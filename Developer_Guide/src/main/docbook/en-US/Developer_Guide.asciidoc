= Developer Guide
:doctype: book
:docinfo: docinfo
:imagesDir: images

[[chap-Developer_Guide-Introduction]]

== Introduction

The RichFaces framework is a rich component library for JavaServer Faces ([acronym]#JSF#). The framework extends the Ajax capabilities of JSF with advanced features for the development of enterprise web applications.

RichFaces leverages several parts of the JSF 2 framework including the lifecycle, validation, conversion facilities, and management of static and dynamic resources. The RichFaces framework includes components with built-in Ajax support and a customizable look-and-feel that can be incorporated into JSF applications.

RichFaces provides a number of advantages for enterprise web application development:

* Create complex application views using out-of-the-box components. The RichFaces user interface ([acronym]#UI#) library contains components for adding rich interactive features to JSF applications. It extends the RichFaces framework to include a large set of Ajax-enabled components that come with extensive skinning support. Additionally, the RichFaces framework is designed to be used seamlessly with other 3d-party libraries on the same page, so you have more options for developing applications.

* Write your own customized rich components with built-in Ajax support. The Component Development Kit ([acronym]#CDK#), used for the RichFaces UI library creation, includes a code-generation facility and a templating facility using [acronym]#XHTML# (extended hyper-text markup language) syntax.

* Generate binary resources on the fly. Extensions to JSF 2 resource-handling facilities can generate images, sounds, [application]#Microsoft Excel# spreadsheets, and more during run-time.

* Create a modern rich user-interface with skinning technology. RichFaces provides a skinning feature that allows you to define and manage different color schemes and other parameters of the look and feel. It is possible to access the skin parameters from page code during run-time. RichFaces comes packaged with a number of skins to get you started, but you can also easily create your own customized skins too.

[[chap-Developer_Guide-Getting_started_with_RichFaces]]

== Getting started with RichFaces

Follow the instructions in this chapter to configure the RichFaces framework and get started with application development.

If you have existing projects that use a previous version of RichFaces, refer to the *_RichFaces Migration Guide_* .

[[sect-Developer_Guide-Getting_started_with_RichFaces-Technical_Requirements]]

=== Technical Requirements

The minimum technical requirements needed to get started with RichFaces are outlined below.

* Java Development Kit ([acronym]#JDK#) 6 or higher
* An application server compliant with Java Platform, Enterprise Edition 6 ([acronym]#JEE6#), such as [productname]#JBoss EAP 6#, [productname]#WildFly# or a servlet container coupled with a JSF implementation, such as Apache Tomcat + Mojarra 2.x.
* A compliant web browser, (see the section on <<sect-Component_Reference-RichFaces_overview-Client_requirements>> for further details)


[[sect-Developer_Guide-Getting_started_with_RichFaces-Technical_Requirements-Project_libraries_and_dependencies]]

==== Project libraries and dependencies

The RichFaces library is distributed across three jars providing all the components and services of the RichFaces framework.

.RichFaces Library
* [filename]+richfaces-core.jar+
* [filename]+richfaces-a4j.jar+
* [filename]+richfaces-rich.jar+

The framework depends on both mandatory and optional third-party dependencies.  Some of the framework services are only enabled when the optional libraries are present.

Note that these dependencies may further depend on their own runtime dependencies.

.Mandatory third-party dependencies
* Java Server Faces 2.x implementation
** [filename]+javax.faces.jar+ (version [code]+2.1.28+ or higher)
** or [filename]+myfaces-impl.jar+ (version [code]+2.1.10+ or higher)

* Google Guava
** [filename]+guava.jar+ (version [code]+18.0+)

* CSS Parser
** [filename]+cssparser.jar+ (version [code]+0.9.14+)

* Simple API for CSS
** [filename]+sac.jar+ (version [code]+1.3+)

.Optional third-party dependencies

* Bean validation (JSR-303) integration for client-side validation (JSR-303 API and Implementation)
** [filename]+validation-api.jar+ (version [code]+1.0.0.GA+)
** [filename]+hibernate-validator.jar+ (version [code]+4.3.2.Final)

* Push transport library - Atmosphere (without dependencies)
** [filename]+atmosphere-runtime.jar+ (version [code]+2.2.3+)
+
(selected compatibility modules [filename]+atmosphere-compat-*.jar+ may be necessary)

* Push JMS integration (JMS API and Implementation)
** [filename]+jms.jar+ (version [code]+1.1+)
** [filename]+hornetq-jms.jar+ (version [code]+2.2.7.Final+ or higher)

* Push CDI integration (CDI API and Implementation)
** [filename]+cdi-api.jar+ (version [code]+1.0-SP4+)
** [filename]+javax.inject.jar+ (version [code]+1+)
** [filename]+jsr-250-api.jar+ (version [code]+1.0+)
** [filename]+weld-servlet.jar+ (version [code]+2.2.6.Final+)

* Extended caching (EhCache)
** [filename]+ehcache.jar+ (version [code]+2.8.3+)

[NOTE]
.Dependencies for servlet containers
====
Some of the dependencies are part of the Java EE 6 specification and thus it is not necessary to include them in projects running on Java EE applications servers.  It is still necessary to include them when using servlet containers.

This does not apply to dependencies on the Servlet API: the JSP API and the EL API.  These APIs are integral parts of both application servers and servlet containers.
====

[[sect-Developer_Guide-Getting_started_with_RichFaces-Development_environments]]

=== Development environments

RichFaces applications can be developed using a range of tools, including integrated development environments ([acronym]++IDE++s). This chapter covers only two such environments in detail:

* [productname]#JBoss Developer Studio#, as described in <<sect-Developer_Guide-Getting_started_with_RichFaces-Creating_a_project_with_JBoss_Tools>>.
* [productname]#Maven#, as described in <<sect-Developer_Guide-Getting_started_with_RichFaces-Creating_a_project_with_Maven>>.


Other development environments such as [productname]#Idea# or [productname]#NetBeans# could also be used for RichFaces development, but such usage is not detailed in this book.

[[sect-Developer_Guide-Getting_started_with_RichFaces-Setting_up_RichFaces]]

=== Setting up RichFaces

Follow the instructions in this section to set up a project with the RichFaces framework and begin building applications.

. *Download the RichFaces archive*
+
Download RichFaces from the JBoss RichFaces Downloads area at http://www.jboss.org/richfaces/download.html. The binary files (available as a [filename]+.zip+ archive) contain the following:
+
* compiled, ready-to-use Java Archives ([acronym]#JAR# files) of the RichFaces library
* library source JAR files
* documentation, including Java documentation and JavaScript documentation
* archetypes
* example source code

. *Unzip the archive*
+
Create a new directory named [filename]+RichFaces+, then unzip the archive that contains the binaries into this new directory.

[[sect-Developer_Guide-Getting_started_with_RichFaces-Creating_a_project_with_JBoss_Tools]]

=== Creating a project with [productname]#JBoss Developer Studio#

Follow the procedure in this section to create a new RichFaces application with [productname]#JBoss Developer Studio#.  Ensure you are using the latest version of [productname]#JBoss Developer Studio# to take advantage of the latest feautures and stability improvements.

. *Create a new project*
+
Create a new project based on the JSF 2 environment using the RichFaces 4 template. In [productname]#JBoss Developer Studio#, select menu:File[New JSF Project] from the menu. Name the project, select [guilabel]#JSF 2# from the [guilabel]#JSF Environment# drop-down box, and click the [guibutton]#Finish# button to create the project.
+
If necessary, update the JSF 2 JAR files to the latest versions.
+
. *Add the RichFaces libraries to the project*
+
[[step-Developer_Guide-Creating_a_project-Add_the_RichFaces_libraries_to_the_project]]
Add the <<sect-Developer_Guide-Getting_started_with_RichFaces-Technical_Requirements-Project_libraries_and_dependencies,RichFaces libraries and their mandatory dependencies>> to the project. Copy them from the location where you unzipped the RichFaces archive to the [filename]+WebContent/WEB-INF/lib/+ directory of your project in [application]#JBoss Developer Studio#.
+
. *[[step-Developer_Guide-Creating_a_project-Reference_the_tag_libraries]]Reference the tag library*
+
The RichFaces tag libraries must be referenced on each XHTML page in your project:
+
[source, XML]
----
<ui:composition xmlns:rich="http://richfaces.org/rich">
<ui:composition xmlns:a4j="http://richfaces.org/a4j">
   ...
</ui:composition>

----

You are now ready to begin developing your RichFaces application. RichFaces components can be dragged and dropped from the [productname]#JBoss Developer Studio# RichFaces palette into your application's XHTML pages.

[[sect-Developer_Guide-Getting_started_with_RichFaces-Creating_a_project_with_Maven]]

=== Creating a project with [productname]#Maven#

[productname]#Apache Maven# is a build automation and project management tool for Java projects. Follow the instructions in this section to create a [productname]#Maven# project for [productname]#RichFaces#.

[[sect-Component_Using_RichFaces_with_Maven-Setting_up_Maven]]

==== Setting up [productname]#Maven#

[productname]#Maven# can be downloaded and installed from Apache's website at http://maven.apache.org/download.html. Due to the use of dependency importing, [productname]#Maven# version 3.0.4 or above is required.

Once [productname]#Maven# has been installed, no further configuration is required to begin building Maven projects.

[[sect-Component_Reference-Using_RichFaces_with_Maven-Using_the_RichFaces_project_archetype]]

==== Using the [productname]#RichFaces# project archetype

A Maven archetype is a template for creating projects. [productname]#Maven# uses an archetype to generate a directory structure and files for a particular project, as well as creating [filename]+pom.xml+ files that contain build instructions.

The RichFaces distribution includes a Maven archetype named [filename]+richfaces-archetype-simpleapp+ for generating the basic structure and requirements of a RichFaces application project. Maven can obtain the archetype from maven central at http://search.maven.org. The archetype is also included with the RichFaces distribution in the [filename]+archetypes+ directory. Follow the procedure in this section to generate a new Maven-based RichFaces project using the archetype.

. Generate the project from the archetype
+
The project can be generated with the [filename]+richfaces-archetype-simpleapp+ archetype. Create a new directory for your project, then run the following Maven command in the directory:
+
----
mvn archetype:generate -DarchetypeGroupId=org.richfaces.archetypes -DarchetypeArtifactId=richfaces-archetype-simpleapp -DarchetypeVersion=4.5.7.Final -DgroupId=org.docs.richfaces -DartifactId=new_project
----
+
The following parameters can be used to customize your project:
+
_-DgroupId_:: Defines the package for the Managed Beans
_-DartifactId_:: Defines the name of the project
+
The command generates a new RichFaces project with the following structure:
+
----
new_project
├── pom.xml
├── readme.txt
└── src
    └── main
        ├── java
        │   └── org
        │       └── docs
        │           └── richfaces
        │               └── RichBean.java
        └── webapp
            ├── index.xhtml
            ├── templates
            │   └── template.xhtml
            └── WEB-INF
                ├── faces-config.xml
                └── web.xml
----

. *Add test dependencies (optional)*
+
Your root directory of your project contains a project descriptor file: [filename]+pom.xml+. If you wish to include modules for test-driven JSF development, add any dependencies for the tests to the [filename]+pom.xml+ file.
+
For testing the server-side part of your application, check out [productname]#link:$$http://www.jboss.org/arquillian$$[JBoss Arquillian project]#.
+
If you want to test JSF from client's perspective with ability to access state of JSF internals, use [productname]#link:$$https://github.com/arquillian/arquillian-extension-warp/blob/master/README.md$$[Arquillian Warp]#.
+
For automation of client-side tests in real-browser, you may want to employ [productname]#link:$$http://community.jboss.org/wiki/ArquillianGraphene$$[Arquillian Graphene]# and [productname]#link:$$https://docs.jboss.org/author/display/ARQ/Drone$$[Arquillian Drone]# extensions.

. *Build the project*
+
Build the project from the command line by entering the _mvn install_ command.
+
The *BUILD SUCCESSFUL* message indicates the project has been assembled and is ready to import into an IDE (integrated development environment), such as [productname]#JBoss Developer Studio#.

. *Import the project into an IDE*
+
To import the project into [productname]#Eclipse# and [productname]#JBoss Developer Studio#, open the importing wizard by choosing menu:File[Import] from the menu.

.. *Select the project*
+
Select menu:Maven[Existing Maven Projects] as the import source and choose the directory with the [filename]+pom.xml+ file for your project.

[NOTE]
.Exporting from Maven
====
The ability to prepare the project for Eclipse and export it using Maven is deprecated in RichFaces 4.5.7.Final. The process does not support JBoss integration-specific features, such as JSF Facets.
====

Your project is now ready to use. Once components and functionality have been added, you can run the application on a server and access it through a web browser at the address [filename]+http://localhost:8080/jsf-app/+ (where jsf-app is the name of your project).

[[sect-Developer_Guide-Getting_started_with_RichFaces-Using_RichFaces_in_existing_JSF2_projects]]

=== Using RichFaces in existing JSF 2 projects

RichFaces can be added to existing JSF 2 projects by adding the new RichFaces libraries. Refer to <<step-Developer_Guide-Creating_a_project-Add_the_RichFaces_libraries_to_the_project, Step 2>> and <<step-Developer_Guide-Creating_a_project-Reference_the_tag_libraries, Step 3>> in <<sect-Developer_Guide-Getting_started_with_RichFaces-Creating_a_project_with_JBoss_Tools>> for details.

[NOTE]
.Application-level settings
====
In RichFaces 4, it is not necessary to add any extra settings to the [filename]+web.xml+ or [filename]+config.xml+ settings files to use the framework.
====

[[chap-Developer_Guide-RichFaces_overview]]

== RichFaces overview

Read this chapter for technical details on the RichFaces framework.

[[sect-Component_Reference-RichFaces_overview-Full_technical_requirements]]

=== Full technical requirements

RichFaces has been developed with an open architecture to be compatible with a wide variety of environments.

[[sect-Component_Reference-RichFaces_overview-Server_requirements]]

==== Server requirements

RichFaces 4 requires either of the following server technologies:

* An application server compliant with Java Platform, Enterprise Edition 6 ([acronym]#JEE6# or [acronym]#JEE6#), such as [productname]#JBoss EAP 6.2.3+# or [productname]#WildFly 8.0.0.Final+#.
* A major servlet container, such as [productname]#Jetty 8# or [productname]#Apache Tomcat 7#.


[[sect-Component_Reference-RichFaces_overview-Client_requirements]]

==== Client requirements

Clients accessing RichFaces applications require a web browser. For a list of supported web browsers, refer to the link:$$https://community.jboss.org/wiki/PrioritizedRichFacesBrowsersCompatibilityMatrix$$[browser compatibility matrix] in the RichFaces wiki.

[[sect-Component_Reference-RichFaces_overview-Development_requirements]]

==== Development requirements

Developing applications with the RichFaces framework requires the Java Development Kit ([acronym]#JDK#), an implementation of JavaServer Faces ([acronym]#JSF#), and a development environment.

Java Development Kit ([acronym]#JDK#):: RichFaces supports the following JDK versions:
+
* JDK 1.6 and higher

JavaServer Faces ([acronym]#JSF#):: RichFaces supports the following JSF implementations and frameworks:
+
* [productname]#MyFaces 2.x#
* [productname]#Mojara 2.x#

Development environment:: RichFaces can be developed using most Java development environments.  The following are recommended, and used for examples in this guide:
+
* [productname]#JBoss Developer Studio 6.x# and higher
* [productname]#Maven 3.0.4# and higher


[[sect-Developer_Guide-RichFaces_overview-Architecture]]

=== Architecture

The important elements of the RichFaces framework are as follows:

* Ajax Action Components
* Ajax Containers
* Ajax Output
* Skins and Theming
* RichFaces Ajax Extensions


Read this section for details on each element.

[[sect-Developer_Guide-Architecture-Ajax_Action_Components]]

==== Ajax Action Components

The RichFaces framework includes several Ajax Action Components and Submitting Bahaviors: [sgmltag]+<a4j:commandButton>+, [sgmltag]+<a4j:commandLink>+, [sgmltag]+<a4j:poll>+, [sgmltag]+<a4j:ajax>+, and more. Use Ajax Action Components to send Ajax requests from the client side.

[[sect-Developer_Guide-Architecture-Ajax_Containers]]

==== Ajax Containers

[classname]+AjaxContainer+ is an interface that marks part of the JSF tree that is decoded during an Ajax request. It only marks the JSF tree if the component or behavior sending the request does not explicitly specify an alternative. [classname]+AjaxRegion+ is an implementation of this interface.

[[sect-Developer_Guide-Architecture-Ajax_Output]]

==== Ajax Output

[classname]+AjaxContainer+ is an interface that marks part of the JSF tree that will be updated and rendered on the client for every Ajax request. It only marks the JSF tree if the component or behavior sending the request does not explicitly turn off automatic updates.

[[sect-Developer_Guide-Architecture-Skins_and_theming]]

==== Skins and theming

RichFaces includes extensive support for application skinning. Skinning is a high-level extension to traditional [acronym]#CSS# (Cascading Style Sheets) which allows the color scheme and appearance of an application to be easily managed. The skins simplify look-and-feel design by allowing multiple elements of the interface to be handled as manageable features, which have associated color palettes and styling. Application skins can additionally be changed on the fly during run-time, allowing user experiences to be personalized and customized.

For full details on skinning and how to create skins for the components in your application, refer to <<chap-Developer_Guide-Skinning_and_theming>>.

[[sect-Developer_Guide-Architecture-RichFaces_Ajax_Extensions]]

==== RichFaces Ajax Extensions

The RichFaces Ajax Extensions plug in to the standard JSF 2 Ajax script facility. They extend the script facility with new features and options.

[[sect-Developer_Guide-RichFaces_overview-Technologies]]

=== Technologies

RichFaces 4 features full JSF 2 integration and uses standard web application technologies such as JavaScript, [acronym]#XML# (Extensible Markup Language), and [acronym]#XHTML# (Extensible Hypertext Markup Language).

[[sect-Developer_Guide-RichFaces_overview-Differences_between_JSF_and_RichFaces_mechanisms]]

=== Differences between [acronym]#JSF# and RichFaces mechanisms

JavaServer Faces 2 evaluates Ajax options, such as [code]+execute+ and [code]+render+, while rendering a page. This allows any parameters to be sent directly from the client side.

RichFaces evaluates the options when the current request is sent. This increases both the security of the data and the convenience for evaluating parameters.

For example, binding Ajax options to Java Bean properties in RichFaces allows you to evaluate the options dynamically for the current request, such as defining additional zones to render. Parameters changed manually on the client side will not influence the request processing. With JSF 2, the options have evaluated during the previous page rendering would need to be used.

[[sect-Developer_Guide-RichFaces_overview-Restrictions]]

=== Restrictions

The following restrictions apply to applications implementing the RichFaces framework:

* As with most Ajax frameworks, you should not attempt to append or delete elements on a page using RichFaces Ajax, but should instead replace them. As such, elements that are rendered conditionally should not be targeted in the [varname]+render+ attributes for Ajax controls. For successful updates, an element with the same identifier as in the response must exist on the page. If it is necessary to append code to a page, include a placeholder for it (an empty element).

* JSF 2 does not allow resources such as JavaScript or Cascading Style Sheets ([acronym]#CSS#) to be added if the element requiring the resource is not initially present in the JSF tree. As such, components added to the tree via Ajax must have any required resources already loaded. In RichFaces, any components added to the JSF tree should have components with corresponding resources included on the main page initially. To facilitate this, components can use the [code]+rendered="false"+ setting to not be rendered on the page.

* JSF does render resource links (stylesheets, scripts) in order of occurence, thus if you add [code]+<h:outputStylesheet>+ to the [code]+<h:head>+ section, JSF will render it before the RichFaces resource links (dependencies of RichFaces components). To be able to overwrite RichFaces stylesheets and re-use RichFaces JavaScript implementation, you need to render [code]+<h:outputStylesheet target="head">+ to the [code]+<h:body>+ section (safe solution is to place it on the end of the section; however to keep readability, you can use start of the section).

* Switching RichFaces skins via Ajax during runtime should be avoided, as this requires all the stylesheets to be reloaded.

[[chap-Developer_Guide-Basic_concepts]]

== Basic concepts

Read this chapter for the basic concepts of using RichFaces in conjunction with Ajax and JavaServer Faces.

[[sect-Developer_Guide-Basic_concepts-Sending_an_Ajax_request]]

=== Sending an Ajax request

Many of the tags in the [classname]+r+ tag library are capable of sending Ajax requests from a JavaServer Faces (JSF) page.

* The [sgmltag]+<a4j:commandButton>+ and [sgmltag]+<a4j:commandLink>+ tags are used to send an Ajax request on the [varname]+click+ JavaScript event.
* The [sgmltag]+<a4j:poll>+ tag is used to send an Ajax request periodically using a timer.
* The [sgmltag]+<a4j:ajax>+ tag allows you to add Ajax functionality to standard JSF components and send Ajax request on a chosen JavaScript event, such as [varname]+keyup+ or [varname]+mouseover+, for example.
* Most components in the [classname]+r+ tag library have built-in Ajax support. Refer to the *_RichFaces Component Reference_* for details on the use of each component.


[[sect-Developer_Guide-Basic_concepts-Partial_tree_processing]]

=== Partial tree processing

Use the [varname]+execute+ attribute to specify which parts of the JSF tree to process during an Ajax request. The [varname]+execute+ attribute can point to an [varname]+id+ identifier of a specific component to process. Components can also be identified through the use of Expression Language ([acronym]#EL#).

Alternatively, the [varname]+execute+ attribute accepts the following keywords:

[code]+@all+:: Every component is processed.
[code]+@none+:: No components are processed.
[code]+@this+:: The requesting component with the [varname]+execute+ attribute is processed.
[code]+@form+:: The form that contains the requesting component is processed.
[code]+@region+:: The region that contains the requesting component is processed. Use the [sgmltag]+<a4j:region>+ component as a wrapper element to specify regions.
Some components make use of additional keywords. These are detailed under the relevant component entry in the *_RichFaces Component Reference_* .

[[sect-Developer_Guide-Basic_concepts-Partial_view_updates]]

=== Partial view updates

Use the [varname]+render+ attribute to specify which components to render for an Ajax update. The [varname]+render+ attribute can point to an [varname]+id+ identifier of a specific component to update. Components can also be identified through the use of Expression Language ([acronym]#EL#).

Alternatively, the [varname]+render+ attribute accepts the following keywords:

[code]+@all+:: Every component is updated.
[code]+@none+:: No components are updated.
[code]+@this+:: The requesting component with the [varname]+execute+ attribute is updated.
[code]+@form+:: The form that contains the requesting component is updated.
[code]+@region+:: The region that contains the requesting component is updated. Use the [sgmltag]+<a4j:region>+ component as a wrapper element to specify regions.

Some components make use of additional keywords. These are detailed under the relevant component entry in the *_RichFaces Component Reference_* .

Use the [sgmltag]+<a4j:outputPanel>+ component with the [code]+ajaxRendered="true"+ setting to always update a section irrespective of the requesting component's [varname]+render+ attribute. The [sgmltag]+<rich:message>+ and [sgmltag]+<rich:messages>+ components are based on the [sgmltag]+<a4j:outputPanel>+ component, and as such will also always be updated. To override this behavior, use the [code]+limitRender="true"+ setting on the requesting component.

[[sect-Developer_Guide-Basic_concepts-Component_overview]]

=== Component overview

The RichFaces framework is made up of two tag libraries: the [classname]+rich+ and [classname]+a4j+ libraries. The [classname]+a4j+ tag library includes both the low-level ajax functionality, while the [classname]+rich+ tag library includes the high-level components for building web applications.  This allows developers to make use of custom Ajax behavior with existing componentsas well as leverage the many ready-made, self-contained components. These components don't require additional configuration in order to send requests or update.

For details on the use of the various components, refer to *_RichFaces Component Reference_* .

[[chap-Developer_Guide-Advanced_features]]

== Advanced features

Read this chapter for details on some of the advanced features and configuration possibilities for the RichFaces framework.

[[sect-Developer_Guide-Advanced_features-JSF2_integration]]

=== JSF 2 integration

JavaServer Faces ([acronym]#JSF#) is the Java-based web application framework upon which the RichFaces framework has been built. RichFaces is now integrated with JSF 2, which features several improvements to the framework.

* The standard display technology used by JSF 1 was JavaServer Pages ([acronym]#JSP#). With JSF 2, the standard display technology has been changed to Facelets, which is a more powerful and more efficient View Declaration Language ([acronym]#VLD#) than JSP.


[[sect-Developer_Guide-Advanced_features-Error_handling]]

=== Error handling

RichFaces allows standard handlers to be defined for processing different application exceptions. Custom JavaScript can be executed when these exceptions occur.

[[sect-Developer_Guide-Advanced_features-Client-side_errors]]

==== Client-side errors

JSF provides a global [code]+onError+ handler on the client. The handler provides the relevant error code and other associated data. The RichFaces Ajax components provide the [varname]+error+ attribute if extra functionality needs to be defined.

Additional processing is available through a number of components, such as the following:

* The [sgmltag]+<a4j:status>+ component has an additional error state.
* The [sgmltag]+<a4j:queue>+ component can be used to process errors.


[[sect-Developer_Guide-Advanced_features-Server-side_errors]]

==== Server-side errors

Use the JSF 2 [classname]+ExceptionHandler+ class to handle server-side errors such as session expiration.

[[sect-Developer_Guide-Advanced_features-Other_functions]]

=== Other functions

RichFaces provides a number of advanced functions, such as managing user roles and identifying elements. Refer to the *_Functions_* chapter in the *_RichFaces Component Reference_* for further details.

[[sect-Developer_Guide-Advanced_features-Resource_loading]]

=== Resource loading

The RichFaces improves a standard JSF resource handling in order to achieve following features:

* resource optimization - serves optimized component resource dependencies (JavaScript, CSS)
* resource mapping - re-routes resource requests (maps an one resource to an another resource)


[[sect-Developer_Guide-Advanced_features-Configuring_ResourceServlet]]

==== Configuring ResourceServlet

For leveraging RichFaces resource loading improvements, the [sgmltag]+ResourceServlet+ needs to be registered.

[sgmltag]+ResourceServlet+ is automatically registered in the Servlet 3.0 and higher environments.

In the Servlet 2.5 and lower environments, it is necessary to register the [sgmltag]+ResourceServlet+ manually in the [sgmltag]+WEB-INF/web.xml+ configuration file:


[source, XML]
----
<servlet>
    <servlet-name>Resource Servlet</servlet-name>
    <servlet-class>org.richfaces.webapp.ResourceServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>Resource Servlet</servlet-name>
    <url-pattern>/org.richfaces.resources/*</url-pattern>
</servlet-mapping>
----

[[sect-Developer_Guide-Advanced_features-Resource_optimization]]

==== Resource optimization

The resource optimization feature provides optimized component dependencies - JavaScript, CSS - which are compressed and aggregated to resource packages.

The loading of compressed resource packages may lead into significant client performance boost, since many small files are aggregated into one big file - the number of HTTP connections necessary to download application resources is significantly decreased.

.Enabling resource optimization
====

To enable the resource optimization, add a following configuration to [code]+web.xml+:


[source, XML]
----
<context-param>
    <param-name>org.richfaces.resourceOptimization.enabled</param-name>
    <param-value>true</param-value>
</context-param>
----

====

.Resource optimization in development JSF project stage
====

Resource optimization is influenced by the project stage:

* resources are not compressed in the development stage and during unit-testing to enable client-side debugging
* resources are compressed in the production stage and during a system-testing to minimize network bandwidth


Switch to the development project stage during a development:


[source, XML]
----
<context-param>
    <param-name>javax.faces.PROJECT_STAGE</param-name>
    <param-value>Development</param-value>
</context-param>
----

====

[[sect-Developer_Guide-Advanced_features-Resource_mapping]]

==== Resource mapping

The resource mapping feature maps an existing JSF resource (determined by library and name) to a another resource.

This feature can help to solve the following cases:

* providing alternative versions of JSF resources
* map several JSF resources to one
* using external resources
* moving resources to servers serving static content


===== Resource mapping configuration file

Configuring the resource mapping means adding new records to the class-path file [code]+META-INF/richfaces/static-resource-mappings.properties+.

Each line in the configuration file represents one relocation.

A following sample shows a JSF resource with the name [code]+resourceLibrary:resourceName+ relocated to a resource [code]+anotherResourceLibrary:anotherResourceName+:

----
resourceLibrary\:resourceName=anotherResourceLibrary/anotherResourceName
----

[NOTE]
.Mapping resource name to relative URL
====
The definition above contains a JSF resource name on the left side of the expression and a relative path on the right side.

The expression on the right side represents a path relative to a JSF resource root, thus resource path [code]+anotherResourceLibrary/anotherResourceName+ actually maps to a JSF resource with name [code]+anotherResourceLibrary:anotherResourceName+.
====

[NOTE]
.Additional mapping files
====
It is possible to define additional resource mapping configuration files by using a contextual parameter identifying the class-path locations where the files reside: [code]+org.richfaces.resourceMapping.mappingFile+ (a comma-separated list of the class-path files).
====

===== Examples of resource mapping

.Providing alternative file
====

All requests for [code]+jquery.js+ are served as requests for [code]+jquery-alternative-version.js+:

----
jquery.js=jquery-alternative-version.js
----

====

.Mapping several resources to one
====

Both [code]+some:jquery.js+ and [code]+another:jquery.js+ are mapped to [code]+final:jquery.js+:

----
some\:jquery.js=final/jquery.js
another\:jquery.js=final/jquery.js
----

====

.Using external resources
====

Mappings with a resource path starting with [code]+http://+ or [code]+https://+ are served as absolute resource locations:

A following sample instructs to load [code]+jquery.js+ from CDN:

----
jquery.js=http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js
----

====

[[chap-Developer_Guide-Skinning_and_theming]]

== Skinning and theming

Read this chapter for a guide to skinning and theming RichFaces applications, including how to implement themes, and details on customizing and extending skins.

[[sect-Developer_Guide-Skinning_and_theming-What_are_skins]]

=== What are skins?

Application skins are used with the RichFaces framework to change the appearance of an application through setting the colors and decoration of controls and components. Typically the appearance of web applications is handled through the [acronym]#CSS# (Cascading Style Sheet) files associated with the application, but skinning allows the settings in a CSS file to be abstracted and easily edited. Skins consist of a small, generalized set of font and color parameters that can be applied to multiple different styles. This avoids repetitive coding and duplication in CSS files. CSS files are not completely replaced: skins work as a high-level extension to standard CSS.

Each skin has a set of [varname]+skin-parameters+, which are used to define the theme palette and other elements of the user interface. These parameters work together with regular CSS declarations, and can be referred to from within CSS using JavaServer Faces Expression Language ([acronym]#EL#).

The skinning feature of RichFaces also allows skins to be changed at runtime, so users can personalize an application's appearance on the fly.

[[sect-Developer_Guide-Skinning_and_theming-Using_skins]]

=== Using skins

RichFaces includes a number of predefined skins. These skins can be used in RichFaces web applications by specifying the skin name in the [varname]+org.richfaces.skin+ context parameter in the [filename]+web.xml+ settings file. The predefined skins are as follows:

* +DEFAULT+
* +plain+, which contains no skin parameters and is intended for embedding RichFaces components into existing projects with their own styles.
* +emeraldTown+
* +blueSky+
* +wine+
* +japanCherry+
* +ruby+
* +classic+
* +deepMarine+


To add one of these skins to your application, add the +org.richfaces.SKIN+ context parameter to the [filename]+web.xml+ configuration file:

[source, XML]
----
<context-param>
    <param-name>org.richfaces.skin</param-name>
    <param-value>skin_name</param-value>
</context-param>
----

[[sect-Developer_Guide-Skinning_and_theming-Skinning_overview]]

=== Skinning overview

RichFaces skins are implemented using the following three-level scheme:

Component stylesheets:: Stylesheets are provided for each component. CSS style parameters map to skin parameters defined in the skin property file. This mapping is accomplished through the use of ECSS files. Refer to <<sect-Developer_Guide-Skinning_and_theming-ECSS_files>> for details on ECSS files.

Skin property files:: Skin property files map skin parameters to constant styles. Skin properties are defined in [filename]+skin.properties+ files. Refer to <<sect-Developer_Guide-Skinning_overview-Skin_parameter_tables>> for a listing of the skin parameters used in a typical skin.

Custom style classes:: Individual components can use the [varname]+styleClass+ attribute to redefine specific elements. These components then use the styles defined in a CSS file instead of the standard look for components as defined by the ECSS stylesheets.
[[sect-Developer_Guide-Skinning_overview-Skin_parameter_tables]]

==== Skin parameter tables

<<tabl-Developer_Guide-Skin_parameter_tables_in_RichFaces-Parameter_settings_for_the_blueSky_skin>> lists the default values for the parameter settings in the +blueSky+ skin. These values are all listed in the [filename]+blueSky.skin.properties+ file, which can be customized and extended as described in <<sect-Developer_Guide-Skinning_and_theming-Customizing_skins>>.

[[tabl-Developer_Guide-Skin_parameter_tables_in_RichFaces-Parameter_settings_for_the_blueSky_skin]]

.Parameter settings for the +blueSky+ skin
[options="header"]
|===============
|Parameter name|Default value
|[parameter]+headerBackgroundColor+|+#BED6F8+
|[parameter]+headerGradientColor+|+#F2F7FF+
|[parameter]+headTextColor+|+#000000+
|[parameter]+headerWeightFont+|+bold+
|[parameter]+generalBackgroundColor+|+#FFFFFF+
|[parameter]+generalTextColor+|+#000000+
|[parameter]+generalSizeFont+|+11px+
|[parameter]+generalFamilyFont+|+Arial, Verdana, sans-serif+
|[parameter]+controlTextColor+|+#000000+
|[parameter]+controlBackgroundColor+|+#FFFFFF+
|[parameter]+additionalBackgroundColor+|+#ECF4FE+
|[parameter]+shadowBackgroundColor+|+#000000+
|[parameter]+shadowOpacity+|+1+
|[parameter]+panelBorderColor+|+#BED6F8+
|[parameter]+subBorderColor+|+#FFFFFF+
|[parameter]+calendarWeekBackgroundColor+|+#F5F5F5+
|[parameter]+calendarHolidaysBackgroundColor+|+#FFEBDA+
|[parameter]+calendarHolidaysTextColor+|+#FF7800+
|[parameter]+calendarCurrentBackgroundColor+|+#FF7800+
|[parameter]+calendarCurrentTextColor+|+#FFEBDA+
|[parameter]+calendarSpecBackgroundColor+|+#E4F5E2+
|[parameter]+calendarSpecTextColor+|+#000000+
|[parameter]+editorBackgroundColor+|+#F1F1F1+
|[parameter]+editBackgroundColor+|+#FEFFDA+
|[parameter]+errorColor+|+#FF0000+
|[parameter]+gradientType+|+plain+
|[parameter]+tabBackgroundColor+|+#C6DEFF+
|[parameter]+tabDisabledTextColor+|+#8DB7F3+
|[parameter]+tableHeaderBackgroundColor+|+#D6E6FB+
|[parameter]+tableSubHeaderBackgroundColor+|+#ECF4FE+
|[parameter]+tableBorderWidth+|+1px+
|[parameter]+tableHeaderTextColor+|+#0B356C+
|[parameter]+trimColor+|+#D6E6FB+
|[parameter]+tipBackgroundColor+|+#FAE6B0+
|[parameter]+tipBorderColor+|+#E5973E+
|[parameter]+selectControlColor+|+#E79A00+
|[parameter]+generalLinkColor+|+#0078D0+
|[parameter]+hoverLinkColor+|+#0090FF+
|[parameter]+visitedLinkColor+|+#0090FF+
|[parameter]+headerSizeFont+|+11px+
|[parameter]+headerFamilyFont+|+Arial, Verdana, sans-serif+
|[parameter]+tabSizeFont+|+11px+
|[parameter]+tabFamilyFont+|+Arial, Verdana, sans-serif+
|[parameter]+buttonSizeFont+|+11px+
|[parameter]+buttonFamilyFont+|+Arial, Verdana, sans-serif+
|[parameter]+tableBackgroundColor+|+#FFFFFF+
|[parameter]+tableFooterBackgroundColor+|+#CCCCCC+
|[parameter]+tableSubfooterBackgroundColor+|+#F1F1F1+
|[parameter]+tableBorderColor+|+#C0C0C0+
|[parameter]+warningColor+|+#FFE6E6+
|[parameter]+warningBackgroundColor+|+#FF0000+
|===============

[[sect-Developer_Guide-Skinning_and_theming-Round_corners]]

==== Support for round corners

Support for round borders in your skins is available via the +panelBorderRadius+ skin parameter. The value of this parameter maps to the CSS 3 +border-radius+ property. This CSS 3 property is ignored in older browsers, and the skin gracefully degrades to square corners.

Units of the +panelBorderRadius+ skin parameter must be either +px+ (pixels). or +%+ (a percentage).

[[sect-Developer_Guide-Skinning_and_theming-ECSS_files]]

==== [acronym]#ECSS# files

RichFaces uses [acronym]#ECSS# files to add extra functionality to the skinning process. ECSS files are CSS files which use Expression Language ([acronym]#EL#) to connect styles with skin properties.

[[exam-Developer_Guide-Skinning_and_theming-ECSS_style_mappings]]

.ECSS style mappings
====

The ECSS code for the [sgmltag]+<rich:panel>+ component contains styles for the panel and its body:


[source, Java]
----
.rf-p{
   background-color:'#{a4jSkin.generalBackgroundColor}';
   color:'#{a4jSkin.panelBorderColor}';
   border-width:1px;
   border-style:solid;
   padding:1px;
}

.rf-p-b{
   font-size:'#{a4jSkin.generalSizeFont}';
   color:'#{a4jSkin.generalTextColor}';
   font-family:'#{a4jSkin.generalFamilyFont}';
   padding:10px;
}

----

[classname]+.rf-p+  defines the panel styles::
+
* The [property]+background-color+ CSS property maps to the [parameter]+generalBackgroundColor+ skin parameter.
* The [property]+color+ CSS property maps to the [parameter]+panelBorderColor+ skin parameter.


[classname]+.rf-p-b+  defines the panel body styles::
+
* The [property]+font-family+ CSS property maps to the [parameter]+generalFamilyFont+ skin parameter.
* The [property]+font-size+ CSS property maps to the [parameter]+generalSizeFont+ skin parameter.
* The [property]+color+ CSS property maps to the [parameter]+generalTextColor+ skin parameter.


====

[[sect-Developer_Guide-Skinning_and_theming-Customizing_skins]]

=== Customizing skins

Skins in RichFaces can be customized on each of the three levels:

Skin property files:: Application interfaces can be modified by altering the values of skin parameters in the skin itself. Edit the constant values defined in the [filename]+skin.properties+ file to change the style of every component mapped to that skin property.
Component stylesheets:: Mappings and other style attributes listed in a component's ECSS file can be edited. Edit the ECSS file to change the styles of all components of that type.
Custom components style classes:: Individual components can use the [varname]+styleClass+ attribute to use a unique style class. Add the new style class to the application CSS and reference it from an individual component with the [varname]+styleClass+ attribute.
Overwriting stylesheets in application:: You can load custom stylesheets using [code]+<h:outputStylesheet>+ which rewrites of extends styles defined for style classes of components.
[NOTE]
.Customizing skins by rewriting/extending component style classes
====
If you want to extend/overwrite style sheet definitions with own stylesheets, make sure you place definitions to be rendered in right order of occurence (see <<sect-Developer_Guide-RichFaces_overview-Restrictions,Restrictions>> section for details).
====

[[exam-Developer_Guide-Using_skins-Simple_skinning_example]]

.Simple skinning example
====

Using any component, such as a panel, without specifying a [varname]+styleClass+ will use the default skin parameters for that component.


[source, XML]
----
<rich:panel>This is a panel without a header</rich:panel>
----

When rendered for display, the panel consists of two HTML elements: a wrapper [sgmltag]+<div>+ element and a [sgmltag]+<div>+ element for the body of the panel. The wrapper element for a panel without a specified [varname]+styleClass+ is rendered as follows:


[source, XML]
----
<div id="..." class="rf-p">
   <div id="..." class="rf-p-b">
      This is a panel without a header
   </div>
</div>

----

To customize the panel appearance according to the three-level scheme, adjust the styles according to the following approach:

. Change the definitions for the [parameter]+generalBackgroundColor+ or [parameter]+panelBorderColor+ parameters in the skin. This will cause all panels in the application to change to the new settings.

. Redefine the [classname]+rf-p+ class in the application CSS. This will also cause all panels in the application to change to the new settings, though the skin itself has not been altered. Any properties not mapped to skin parameters should be redefined in this way.

. Specify a different [varname]+styleClass+ attribute to style the individual component. If a [varname]+styleClass+ attribute is used, the specified style class is applied to the component, which could extend or override the default styles.
+
--
[source, XML]
----
<rich:panel styleClass="customClass">...</rich:panel>
----

The +customClass+ style is added to the CSS, and is applied to the component when it is rendered for display:

[source, XML]
----
<div class="rf-p customClass">
   ...
</div>
----
--

====

[[sect-Developer_Guide-Customizing_skins-Creating_a_new_skin]]

==== Creating a new skin

. *Create the skin file*
+
The name of the skin file should follow the format [filename]+$$new_skin_name.skin.properties$$+ and is placed in either the [filename]+META-INF/skins/+ directory or the classpath directory of your project.

. *Define the skin constants*
+
* *Define all the skin constants*
+
Add skin parameter constants and values to the file. All the skin parameters listed in <<tabl-Developer_Guide-Skin_parameter_tables_in_RichFaces-Parameter_settings_for_the_blueSky_skin>> should be included in the skin file, with settings relevant to your new skin.
+
[[exam-Developer_Guide-Skinning_and_theming-blueSky.skin.properties_file]]
.[filename]+blueSky.skin.properties+ file
====

Open the [filename]+blueSky.skin.properties+ file from the [filename]+/META-INF/skins+ directory in the ++richfaces-core-_{version}_.jar++ package. The file lists all the skin parameter constants shown in <<tabl-Developer_Guide-Skin_parameter_tables_in_RichFaces-Parameter_settings_for_the_blueSky_skin>>.

You can use the [filename]+blueSky.skin.properties+ file as a template for your new skin.

====
+
* *Extend a base skin*
+
Instead of redefining an entire new skin, your skin can use an existing skin as a base on which to build new parameters. Specify a base skin by using the [varname]+baseSkin+ parameter in the skin file, as shown in <<exam-Developer_Guide-Skinning_and_theming-Using_a_base_skin>>.
+
[[exam-Developer_Guide-Skinning_and_theming-Using_a_base_skin]]
.Using a base skin
====

This example takes the +blueSky+ skin as a base and only changes the [varname]+generalSizeFont+ parameter.

----
baseSkin=blueSky
generalSizeFont=12pt
----

====

. *Reference the skin definition*
+
Add a skin definition [sgmltag]+<context-param>+ to the [filename]+web.xml+ settings file of your application:
+
[source, XML]
----
<context-param>
   <param-name>org.richfaces.skin</param-name>
   <param-value>new_skin_name</param-value>
</context-param>
----

[[sect-Developer_Guide-Skinning_and_theming-Changing_skins_at_runtime]]

=== Changing skins at runtime

To allow users to change skins at runtime, use a managed bean to access the skin.

. *Create the skin bean*
+
The skin bean is a simple interface to manage the skin:
+
[source, Java]
----
public class SkinBean {

    private String skin;

    public String getSkin() {
        return skin;
    }
    public void setSkin(String skin) {
        this.skin = skin;
    }
}

----

. *Reference the skin bean*
+
Add the [code]+@ManagedBean+ and [code]+@SessionScoped+ references to the class.
+
* Alternatively, use [acronym]#EL# (Expression Language) to reference the skin bean from the [filename]+web.xml+ settings file.
+
[source, XML]
----
<context-param>
    <param-name>org.richfaces.skin</param-name>
    <param-value>#{skinBean.skin}</param-value>
</context-param>
----

. *Set initial skin*
+
The application needs an initial skin to display before the user chooses an alternative skin. Specify the skin in your class with [code]+@ManagedProperty+.
+
[source, Java]
----
@ManagedProperty(value="blueSky")
private String skin;
----
+
* Alternatively, specify the initial skin in the [filename]+web.xml+ configuration file.
+
[source, XML]
----
<managed-bean>
    <managed-bean-name>skinBean</managed-bean-name>
    <managed-bean-class>SkinBean</managed-bean-class>
    <managed-bean-scope>session</managed-bean-scope>
    <managed-property>
        <property-name>skin</property-name>
        <value>blueSky</value>
    </managed-property>
</managed-bean>
----

[[sect-Developer_Guide-Skinning_and_theming-Skinning_standard_controls]]

=== Skinning standard controls

Standard HTML controls used alongside RichFaces components are also themed to create a cohesive user interface.

[[sect-Developer_Guide-Skinning_standard_controls-Automatic_skinning]]

==== Automatic skinning

The skinning style properties are automatically applied to controls based on their element names and attribute types. If the HTML elements are referenced in the standard skin stylesheets, the controls will be styled according to the mapped skin properties.

Standard HTML controls are skinned in this way by default. To override this behavior and prevent the RichFaces skins from being applied to the standard HTML controls, set the +org.richfaces.enableControlSkinning+ context parameter in the [filename]+web.xml+ configuration file to +false+:


[source, XML]
----
<context-param>
   <param-name>org.richfaces.enableControlSkinning</param-name>
   <param-value>false</param-value>
</context-param>
----

[[sect-Developer_Guide-Skinning_standard_controls-Skinning_with_the_rfs-ctn_class]]

==== Skinning with the [classname]+rfs-ctn+ class

The skinning style properties can be determined through a separate CSS class. This method is not available by default, but is enabled through the +org.richfaces.enableControlSkinningClasses+ context parameter in the [filename]+web.xml+ configuration file:


[source, XML]
----
<context-param>
   <param-name>org.richfaces.enableControlSkinningClasses</param-name>
   <param-value>true</param-value>
</context-param>
----

When enabled, a stylesheet with predefined classes offers a special CSS class named [classname]+rfs-ctn+. Reference the [classname]+rfs-ctn+ class from any container element (such as a [sgmltag]+<div>+ element) to skin all the standard HTML controls in the container.

Standard HTML controls can also be specifically defined in the CSS. Refer to the [filename]+$$/META-INF/resources/org.richfaces/skinning_both.ecss$$+ file in the ++richfaces-core-_{version}_.jar++ package for examples of specially-defined CSS classes with skin parameters for HTML controls.

[[appe-Developer_Guide-Style_classes_and_skin_parameters]]


[appendix]
== Style classes and skin parameters

Each of the [productname]#RichFaces# components are listed below, along with their style classes and skin parameters. For further details on each component, refer to the relevant section in the *_RichFaces Component Reference_* .

=== Processing management

==== +<a4j:log>+

include::skinning/log.asciidoc[]

=== Rich inputs

==== +<rich:autocomplete>+

include::skinning/autocomplete.asciidoc[]

==== +<rich:calendar>+

include::skinning/calendar.asciidoc[]

==== +<rich:editor>+

include::skinning/editor.asciidoc[]

==== +<rich:fileUpload>+

include::skinning/fileUpload.asciidoc[]

==== +<rich:inplaceInput>+

include::skinning/inplaceInput.asciidoc[]

==== +<rich:inputNumberSlider>+

include::skinning/inputNumberSlider.asciidoc[]

==== +<rich:inputNumberSpinner>+

include::skinning/inputNumberSpinner.asciidoc[]

=== Rich selects

==== +<rich:inplaceSelect>+

include::skinning/inplaceSelect.asciidoc[]

==== +<rich:select>+

include::skinning/select.asciidoc[]

==== +<rich:orderingList>+

include::skinning/orderingList.asciidoc[]

==== +<rich:pickList>+

include::skinning/pickList.asciidoc[]

=== Panels and containers

==== +<rich:panel>+

include::skinning/panel.asciidoc[]

==== +<rich:accordion>+

include::skinning/accordion.asciidoc[]

==== +<rich:collapsiblePanel>+

include::skinning/collapsiblePanel.asciidoc[]

==== +<rich:popupPanel>+

include::skinning/popupPanel.asciidoc[]

==== +<rich:tabPanel>+

include::skinning/tabPanel.asciidoc[]

=== Tables and grids

==== +<rich:dataTable>+

include::skinning/dataTable.asciidoc[]

==== +<rich:collapsibleSubTable>+

include::skinning/collapsibleSubTable.asciidoc[]

==== +<rich:collapsibleSubTableToggler>+

include::skinning/collapsibleSubTableToggler.asciidoc[]

==== +<rich:extendedDataTable>+

include::skinning/extendedDataTable.asciidoc[]

==== +<rich:dataGrid>+

include::skinning/dataGrid.asciidoc[]

==== +<rich:list>+

include::skinning/list.asciidoc[]

==== +<rich:dataScroller>+

include::skinning/dataScroller.asciidoc[]

=== Trees

==== +<rich:tree>+

include::skinning/tree.asciidoc[]

==== +<rich:treeNode>+

include::skinning/treeNode.asciidoc[]

=== Menus and toolbars

==== +<rich:dropDownMenu>+

include::skinning/dropDownMenu.asciidoc[]

==== +<rich:contextMenu>+

include::skinning/contextMenu.asciidoc[]

==== +<rich:panelMenu>+

include::skinning/panelMenu.asciidoc[]

==== +<rich:toolbar>+

include::skinning/toolbar.asciidoc[]

=== Output and messages

==== +<rich:message>+

include::skinning/message.asciidoc[]

==== +<rich:messages>+

include::skinning/messages.asciidoc[]

==== +<rich:notify>+

include::skinning/notify.asciidoc[]

==== +<rich:notifyMessage>+

include::skinning/notifyMessage.asciidoc[]

==== +<rich:notifyStack>+

include::skinning/notifyStack.asciidoc[]

==== +<rich:progressBar>+

include::skinning/progressBar.asciidoc[]

==== +<rich:tooltip>+

include::skinning/tooltip.asciidoc[]

=== Drag and drop

==== +<rich:dropTarget>+

include::skinning/dropTarget.asciidoc[]

==== +<rich:dragIndicator>+

include::skinning/dragIndicator.asciidoc[]

[[appe-Developer_Guide-Migration_Notes]]

[appendix]
== Migration Notes

This section of the guide will track any breaking changes introduced in new releases, and identify any steps required to accommodate those changes in your application.

[[appe-Developer_Guide-Migration_Notes-4_3_0]]

=== RichFaces 4.3.7.Final

==== Autosize changes for the popupPanel

The [sgmltag]+<rich:popupPanel>+ no longer ignores the min and max sizes for width and height when ++autosize=true++.

=== RichFaces 4.3.0.Final

[[appe-Developer_Guide-Migration_Notes-4_3_0-built_in_sorting_and_filtering_controls]]

==== Built-in sorting and filtering controls

The [sgmltag]+<rich:extendedDataTable>+ now has built-in sorting and filtering controls. If you have existing [sgmltag]+<rich:extendedDataTable>+ with custom sort and/or filter controls, you will want to disable the built-in sort and/or filter controls. This can be done either on a column-by-column basis, or for all columns in your applications.

For details on disabling the built-in sort and filter controls, refer to sections "External filter controls" and "External sort controls" in the RichFaces Component Reference.

[[appe-Developer_Guide-Migration_Notes-4_3_0-NotifyMessage_Sting_Escaping]]

==== NotifyMessage string escaping

Prior to version 4.3.0.Final, the message summary and details of the [sgmltag]+<rich:notifyMessage>+ and [sgmltag]+<rich:notifyMessages>+ components were not escaped. In the 4.3.0.Final release, an attribute [varname]+escape+ was added with a default value true.

[[appe-Developer_Guide-Migration_Notes-4_3_0-Select_Input_Validation]]

==== Select input validation

The [sgmltag]+<rich:select>+ now validates that manually entered input values match one of the values of the provided list (including support for client-side validation).
