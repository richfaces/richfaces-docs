= Component Reference
:doctype: book
:docinfo: docinfo
:imagesDir: images

[[chap-Component_Reference-Introduction]]

== Introduction

This book is a guide to the various components available in the RichFaces 4.5.9-SNAPSHOT framework. It includes descriptions of the role of the components, details on how best to use them, coded examples of their use, and basic references of their properties and attributes.

For full references for all component classes and properties, refer to the following supplementary documentation:

* *_VDL (View Definition Language) Documentation_*
** Available at http://docs.jboss.org/richfaces/latest_4_5_X/vdldoc/


* *_Javadoc_*
** Available at http://docs.jboss.org/richfaces/latest_4_5_X/javadoc/


For further examples for each component, refer to the *_RichFaces Showcase_* at http://showcase.richfaces.org/.

[[sect-Component_Reference-Introduction-Libraries]]

=== Libraries

The RichFaces framework is made up of two tag libraries: the [classname]+a4j+ library and the [classname]+rich+ library.

[classname]+a4j+  library:: The [classname]+a4j+ tag library provides core Ajax and utility components.
[classname]+rich+  library:: The [classname]+rich+ tag library provides ready-made, self-contained, rich user-interface components. These components have built-in Ajax support. By default, the components don't require additional configuration in order to send requests or update, but can also be customized by plugging in utility behaviors.
[[chap-Component_Reference-Common_Ajax_attributes]]

== Common Ajax attributes

The Ajax components in the [classname]+a4j+ library share common attributes to perform similar functionality. Most RichFaces components in the [classname]+rich+ library that feature built-in Ajax support share these common attributes as well.

Most attributes have default values, so they need not be explicitly set for the component to function in its default state. These attributes can be altered to customize the behavior of the component if necessary.

[[sect-Component_Reference-Common_Ajax_attributes-Data_processing]]

=== Data processing

The RichFaces Ajax script is built on a base of the JSF 2 Ajax script. As such, each time a request is sent, the data from the requesting component's parent [acronym]#JSF# form is submitted along with the [acronym]#XMLHttpRequest# object. The form data contains values from the input element and auxiliary information such as state-saving data.

[[sect-Component_Reference-Data_processing-execute]]

==== [varname]+execute+

The [varname]+execute+ attribute allows [acronym]#JSF# processing to be limited to defined components. The [varname]+execute+ attribute can point to an [varname]+id+ identifier of a specific component to process. Components can also be identified through the use of Expression Language ( [acronym]#EL#).

Alternatively, the [varname]+execute+ attribute accepts the following keywords:

[code]+@all+:: Every component is processed.
[code]+@none+:: No components are processed.
[code]+@this+:: The requesting component with the [varname]+execute+ attribute is processed. This is the default behavior for components.
[code]+@form+:: The form that contains the requesting component is processed.
[code]+@region+:: The region that contains the requesting component is processed. Use the [sgmltag]+<a4j:region>+ component as a wrapper element to specify regions.

Some components make use of additional keywords. These are detailed under the relevant component entry in this book.

[[sect-Component_Reference-Data_processing-bypassUpdates]]

==== [varname]+bypassUpdates+

If the [varname]+bypassUpdates+ attribute is set to +true+, the Update Model phase of the request processing lifecycle is bypassed. This is useful if user input needs to be validated but the model does not need to be updated. This is the opposite functionality to the [varname]+execute+ attribute in RichFaces.

[[sect-Component_Reference-Common_Ajax_attributes-Rendering]]

=== Rendering

[[sect-Component_Reference-Rendering-render]]

==== [varname]+render+

The [varname]+render+ attribute provides a reference to one or more components on the page that need updating after an Ajax interaction. It uses the [methodname]+UIComponent.findComponent()+ algorithm to find the components in the component tree using their [varname]+id+ identifiers as a reference. Components can be referenced by their [varname]+id+ identifier alone, or by their [varname]+clientId+ identifier to make locating components more efficient. <<exam-Component_Reference-render-render_example>> shows both ways of referencing components. Each command button will correctly render the referenced panel grids, but the second button locates the references more efficiently with explicit [varname]+clientId+ paths.

[[exam-Component_Reference-render-render_example]]

.render example
====


[source, XML]
----
<h:form id="form1">
    <a4j:commandButton value="Basic reference" render="infoBlock, infoBlock2" />
    <a4j:commandButton value="Specific reference" render=":infoBlock,:sv:infoBlock2" />
</h:form>

<h:panelGrid id="infoBlock">
    ...
</h:panelGrid>

<h:form id="sv">
    <h:panelGrid id="infoBlock2">
        ...
    </h:panelGrid>
</h:form>

----

====

The value of the [varname]+render+ attribute can also be an expression written using JavaServer Faces' Expression Language ( [acronym]#EL#); this can either be a [type]+Set+, [type]+Collection+, [type]+Array+, or [type]+String+.

[NOTE]
.Differences between [acronym]#JSF# Ajax and RichFaces Ajax
====
[acronym]#JSF# evaluates all parameters during page rendering. As such, during a request from a page, all [varname]+execute+ and [varname]+render+ values are passed to the server from the client. In contrast, RichFaces evaluates these options at the server side during the current request.

This means that with JSF, making changes during a request to a [varname]+render+ value defined with EL will not influence the request. RichFaces, however, will always use the newer values.

The RichFaces approach additionally increases data integrity. Parameters that are changed from the client side are re-evaluated on the server, where they cannot be changed.
====

[IMPORTANT]
.Conditionally-rendered component updates
====
A common problem with using [varname]+render+ occurs when the referenced component is conditionally rendered via the [varname]+rendered+ attribute. If a component is not initially rendered, it does not have any HTML representation in the Document Object Model ( [acronym]#DOM#). As such, when RichFaces renders the component via Ajax, the page does not update as the place for the update is not known.

To work around this issue, wrap the component to be rendered in an [sgmltag]+<a4j:outputPanel>+ component. The [sgmltag]+<a4j:outputPanel>+ component will receive the update and render the component as required.
====

[[sect-Component_Reference-Rendering-ajaxRendered]]

==== [varname]+ajaxRendered+

A component with [code]+ajaxRendered="true"+ will be re-rendered with _every_ Ajax request, even when not referenced by the requesting component's [varname]+render+ attribute. This can be useful for updating a status display or error message without explicitly requesting it.

The [varname]+ajaxRendered+ attribute's functionality is the basis for the [sgmltag]+<a4j:outputPanel>+ component. The [sgmltag]+<a4j:outputPanel>+ component is designed to mark parts of the page for automatic updating. Refer to <<sect-Component_Reference-Containers-outputPanel>> for details.

Automatic rendering of such components can be repressed by adding [code]+limitRender="true"+ to the requesting component, as described in <<sect-Component_Reference-Rendering-limitRender>>.

[[sect-Component_Reference-Rendering-limitRender]]

==== [varname]+limitRender+

RichFaces Ajax-enabled components and Ajax behaviors with [code]+limitRender="true"+ specified will _not_ cause components with [code]+ajaxRendered="true"+ to re-render, and only those components listed in the [varname]+render+ attribute will be updated. This essentially overrides the [varname]+ajaxRendered+ attribute in other components.

<<exam-Component_Reference-data-Data_reference_example>> describes two command buttons, a panel grid rendered by the buttons, and an output panel showing error messages. When the first button is clicked, the output panel is rendered even though it is not explicitly referenced with the [varname]+render+ attribute. The second button, however, uses [code]+limitRender="true"+ to override the output panel's rendering and only render the panel grid.

[[exam-Component_Reference-limitRender-Rendering_example]]

.Rendering example
====


[source, XML]
----
<h:form id="form1">
    <a4j:commandButton value="Normal rendering" render="infoBlock" />
    <a4j:commandButton value="Limited rendering" render="infoBlock" limitRender="true" />
</h:form>

<h:panelGrid id="infoBlock">
    ...
</h:panelGrid>

<a4j:outputPanel ajaxRendered="true">
    <h:messages />
</a4j:outputPanel>

----

====

[[sect-Component_Reference-Common_Ajax_attributes-Queuing_and_traffic_control]]

=== Queuing and traffic control

[[sect-Component_Reference-Queuing_and_traffic_control-requestDelay]]

==== [varname]+requestDelay+

The [varname]+requestDelay+ attribute specifies an amount of time in milliseconds for the request to wait in the queue before being sent to the server. If a similar request is added to the queue before the delay is over, the original request is replaced with the new one.

[[sect-Component_Reference-Queuing_and_traffic_control-ignoreDupResponses]]

==== [varname]+ignoreDupResponses+

When set to +true+, the [varname]+ignoreDupResponses+ attribute causes responses from the server for the request to be ignored if there is another similar request in the queue. This avoids unnecessary updates on the client when another update is expected. The request is still processed on the server, but if another similar request has been queued then no updates are made on the client.

[[sect-Component_Reference-Common_Ajax_attributes-Events_and_JavaScript_interactions]]

=== Events and JavaScript interactions

JSF provides global [varname]+jsf.ajax.onError+ and [varname]+jsf.ajax.onEvent+ events to define handlers (the [varname]+jsf.ajax.onEvent+ event is used for all [varname]+begin+, [varname]+success+, and [varname]+complete+ events). RichFaces adds event-specific attributes at the component level.

[[sect-Component_Reference-Events_and_JavaScript_interactions-onsubmit]]

==== [varname]+onbeforesubmit+

The [varname]+onbeforesubmit+ event attribute invokes the event listener _before_ an Ajax request is sent. The request is canceled if the event listener defined for the [varname]+onbeforesubmit+ event returns +false+.

[[sect-Component_Reference-Events_and_JavaScript_interactions-onbegin]]

==== [varname]+onbegin+

The [varname]+onbegin+ event attribute invokes the event listener _after_ an Ajax request is sent.

[[sect-Component_Reference-Events_and_JavaScript_interactions-onbeforedomupdate]]

==== [varname]+onbeforedomupdate+

The [varname]+onbeforedomupdate+ event attribute invokes the event listener after an Ajax response has been returned but _before_ the [acronym]#DOM# tree of the browser is updated.

[[sect-Component_Reference-Events_and_JavaScript_interactions-oncomplete]]

==== [varname]+oncomplete+

The [varname]+oncomplete+ event attribute invokes the event listener after an Ajax response has been returned _and_ the [acronym]#DOM# tree of the browser has been updated.

[[sect-Component_Reference-Events_and_JavaScript_interactions-data]]

===== [varname]+data+

The [varname]+data+ attribute allows additional data to be handled with the [varname]+oncomplete+ event. Use [acronym]#JSF# Expression Language ( [acronym]#EL#) to reference the property of the managed bean, and its value will be serialized in JavaScript Object Notation ( [acronym]#JSON#) and returned to the client side. The property can then be referenced through the [parameter]+event.data+ variable in the event attribute definitions. Both primitive types and complex types such as arrays and collections can be serialized and used with [varname]+data+.

[[exam-Component_Reference-data-Data_reference_example]]

.Data reference example
====


[source, XML]
----
<a4j:commandButton value="Update" oncomplete="showTheName(event.data.name)" data="#{userBean.name}" />

----

====

[[sect-Component_Reference-Events_and_JavaScript_interactions-onerror]]

==== [varname]+onerror+

The [varname]+onerror+ event attribute invokes the event listener when an error has occurred during Ajax communications.

[[sect-Component_Reference-Events_and_JavaScript_interactions-Registering_event_callbacks_with_jQuery]]

==== Registering event callbacks with jQuery

RichFaces allows one to register callbacks for the events listed above using jQuery:

* [varname]+ajaxsubmit+: triggered _before_ an Ajax request is sent.
* [varname]+ajaxbegin+: triggered _after_ an Ajax request is sent.
* [varname]+ajaxbeforedomupdate+: triggered after an Ajax response has been returned but _before_ the DOM tree of the browser has been updated.
* [varname]+ajaxcomplete+: triggered after an Ajax response has been returned _and_ the DOM tree of the browser has been updated.


The event callback can be registered either on a form or a whole page:


[source, Java]
----
<h:outputScript>
jQuery(document).ready(function() {
	jQuery(#{rich:element('form_id')}).on("ajaxsubmit", function() {
	    // the callback will be triggered before the form is submitted using JSF AJAX
    	console.log("ajaxsubmit");
	});


    jQuery(document).on("ajaxcomplete", function() {
        // the callback will be triggered for each completed JSF AJAX for the current page
    	console.log("ajaxcomplete");
	});
}
</h:outputScript>
----

[[part-Component_Reference-Ajax_control_components]]

= Ajax control components

[[chap-Component_Reference-Actions]]

== Actions

This chapter details the basic components that respond to a user action and submit an Ajax request.

[[sect-Component_Reference-Actions-ajax]]

=== [sgmltag]+<a4j:ajax>+

The [sgmltag]+<a4j:ajax>+ behavior allows Ajax capability to be added to a non-Ajax component. The non-Ajax component must implement the [interfacename]+ClientBehaviorHolder+ interface for all the event attributes that support behavior rendering.

[[sect-Component_Reference-ajax-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:ajax>+ behavior is placed as a direct child to the component that requires Ajax support.

Point the [varname]+event+ attribute to the standard JSF event that triggers the behavior. If the [varname]+event+ attribute is not defined, the behavior is triggered on the event that normally provides interaction behavior for the parent component.

[[exam-Component_Reference-ajax-ajax_example]]

.[sgmltag]+<a4j:ajax>+ example
====


[source, XML]
----
<h:panelGrid columns="2">
    <h:inputText id="myinput" value="#{userBean.name}">
        <a4j:ajax event="keyup" render="outtext" />
    </h:inputText>
    <h:outputText id="outtext" value="#{userBean.name}" />
</h:panelGrid>

----

====

[[sect-Component_Reference-ajax-Reference_data]]

==== Reference data

* [parameter]+client-behavior-renderer-type+: [classname]+org.ajax4jsf.behavior.Ajax+
* [parameter]+behavior-id+: [classname]+org.ajax4jsf.behavior.Ajax+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.AjaxHandler+
* [parameter]+behavior-class+: [classname]+org.ajax4jsf.component.behavior.AjaxBehavior+
* [parameter]+client-behavior-renderer-class+: [classname]+org.ajax4jsf.renderkit.AjaxBehaviorRenderer+


[[sect-Component_Reference-Actions-param]]

=== [sgmltag]+<a4j:param>+

The [sgmltag]+<a4j:param>+ behavior combines the functionality of the JavaServer Faces ( [acronym]#JSF#) components [sgmltag]+<f:param>+ and [sgmltag]+<f:actionListener>+.

[[sect-Component_Reference-param-Basic_usage]]

==== Basic usage

Basic usage of the [sgmltag]+<a4j:param>+ requires three main attributes:

* The [varname]+value+ attribute is the initial value of the parameter.
* The [varname]+assignTo+ attribute defines the bean property. The property is updated if the parent command component performs an action event during the _Process Request_ phase.


<<exam-Component_Reference-param-param_example>> shows a simple implementation along with the accompanying managed bean.

[[exam-Component_Reference-param-param_example]]

.[sgmltag]+<a4j:param>+ example
====


[source, XML]
----
<h:form id="form">
    <a4j:commandButton value="Set name to Alex" reRender="rep">
        <a4j:param name="username" value="Alex" assignTo="#{paramBean.name}"/>
    </a4j:commandButton>
    <h:outputText id="rep" value="Name: #{paramBean.name}"/>
</h:form>

----


[source, Java]
----
public class ParamBean {
    private String name = "John";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

----

When the [guibutton]#Set name to Alex# button is pressed, the application sets the [varname]+name+ parameter of the bean to +Alex+, and displays the name in the output field.

====

[[sect-Component_Reference-param-Interoperability]]

==== Interoperability

The [sgmltag]+<a4j:param>+ tag can be used with non-Ajax components in addition to Ajax components. This includes components which are working through the [code]+GET+ request, such as the [sgmltag]+<h:link>+ and [sgmltag]+<h:button>+ components. In this way, data model values can also be updated without any Java code on the server side.

The [varname]+converter+ attribute can be used to specify how to convert the value before it is submitted to the data model. The property is assigned the new value during the _Update Model_ phase.

[NOTE]
.Validation failure
====
If the validation of the form fails, the _Update Model_ phase will be skipped and the property will not be updated.
====

[[sect-Component_Reference-param-Passing_client-side_parameters]]

==== Passing client-side parameters

Variables from JavaScript functions can be used for the [varname]+value+ attribute. In such an implementation, the [varname]+noEscape+ attribute should be set to +true+. Using [code]+noEscape="true"+, the [varname]+value+ attribute can contain any JavaScript expression or JavaScript function invocation, and the result will be sent to the server as the [varname]+value+ attribute.

[[exam-Component_Reference-param-Passing_client-side_parameters]]

.Passing client-side parameters
====


[source, XML]
----
<h:form>
   <a4j:commandButton value="Show Screen Size" render="infoPanel">
      <a4j:param name="w" value="screen.width"
                 assignTo="#{paramBean.screenWidth}" noEscape="true" />
      <a4j:param name="h" value="screen.height"
                 assignTo="#{paramBean.screenHeight}" noEscape="true" />
   </a4j:commandButton>

   <h:panelGrid columns="2" id="infoPanel">
      <h:outputText value="Width:" />
      <h:outputText value="#{paramBean.screenWidth}" />
      <h:outputText value="Height:" />
      <h:outputText value="#{paramBean.screenHeight}" />
   </h:panelGrid>
</h:form>

----

The command button triggers the [sgmltag]+<a4j:param>+ behaviors and renders the output text. The [sgmltag]+<a4j:param>+ behaviors pass client-side parameters for the screen width and height through the backing bean. These parameters are then used to populate the output text values.

====

[[sect-Component_Reference-param-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Parameter+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIParameter+
* [parameter]+component-family+: [classname]+javax.faces.Parameter+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.ParameterHandler+


[[sect-Component_Reference-Actions-actionListener]]

=== [sgmltag]+<a4j:actionListener>+

Use the [sgmltag]+<a4j:actionListener>+ tag to register an [classname]+ActionListener+ class on a parent action component. The class provided as a listener must implement the [interfacename]+javax.faces.event.ActionListener+ interface. Multiple listener methods can be registered on an action component in this way.

The [sgmltag]+<a4j:actionListener>+ tag differs from the standard JSF tag by allowing a listener method to be defined instead of just a class. Use the [varname]+listener+ attribute to define the listener method.

[[sect-Component_Reference-Actions-commandButton]]

=== [sgmltag]+<a4j:commandButton>+

The [sgmltag]+<a4j:commandButton>+ component is similar to the JavaServer Faces ( [acronym]#JSF#) [sgmltag]+<h:commandButton>+ component, but additionally includes Ajax support.

[[figu-Component_Reference-commandButton-commandButton]]
.[sgmltag]+<a4j:commandButton>+
image::figu-Component_Reference-commandButton-commandButton.png[]


[NOTE]
.The [sgmltag]+<a4j:commandButton>+ component executes the complete form
====
Button controls are typically used to perform complete form submissions for data storing. As a consequence, the [sgmltag]+<a4j:commandButton>+ component has the [code]+execute="@form"+ setting by default. To limit rendering to a different scope, redefine the [varname]+execute+ attribute.
====

[[sect-Component_Reference-commandButton-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:commandButton>+ requires only the [varname]+value+ attribute to function. Use the [varname]+value+ attribute to specify the text of the button.

By default, the [sgmltag]+<a4j:commandButton>+ uses the [varname]+click+ event instead of the [varname]+submit+ event.

[[sect-Component_Reference-commandButton-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.CommandButton+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICommandButton+
* [parameter]+component-family+: [classname]+javax.faces.Command+
* [parameter]+renderer-type+: [classname]+org.richfaces.CommandButtonRenderer+


[[sect-Component_Reference-Actions-commandLink]]

=== [sgmltag]+<a4j:commandLink>+

The [sgmltag]+<a4j:commandLink>+ component is similar to the JavaServer Faces ( [acronym]#JSF#) [sgmltag]+<h:commandLink>+ component, except that it includes plugged-in Ajax behavior.

[[figu-Component_Reference-commandLink-commandLink]]
.[sgmltag]+<a4j:commandLink>+
image::figu-Component_Reference-commandLink-commandLink.png[]


[NOTE]
.The [sgmltag]+<a4j:commandLink>+ component executes the complete form
====
Link controls are typically used to perform complete form submissions for data storing. As a consequence, the [sgmltag]+<a4j:commandLink>+ component has the [code]+execute="@form"+ setting by default. To limit rendering to a different scope, redefine the [varname]+execute+ attribute.
====

[[sect-Component_Reference-commandLink-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:commandLink>+ requires only the [varname]+value+ attribute to function. Use the [varname]+value+ attribute to specify the text of the link.

The [sgmltag]+<a4j:commandLink>+ uses the [varname]+click+ event instead of the [varname]+submit+ event.

[[sect-Component_Reference-commandLink-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.CommandLink+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICommandLink+
* [parameter]+component-family+: [classname]+javax.faces.Command+
* [parameter]+renderer-type+: [classname]+org.richfaces.CommandLinkRenderer+


[[sect-Component_Reference-Actions-jsFunction]]

=== [sgmltag]+<a4j:jsFunction>+

The [sgmltag]+<a4j:jsFunction>+ component performs Ajax requests directly from JavaScript code and retrieves server-side data. The server-side data is returned in JavaScript Object Notation ( [acronym]#JSON#) format prior to the execution of any JavaScript code defined using the [varname]+oncomplete+ attribute.

[[sect-Component_Reference-jsFunction-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:jsFunction>+ component requires the [varname]+data+ attribute. Use the [varname]+data+ attribute to define where the retrieved server-side data is stored.

<<exam-Component_Reference-jsFunction-jsFunction_example>> shows how an Ajax request can be initiated from the JavaScript and a partial page update performed. The JavaScript function can be invoked with the data returned by the Ajax response.

[[exam-Component_Reference-jsFunction-jsFunction_example]]

.[sgmltag]+<a4j:jsFunction>+ example
====


[source, XML]
----
<table width="400">
   <tbody>
      <tr>
         <td>
            <span onmouseover="updateName('Kate')"
                  onmouseout="updateName('')">Kate</span>
         </td>
         <td>
            <span onmouseover="updateName('John')"
                  onmouseout="updateName('')">John</span>
         </td>
         <td>
            <span onmouseover="updateName('Alex')"
                  onmouseout="updateName('')">Alex</span>
         </td>
      </tr>
      <tr>
         <td colspan="3">
            Name: <b><h:outputText id="showname" value="#{functionBean.text}" /></b>
         </td>
      </tr>
   </tbody>
</table>
<h:form>
   <a4j:jsFunction name="updateName" render="showname">
      <a4j:param name="name" assignTo="#{functionBean.text}"/>
   </a4j:jsFunction>
</h:form>

----

The output text for the name is changed depending on which table cell the user hovers over with the mouse. The [sgmltag]+<a4j:jsFunction>+ component manages the updating and display of the name.

====

[[sect-Component_Reference-jsFunction-Parameters_and_JavaScript]]

==== Parameters and JavaScript

The [sgmltag]+<a4j:jsFunction>+ component allows the use of the [sgmltag]+<a4j:param>+ component or the JavaServer Faces [sgmltag]+<f:param>+ component to pass any number of parameters for the JavaScript function.

[[sect-Component_Reference-jsFunction-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Function+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIFunction+
* [parameter]+component-family+: [classname]+javax.faces.Command+
* [parameter]+renderer-type+: [classname]+org.richfaces.FunctionRenderer+


[[sect-Component_Reference-Actions-poll]]

=== [sgmltag]+<a4j:poll>+

The [sgmltag]+<a4j:poll>+ component allows periodical sending of Ajax requests to the server. It is used for repeatedly updating a page at specific time intervals.

[[sect-Component_Reference-poll-Timing_options]]

==== Timing options

The [varname]+interval+ attribute specifies the time in milliseconds between requests. The default for this value is 1000 ms (1 second).

The [sgmltag]+<a4j:poll>+ component can be enabled and disabled using the [varname]+enabled+ attribute. Using Expression Language ( [acronym]#EL#), the [varname]+enabled+ attribute can point to a bean property to apply a particular attribute value.

[[sect-Component_Reference-poll-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Poll+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPoll+
* [parameter]+component-family+: [classname]+org.richfaces.Poll+
* [parameter]+renderer-type+: [classname]+org.richfaces.PollRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.AjaxPollHandler+


[[sect-Component_Reference-Actions-push]]

=== [sgmltag]+<a4j:push>+

The [sgmltag]+<a4j:push>+ component performs real-time updates on the client side from events triggered at the server side. The events are pushed out to the client through the RichFaces messaging queue. When the [sgmltag]+<a4j:push>+ component is triggered by a server event, it can in turn cause Ajax updates and changes.

The [sgmltag]+<a4j:push>+ component uses the Comet model for pushing data to the client.

[[sect-Component_Reference-push-Setting_up_push]]

==== Setting up Push

Using the Push component requires configuration steps which depends on an environment in which the Push is used:

[[sect-Component_Reference-push-Installing_runtime_dependencies]]

===== Installing runtime dependencies

The [sgmltag]+<a4j:push>+ uses an Atmosphere framework for transporting messages. In order to use the Atmosphere on the server-side, it is necessary to add Atmosphere libraries into a project.

In a Maven-based project, you should add [code]+richfaces-push-depchain+ as a runtime dependency:


[source, XML]
----
 <dependency>
    <groupId>org.richfaces</groupId>
    <artifactId>richfaces-push-depchain</artifactId>
    <type>pom</type>
    <version>4.5.9-SNAPSHOT</version>
    <scope>runtime</scope>
</dependency>
----

By declarating a dependency chain, all the required runtime dependencies such as [code]+atmosphere-runtime+ will be added transitively to your project.

For non-Maven-based projects, it is necessary to add dependencies manually - check "RichFaces Developer Guide", section "Project libraries and dependencies" for details.

[[sect-Component_Reference-push-Registering_Push_servlet]]

===== Registering Push servlet

The Push requires a [code]+PushServlet+ registered in web application and listening for Push client connections.

In the Servlets 3.0 and higher environments, the servlet will be registered automatically.

However in the Servlets 2.5 and lower environments, the servlet needs to be registered manually in [code]+web.xml+:


[source, XML]
----
<!-- Push Servlet - listens for user sessions -->
<servlet>
    <servlet-name>Push Servlet</servlet-name>
    <servlet-class>org.richfaces.webapp.PushServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>Push Servlet</servlet-name>
    <url-pattern>/__richfaces_push</url-pattern>
</servlet-mapping>

<!-- setups servlet-mapping in RichFaces configuration -->
<context-param>
    <param-name>org.richfaces.push.handlerMapping</param-name>
    <param-value>/__richfaces_push</param-value>
</context-param>
----

[NOTE]
.Manual registration of servlet in Servlets 3.0
====
When you attempt to register the Push servlet manually in Servlet 3.0 environments, RichFaces will detect that the Push servlet is already registered and avoid initializing it again.

However, be sure to setup the Push servlet to support asynchronous requests - modify the servlet registration from the previous [code]+web.xml+ snippet as follows:


[source, XML]
----
<servlet>
    <servlet-name>Push Servlet</servlet-name>
    <servlet-class>org.richfaces.webapp.PushServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
    <async-supported>true</async-supported>
</servlet>
----


====

[NOTE]
.Switching to Blocking I/O instead of asynchronous servlets
====
Although a container you use supports Servlets 3.0, you may experience problems with using asynchronous servlets.

It is possible to force the Atmosphere to use a blocking I/O approach with the following [code]+web.xml+ configuration:


[source, XML]
----
<context-param>
    <param-name>org.atmosphere.useBlocking</param-name>
    <param-value>true</param-value>
</context-param>
----


====

[[sect-Component_Reference-push-Server_side_Push_methods]]

==== Server-side Push methods

The Push events can be fired on the server-side in several ways:

* _TopicsContext_ - accesses a RichFaces message queue directly
* _Push CDI_ - uses the CDI Event mechanism to fire messages
* _Push JMS_ - the RichFaces Push consumes messages from an enterprise messaging system and exposes them to the client (tightly coupled with the JMS runtime)


[[sect-Component_Reference-push-Client_side_Push_methods]]

==== Client-side Push methods

On the client side, push notifications may be processed in the following ways:

* [code]+ondataavailable+ event handler (serialized message is available)
* Client behaviors attached to [code]+dataavailable+ event


[[sect-Component_Reference-push-Push_Topics]]

==== Push Topics

The Push messages are delivered to the client based on a [code]+TopicKey+'s name (e.g. [code]+someTopic+).

The [code]+TopicKey+ can optionally include a subtopic name (e.g. [code]+subtopic@anotherTopic+).

On the client side, the topic is represted by an [sgmltag]+<a4j:push>+'s attribute [varname]+address+.

[NOTE]
.Push Topic relates to JMS topic
====
The format for the name of the push topic is very close to the JMS topic name and thus enables a seamless transport of JMS messages to the RichFaces message queue.
====

[NOTE]
.Topics with EL expressions
====
Since the topic key can contain EL expressions, it is possible to achieve dynamic end-points (e.g. addressing specific clients).

You need to push a message by using [code]+TopicContext.publish(TopicKey key, Object message)+ or using CDI events to publish message to dynamically evaluated topic key.

The [sgmltag]+<a4j:push>+'s attribute [varname]+address+ accepts EL expressions.
====

[[sect-Component_Reference-push-Handling_a_push_message]]

==== Handling a push message

A push message sent from the server to the [sgmltag]+<a4j:push>+ component on the client will cause it to trigger any event handlers defined using the [varname]+dataavailable+ event handler.

The [sgmltag]+<a4j:push>+ component should also include the [varname]+onerror+ event handler to inform the user when an error has occurred with the push messages.

[sgmltag]+<a4j:push>+ can be used for either immediate processing of messages (like in the previous example) or it can trigger a partial page update. Check out following samples:

[[exam-Component_Reference-push-Handling_a_push_message]]

.Handling a push message
====


[source, XML]
----
<a4j:push address="chat"
          onerror="alert(event.rf.data)"
          ondataavailable="chat.addMessage(event.rf.data)" />

----

This example uses the [varname]+dataavailable+ event attribute with some JavaScript to update messages in a chat room. The [parameter]+event.rf.data+ parameter contains Push message data serialized to JavaScript.

====

[[exam-Component_Reference-push-Updating_DOM_for_each_push_notification]]

.Updating DOM for each push message
====


[source, XML]
----
<a4j:push address="chat"
          onerror="alert(event.rf.data)">
    <a4j:ajax event="datavailable" render="chat" />
</a4j:push>
----

This example uses the [varname]+dataavailable+ event handler to trigger an AJAX request and a partial page update.

====

[[sect-Component_Reference-push-Handling_a_push_subscription]]

==== Handling a push subscription

The [sgmltag]+<a4j:push>+ component establishes connection with server on complete page load (when document is ready).

It means that the application starts to handle push messages once the page is completely loaded.

However time-critical applications may require keeping client stricly synchronized with the server state.

For such applications you may use [varname]+onsubscribed+ event handler, which is triggered every time the given component is successfully subscribed to the address/topic it listens to (on a page load and on each AJAX re-render).

[[exam-Component_Reference-push-Handling_a_push_subscription]]

.The time-critical updates in stock application
====


[source, XML]
----
<a4j:push address="stockUpdates"
          onerror="alert(event.rf.data)">
    <a4j:ajax event="dataavailable" render="stocksTable" />
	<a4j:ajax event="subscribed" render="stocksTable" />
</a4j:push>

----

This example uses the [varname]+subscribed+ event to update the table content once the push component is subscribed to the topic, ensuring that the table content is not stale.

====

[[sect-Component_Reference-push-Using_TopicsContext_to_publish_message]]

==== Using TopicsContext to publish message

Messages could be produced using the [code]+TopicsContext+ interface directly as in the following sample:


[source, Java]
----
private TopicKey topicKey = new TopicKey("chat");

public void initializeTopic() {
	TopicsContext topicsContext = TopicsContext.lookup();
	topicsContext.getOrCreateTopic(topicKey);
}

public void sendMessage(String message) throws MessageException {
    TopicsContext topicsContext = TopicsContext.lookup();
    topicsContext.publish(topicKey, message);
}
----

A topic needs to first be created using [code]+TopicsContext#getOrCreate(TopicKey)+ where [code]+TopicKey+ is the name of the topic. A message to the topic can be sent using the method: [code]+TopicsContext#publish(topicKey, message)+.

[[sect-Component_Reference-push-Push_CDI_Integration]]

==== Integrating Push with CDI events

An alternative way of producing messages is to use the CDI event mechanism.

Push notifications can be produced by annotating a CDI event injection point with the [code]+@Push+ annotation, which specifies an end-point (topic name).

The payload of the message is the serialized object sent using the CDI event interface ( [code]+Event.fire(T object)+).


[source, Java]
----
@Inject
@Push(topic = "chat")
Event<String> pushEvent;

public void sendMessage(String message) {
    pushEvent.fire(message);
}
----

[[sect-Component_Reference-push-Push_and_JMS_integration]]

==== Push and JMS integration

An integration of the RichFaces Push and the Java Messaging Service ( JMS) allows to write robust interactive applications.

===== Enabling JMS integraction

The JMS integration needs to be enabled in [code]+web.xml+ with a following configuration:


[source, XML]
----
<context-param>
    <param-name>org.richfaces.push.jms.enabled</param-name>
    <param-value>true</param-value>
</context-param>
----

===== Configuring JMS backend

The JMS instance on the back-end must be configured to work with your [sgmltag]+<a4j:push>+ components.

[NOTE]
.Configuring JMS on JBoss EAP
====
Refer to the *_JBoss EAP Administration and Configuration Guide_* for details on configuring JMS in JBoss EAP.
====

[[exam-Component_Reference-push-JMS_server_configuration]]

.JMS server configuration
====

This simple example describes the JMS server configuration required for a pushing server date to the client.

The JMS server needs to be setup in order to propagate JMS messages to Push components. Create a new JMS topic using the following settings:

[horizontal]
[guilabel]#Name:#:: datePush
[guilabel]#JNDI name:#:: /topic/datePush
 :: Use the default settings for other options.


Add a single role for the topic in the same form using the following settings:

[horizontal]
[guilabel]#Name:#:: guest
[guilabel]#Send:#:: true
[guilabel]#Consume:#:: true
[guilabel]#Create subscriber:#:: true
[guilabel]#Delete subscriber:#:: true
[guilabel]#Create durable subscriber:#:: true
[guilabel]#Delete durable subscriber:#:: true


====

Ensure the [guilabel]#Create durable subscriber# and the [guilabel]#Delete durable subscriber# options are set to [guilabel]#true# for proper push functionality.

[NOTE]
.Durable subscriptions
====
Durable subscriptions receive all events, including those events which were sent while the push component was not connected.

Refer to *_JMS Documentation_* for details on configuring the JMS Server.
====

[NOTE]
.JMS integration with custom configuration
====
RichFaces looks for the JMS Connection Factory on the JNDI context [code]+/ConnectionFactory+ by default.

The prefix [code]+/topic+ is used for deriving JMS topic names from Push topic names.

When integrating component into an enterprise system, this defaults can be changed.

Use following [code]+web.xml+ parameters to change default values: [code]+org.richfaces.push.jms.connectionFactory+, [code]+org.richfaces.push.jms.topicsNamespace+.

When RichFaces obtains a connection, an empty user name is used with an empty password.

Use following [code]+web.xml+ parameters or equivalent JVM parameters to change default values: [code]+org.richfaces.push.jms.connectionUsername+, [code]+org.richfaces.push.jms.connectionPassword+.

====

===== Sending and receiving Push messages using JMS

The JMS message which should be propagated to Push needs to be created with the method [code]+session.createObjectMessage(message);+.

The message could be then published using [code]+publisher.publish(message);+ like in a following example:

[[exam-Component_Reference-push-Sending_messages_using_JMS]]

.Sending messages using JMS
====


[source, Java]
----
TopicConnection connection;
TopicSession session;
TopicPublisher publisher;

public void sendCurrentDate() throws JMSException {
    String currentDate = new Date().toString();
    ObjectMessage message = session.createObjectMessage(message);
    publisher.publish(message);
}

// messaging needs to be initialized before using method #sendCurrentDate()
private void initializeMessaging() throws JMSException, NamingException {
    if (connection == null) {
        TopicConnectionFactory tcf = (TopicConnectionFactory) InitialContext.doLookup("java:/ConnectionFactory");
        connection = tcf.createTopicConnection();
    }
    if (session == null) {
        session = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
    }
    if (topic == null) {
        topic = InitialContext.doLookup("topic/datePush");
    }
    if (publisher == null) {
        publisher = session.createPublisher(topic);
    }
}
----

====

Receiving messages from a JMS queue doesn't differ from receiving messages sent by the [code]+TopicsContext+ or using CDI events.

[[exam-Component_Reference-push-Receiving_messages_using_JMS]]

.Receiving messages using JMS
====


[source, XML]
----
<a4j:push id="datePush" address="datePush"
            ondataavailable="jQuery(#{rich:element('serverDate')}).text(event.rf.data)" />

<a4j:outputPanel id="serverDate" layout="block">
    <i>waiting for event...</i>
</a4j:outputPanel>
----

====

The above example demonstrates a simple use of the [sgmltag]+<a4j:push>+ tag that causes an immediate update of the page content.

[[sect-Component_Reference-push-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Push+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPush+
* [parameter]+component-family+: [classname]+org.richfaces.Push+
* [parameter]+renderer-type+: [classname]+org.richfaces.PushRenderer+


[[chap-Component_Reference-Resources]]

== Resources

This chapter covers those components used to handle and manage resources and beans.

[[sect-Component_Reference-Resources-mediaOutput]]

=== [sgmltag]+<a4j:mediaOutput>+

The [sgmltag]+<a4j:mediaOutput>+ component is used for generating images, video, sounds, and other resources defined on the fly.

[[sect-Component_Reference-mediaOutput-Basic_usage]]

==== Basic usage

The [varname]+createContent+ attribute points to the method used for generating the displayed content.

If necessary, the [varname]+value+ attribute can be used to pass input data to the content generation method specified with [varname]+createContent+. The [varname]+cacheable+ attribute specifies whether the resulting content will be cached or not.

[[sect-Component_Reference-mediaOutput-Handling_content]]

==== Handling content

The [varname]+mimeType+ attribute describes the type of output content, and corresponds to the type in the header of the [acronym]#HTTP# request. The [varname]+element+ attribute defines [acronym]#XHTML# element used to display the content:

* +img+
* +object+
* +applet+
* +script+
* +link+
* +a+


[[exam-Component_Reference-mediaOutput-mediaOutput_example]]

.[sgmltag]+<a4j:mediaOutput>+ example
====

This example uses the [sgmltag]+<a4j:mediaOutput>+ component to generate a [acronym]#JPEG# image of verification digits. The code on the application page is a single element:


[source, XML]
----
<a4j:mediaOutput element="img" cacheable="false" session="false"
                 createContent="#{mediaBean.paint}" value="#{mediaData}"
                 mimeType="image/jpeg" />

----

The [sgmltag]+<a4j:mediaOutput>+ component uses the [methodname]+MediaBean.paint+ method to create the image. The method generates a random number, which is then converted into an output stream and rendered to a [acronym]#JPEG# image. The [classname]+MediaBean+ class is as follows:


[source, Java]
----
package demo;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Random;
import javax.imageio.ImageIO;

public class MediaBean {

    public void paint(OutputStream out, Object data) throws IOException {

        Integer high = 9999;
        Integer low = 1000;
        Random generator = new Random();
        Integer digits = generator.nextInt(high - low + 1) + low;

        if (data instanceof MediaData) {
            MediaData paintData = (MediaData) data;
            BufferedImage img = new BufferedImage(paintData.getWidth(),paintData.getHeight(),BufferedImage.TYPE_INT_RGB);
            Graphics2D graphics2D = img.createGraphics();
            graphics2D.setBackground(paintData.getBackground());
            graphics2D.setColor(paintData.getDrawColor());
            graphics2D.clearRect(0,0,paintData.getWidth(),paintData.getHeight());
            graphics2D.setFont(paintData.getFont());
            graphics2D.drawString(digits.toString(), 20, 35);
            ImageIO.write(img,"png",out);
        }
    }
}

----

Another class, [classname]+MediaData+ is required by the [varname]+value+ attribute for keeping data to be used as input for the content creation method. The [classname]+MediaData+ class is as follows:


[source, Java]
----
package demo;

import java.awt.Color;
import java.awt.Font;
import java.io.Serializable;

public class MediaData implements Serializable {

    private static final long serialVersionUID = 1L;

    Integer Width=110;
    Integer Height=50;

    Color Background=new Color(190, 214, 248);
    Color DrawColor=new Color(0,0,0);

    Font font = new Font("Serif", Font.TRUETYPE_FONT, 30);

    /* Corresponding getters and setters */
    ...

}

----

The [sgmltag]+<a4j:mediaOutput>+ component uses the [classname]+MediaBean+ and [classname]+MediaData+ classes to generate a new image on each page refresh.

image::figu-Component_Reference-mediaOutput-mediaOutput_example_result.png[The generated image containing a random verification number.]

====

[NOTE]
.[classname]+Serializable+ interface
====
A bean class passed using the [varname]+value+ attribute of [sgmltag]+<a4j:mediaOutput>+ should implement the [classname]+Serializable+ interface so that it will be encoded to the [acronym]#URL# of the resource.
====

[[sect-Component_Reference-mediaOutput-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.MediaOutput+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIMediaOutput+
* [parameter]+component-family+: [classname]+org.richfaces.MediaOutput+
* [parameter]+renderer-type+: [classname]+org.richfaces.MediaOutputRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.MediaOutputHandler+


[[chap-Component_Reference-Containers]]

== Containers

This chapter details those components in the [classname]+r+ tag library which define an area used as a container or wrapper for other components.

[[sect-Component_Reference-Containers-outputPanel]]

=== [sgmltag]+<a4j:outputPanel>+

The [sgmltag]+<a4j:outputPanel>+ component is used to group together components in to update them as a whole, rather than having to specify the components individually.

[[sect-Component_Reference-outputPanel-Aiding_complex_Ajax_rendering]]

==== Aiding complex Ajax rendering

Use the [sgmltag]+<a4j:outputPanel>+ component to wrap behaviors when using complex Ajax rendering. Parent components may not render correctly when attached behaviors trigger updates. Point the behaviors to the wrapping [sgmltag]+<a4j:outputPanel>+ component instead of the parent components. The [sgmltag]+<a4j:outputPanel>+ component is properly encoded to ensure the wrapped components are correctly rendered.

[[sect-Component_Reference-outputPanel-Panel_appearance]]

==== Panel appearance

The [varname]+layout+ attribute can be used to determine how the component is rendered in [acronym]#HTML#:

* [code]+layout="inline"+ is the default behavior, which will render the component as a pair of [sgmltag]+<span>+ tags containing the child components.
* [code]+layout="block"+ will render the component as a pair of [sgmltag]+<div>+ tags containing the child components, which will use any defined [sgmltag]+<div>+ element styles.


Setting [code]+ajaxRendered="true"+ will cause the [sgmltag]+<a4j:outputPanel>+ to be updated with each Ajax response for the page, even when not listed explicitly by the requesting component. This can in turn be overridden by specific attributes on any requesting components.

[[sect-Component_Reference-outputPanel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.OutputPanel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIOutputPanel+
* [parameter]+component-family+: [classname]+javax.faces.Panel+
* [parameter]+renderer-type+: [classname]+org.richfaces.OutputPanelRenderer+


[[sect-Component_Reference-Containers-region]]

=== [sgmltag]+<a4j:region>+

The [sgmltag]+<a4j:region>+ component specifies a part of the JSF component tree to be processed on the server. The region causes all the [classname]+r+ Ajax controls to execute: decoding, validating, and updating the model. The region causes these components to execute even if not explicitly declared. As such, processing areas can more easily be marked using a declarative approach.

Regions can be nested, in which case only the parent region of the component initiating the request will be processed.

[[sect-Component_Reference-region-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Region+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIRegion+
* [parameter]+component-family+: [classname]+org.richfaces.AjaxContainer+


[[chap-Component_Reference-Validation]]

== Validation

JavaServer Faces 2 provides built-in support for bean validation as per the Java Specification Request JSR-303 standard. As such, containers must validate model objects. Validation is performed at different application tiers according to annotation-based constraints. Refer to http://jcp.org/en/jsr/detail?id=303 for further details on the JSR-303 specification.

<<exam-Component_Reference-Validation-JSR-303_validation_annotations>> shows an example JSF managed bean. The bean includes JSR-303 annotations for validation. Validation annotations defined in this way are registered on components bound to the bean properties, and validation is triggered in the _Process Validation_ phase.

[[exam-Component_Reference-Validation-JSR-303_validation_annotations]]

.JSR-303 validation annotations
====


[source, Java]
----
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;

@ManagedBean
@RequestScoped
public class UserBean {

   @Size(min=3, max=12)
   private String name = null;

   @Pattern(regexp = "^[\\w\\-]([\\.\\w])+[\\w]+@([\\w\\-]+\\.)+[a-zA-Z]{2,4}$" , message="Bad email")
   private String email = null;

   @Min(value = 18)
   @Max(value = 99)
   private Integer age;

//...
//Getters and Setters
}

----

====

[NOTE]
.Requirements
====
Bean validation in both JavaServer Faces and RichFaces requires the _JSR-303_ implementation. The implementation is bundled with [productname]#JEE 6 Application Server#.

If using [productname]#Tomcat# or another simple servlet container, add the [filename]+validation-api+ Java Archive and a validation provider (such as [productname]#Hibernate Validator#) to your application libraries.
====

[[sect-Component_Reference-Validation-validator]]

=== [sgmltag]+<rich:validator>+ client-side validation

The validation built in to JavaServer Faces 2 occurs on the server side. The [sgmltag]+<rich:validator>+ behavior adds client-side validation to a control based on registered server-side validators. It provides this validation without the need to reproduce the server-side annotations. The [sgmltag]+<rich:validator>+ behavior triggers all client validator annotations listed in the relevant managed bean.

[[sect-Component_Reference-validator-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:validator>+ behavior is added as a child element to any input control. The value of the input control must reference a managed bean. The content of the input control validates on the client-side based on registered server-side validators included in the managed bean.

[[exam-Component_Reference-validator-Basic_usage]]

.Basic usage
====


[source, XML]
----
<h:inputText value="#{userBean.name}">
   <rich:validator/>
</h:inputText>

----

====

[NOTE]
.JSF validation tags
====
JSF validation tags, such as [sgmltag]+<f:validateLength>+ and [sgmltag]+<f:validateDoubleRange>+ tags, can be declared alongside [sgmltag]+<rich:validator>+ behaviors. However, because this duplicates the validation processes at both the view and model level, it is not recommended.
====

[[sect-Component_Reference-validator-Messages_from_client-side_validators]]

==== Messages from client-side validators

Use the [sgmltag]+<rich:message>+ and [sgmltag]+<rich:messages>+ components to display validation messages. The [varname]+for+ attribute of the [sgmltag]+<rich:message>+ component references the [varname]+id+ identifier of the input control being validated.

[[exam-Component_Reference-validator-Messages]]

.Messages
====


[source, XML]
----
<rich:panel header="User information">
   <h:panelGrid columns="3">

      <h:outputText value="Name:" />
      <h:inputText value="#{validationBean.name}" id="name">
         <rich:validator />
      </h:inputText>
      <rich:message for="name" />

      <h:outputText value="Email" />
      <h:inputText value="#{validationBean.email}" id="email">
         <rich:validator />
      </h:inputText>
      <rich:message for="email" />

      <h:outputText value="Age" />
      <h:inputText value="#{validationBean.age}" id="age">
         <rich:validator />
      </h:inputText>
      <rich:message for="age" />

      <h:outputText value="I agree the terms" />
      <h:selectBooleanCheckbox value="#{validationBean.agree}" id="agree">
         <rich:validator/>
      </h:selectBooleanCheckbox>
      <rich:message for="agree" />

   </h:panelGrid>
</rich:panel>

----

Failed validation checks are reported using [sgmltag]+<rich:message>+ components. The validation annotations in the managed bean are outlined in <<exam-Component_Reference-Validation-JSR-303_validation_annotations>>.

image::figu-Component_Reference-validator-Messages.png[Failed validation checks are reported using +&lt;rich:message&gt;+ components.]

====

[[sect-Component_Reference-validator-Validation_triggers]]

==== Validation triggers

Use the [varname]+event+ attribute to specify which event on the input control triggers the validation process. By default, the [sgmltag]+<rich:validator>+ behavior triggers validation when the input control is changed ( [code]+event="change"+).

[[exam-Component_Reference-validator-Validation_triggers]]

.Validation triggers
====


[source, XML]
----
<h:inputText value="#{userBean.name}">
   <rich:validator event="keyup"/>
</h:inputText>

----

The [varname]+event+ attribute is changed to the +keyup+ event, such that validation takes place after each key press.

====

[[sect-Component_Reference-validator-Ajax_fall-backs]]

==== Ajax fall-backs

If no client-side validation method exists for a registered server-side validator, Ajax fall-back is used. The [sgmltag]+<rich:validator>+ behavior invokes all available client-side validators. If all the client-side validators return valid, RichFaces performs an Ajax request to invoke the remaining validators on the server side.

[[sect-Component_Reference-validator-Reference_data]]

==== Reference data

* [parameter]+client-behavior-renderer-type+: [classname]+org.richfaces.ClientValidatorRenderer+
* [parameter]+behavior-id+: [classname]+org.richfaces.behavior.ClientValidator+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.ClientValidatorHandler+
* [parameter]+behavior-class+: [classname]+org.ajax4jsf.component.behavior.ClientValidatorImpl+
* [parameter]+client-behavior-renderer-class+: [classname]+org.richfaces.renderkit.html.ClientValidatorRenderer+


[[sect-Component_Reference-Validation-graphValidator]]

=== [sgmltag]+<rich:graphValidator>+ object validation

The [sgmltag]+<rich:graphValidator>+ component is used to wrap a set of input components related to one object. The object defined by the [sgmltag]+<rich:graphValidator>+ component can then be completely validated. The validation includes all object properties, even those which are not bound to the individual form components. Validation performed in this way allows for cross-field validation in complex forms.

[NOTE]
.Validation without model updates
====
The [sgmltag]+<rich:graphValidator>+ component performs a [methodname]+clone()+ method on the referenced bean instance during the validation phase. The cloned object is validated and triggers any required validation messages. As such, the model object remains clean, and the lifecycle is interrupted properly after the _Process Validations_ phase.

Ensure the referenced object implements the [interfacename]+Cloneable+ interface, and allows a deep clone if required.
====

[[sect-Component_Reference-graphValidator-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:graphValidator>+ element must wrap all the input controls that are required to validate the object. The [varname]+value+ attribute names the bean for the validating object.

[[exam-Component_Reference-graphValidator-Basic_usage]]

.Basic usage
====

The example demonstrates a simple form for changing a password. The two entered passwords must match, so a [sgmltag]+<rich:graphValidator>+ component is used for cross-field validation.


[source, XML]
----
<h:form>
   <rich:graphValidator value="#{userBean}">
      <rich:panel header="Change password">
         <rich:messages/>
         <h:panelGrid columns="3">
            <h:outputText value="Enter new password:" />
            <h:inputSecret value="#{userBean.password}" id="pass"/>
            <rich:message for="pass"/>
            <h:outputText value="Confirm the new password:" />
            <h:inputSecret value="#{userBean.confirm}" id="conf"/>
            <rich:message for="conf"/>
         </h:panelGrid>
         <a4j:commandButton value="Store changes"
                            action="#{userBean.storeNewPassword}" />
      </rich:panel>
   </rich:graphValidator>
</h:form>

----

The input controls validate against the following bean:


[source, Java]
----
@ManagedBean
@RequestScoped
public class UserBean implements Cloneable {

   @Size(min = 5, max = 15, message="Wrong size for password")
   private String password;
   @Size(min = 5, max = 15, message="Wrong size for confirmation")
   private String confirm;
   private String status = "";

   @AssertTrue(message = "Different passwords entered!")
   public boolean isPasswordsEquals() {
      return password.equals(confirm);
   }

   public void storeNewPassword() {
      FacesContext.getCurrentInstance().addMessage("", new FacesMessage(FacesMessage.SEVERITY_INFO, "Succesfully changed!", "Succesfully changed!"));
   }

   ...
}

----

When validation occurs, the whole object is validated against the annotation contstraints. The [varname]+@AssertTrue+ annotation relies on the [methodname]+isPasswordsEqual()+ function to check whether the two entered passwords are equal.

If the entered passwords do not match, an error message is displayed:

image::figu-Component_Reference-graphValidator-Basic_usage.png[Failed validation checks are reported using +&lt;rich:message&gt;+ components.]

====

[[sect-Component_Reference-graphValidator-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.GraphValidator+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIGraphValidator+
* [parameter]+component-family+: [classname]+org.richfaces.GraphValidator+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.GraphValidatorHandler+


[[chap-Component_Reference-Processing_management]]

== Processing management

This chapter covers those components that manage the processing of information, requests, and updates.

[[sect-Component_Reference-Processing_management-queue]]

=== [sgmltag]+<a4j:queue>+

The [sgmltag]+<a4j:queue>+ component manages the JSF queue of Ajax requests. It provides additional options for a finer control of request processing.

[[sect-Component_Reference-queue-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:queue>+ component works in the same basic way as the standard JSF queue. It can be enabled and disabled through the [varname]+enabled+ attribute.

[NOTE]
.Requests from other libraries
====
The [sgmltag]+<a4j:queue>+ component does not handle standard JSF requests or requests from component libraries other than RichFaces.
====

[[sect-Component_Reference-queue-Delaying_requests]]

==== Delaying requests

Use the [varname]+requestDelay+ attribute to add a delay between each request in the queue. Set the [varname]+requestDelay+ attribute to the number of milliseconds to wait in between each request. Delaying requests avoids unnecessary processing for actions that would otherwise cause multiple requests, such as typing. Similar requests in the queue are combined while waiting for the request delay.

[[exam-Component_Reference-queue-Delaying_requests]]

.Delaying requests
====


[source, XML]
----
<a4j:queue requestDelay="1500"/>
----

The queue delays each request by 1500 milliseconds.

====

[[sect-Component_Reference-queue-Duplicate_responses]]

==== Duplicate responses

The client side can update unnecessarily if duplicate responses require similar updates. Set [code]+ignoreDupResponses="true"+ to ignore duplicate responses. With this setting, the client will not update from a request if a similar request is in the queue.

[[sect-Component_Reference-queue-Queue_scopes]]

==== Queue scopes

Define the queue scope to make it the default queue for all requests in that scope. The scope depends on the placement of the queue and any naming identifiers.

* An unnamed [sgmltag]+<a4j:queue>+ component placed outside any forms becomes the default queue for all requests on the page.
* An unnamed [sgmltag]+<a4j:queue>+ component placed inside a form becomes the default queue for all requests within that form.
* Use the [varname]+name+ identifier attribute to name an [sgmltag]+<a4j:queue>+ component. Named queues can be accessed with the [sgmltag]+<a4j:attachQueue>+ behavior to act as a queue for specific components and behaviors. Refer to <<sect-Component_Reference-Processing_management-attachQueue>> for details.


[[exam-Component_Reference-queue-Queue_scopes]]

.Queue scopes
====


[source, XML]
----
<a4j:queue name="viewQueue" requestDelay="2000"/>
<h:form>
	<a4j:queue name="formQueue" requestDelay="1500"/>
   ...
</h:form>

----

The queue outside the form is scoped to the view. The queue inside the form is scoped only to that form.

====

[[sect-Component_Reference-queue-queue_client-side_events]]

==== [sgmltag]+<a4j:queue>+ client-side events

The [sgmltag]+<a4j:queue>+ component features several events relating to queuing actions in addition to the common JSF events:

* The [varname]+complete+ event is fired after a request is completed. The request object is passed as a parameter to the event handler, so the queue is accessible using [code]+request.queue+ and the element which was the source of the request is accessible using +this+.
* The [varname]+requestqueue+ event is fired after a new request has been added to the queue.
* The [varname]+requestdequeue+ event is fired after a request has been removed from the queue.


[[sect-Component_Reference-queue-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Queue+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIQueue+
* [parameter]+component-family+: [classname]+org.richfaces.Queue+
* [parameter]+renderer-type+: [classname]+org.richfaces.QueueRenderer+


[[sect-Component_Reference-Processing_management-attachQueue]]

==== [sgmltag]+<a4j:attachQueue>+

The [sgmltag]+<a4j:attachQueue>+ behavior is used together with a [sgmltag]+<a4j:queue>+ component to further customize queuing for particular components and behaviors. The [sgmltag]+<a4j:attachQueue>+ behavior can override the scope-wide queue settings for an individual component, or attach specific requests to a queue.

[[sect-Component_Reference-attachQueue-Overriding_scope_settings]]

===== Overriding scope settings

Queues can be scoped to various levels as described in <<sect-Component_Reference-queue-Queue_scopes>>. Use an [sgmltag]+<a4j:attachQueue>+ behavior in the same scope as a queue to override the queue settings for a particular control.

[[exam-Component_Reference-attachQueue-Overriding_scope_settings]]

.Overriding scope settings
====


[source, XML]
----
<a4j:queue requestDelay="2000"/>
<h:form>
   <rich:panel>
      <h:inputText>
         <a4j:ajax event="keyup" />
      </h:inputText>
      <a4j:commandButton value="submit">
         <a4j:attachQueue requestDelay="0" />
      </a4j:commandButton>
   </rich:panel>
</h:form>

----

The request delay is overridden by the [sgmltag]+<a4j:attachQueue>+ behavior on the submit button.

====

[[sect-Component_Reference-attachQueue-Using_a_named_queue]]

===== Using a named queue

Name an [sgmltag]+<a4j:queue>+ component using the [varname]+name+ attribute. It can then be used by specific components through the [sgmltag]+<a4j:attachQueue>+ behavior. Use the [varname]+name+ attribute of the [sgmltag]+<a4j:attachQueue>+ behavior to identify the name of the destination queue.

[[exam-Component_Reference-attachQueue-Using_a_named_queue]]

.Using a named queue
====


[source, XML]
----
<a4j:queue name="viewQueue"/>
<h:form>
	<a4j:queue name="formQueue"/>
   <rich:panel>
      <a4j:commandButton value="submit">
         <a4j:attachQueue name="viewQueue" />
      </a4j:commandButton>
   </rich:panel>
</h:form>

----

The requests from the button are attached to the +viewQueue+ queue, rather than the +formQueue+ queue.

====

[[sect-Component_Reference-attachQueue-Grouping_requests]]

===== Grouping requests

Use grouping to process multiple requests together. Specify a grouping identifier with the [varname]+requestGroupingId+ attribute. Requests from multiple [sgmltag]+<a4j:attachQueue>+ behaviors can use the same identifier to group requests together.

[[exam-Component_Reference-attachQueue-Grouping_requests]]

.Grouping requests
====


[source, XML]
----
<h:form>
   <a4j:queue requestDelay="2000"/>
   <h:inputText id="input1" value="#{queueBean.text1}">
      <a4j:attachQueue requestGroupingId="registrationForm"/>
   </h:inputText>
   <h:inputText id="input2" value="#{queueBean.text2}">
      <a4j:attachQueue requestGroupingId="registrationForm"/>
   </h:inputText>
</h:form>

----

Requests from both the text input boxes are grouped together with the +registrationForm+ identifier.

====

[[sect-Component_Reference-attachQueue-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.AttachQueue+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIAttachQueue+
* [parameter]+component-family+: [classname]+org.richfaces.AttachQueue+
* [parameter]+renderer-type+: [classname]+org.richfaces.AttachQueueRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.AttachQueueHandler+


[[sect-Component_Reference-Processing_management-log]]

=== [sgmltag]+<a4j:log>+

The [sgmltag]+<a4j:log>+ component generates JavaScript that opens a debug window, logging application information such as requests, responses, and [acronym]#DOM# changes.

[[sect-Component_Reference-log-Basic_usage]]

==== Basic usage

The [sgmltag]+<a4j:log>+ component doesn't require any additional attributes for basic functionality.

[[sect-Component_Reference-log-Log_monitoring]]

==== Log monitoring

The [varname]+mode+ attribute determines how the log appears on the page.

* Set [code]+mode="inline"+ to place the logging data in-line on the current page. This is the default setting.
* Set [code]+mode="popup"+ to present the logging data in a new pop-up window. The window is set to be opened by pressing the key combination kbd:[Ctrl+Shift+L]; this can be partially reconfigured with the [varname]+hotkey+ attribute, which specifies the letter key to use in combination with kbd:[Ctrl+Shift] instead of kbd:[L].
* Set [code]+mode="console"+ to present the logging data in the JavaScript console of the browser.


The amount of data logged can be determined with the [varname]+level+ attribute:

* Set [code]+level="ERROR"+ to log all errors.
* Set [code]+level="FATAL"+ to log only fatal messages.
* Set [code]+level="INFO"+ to log only informational messages.
* Set [code]+level="WARN"+ to log only warning messages.
* Set [code]+level="ALL"+ to log all data. This is the default setting.


[[exam-Component_Reference-log-log_example]]

.[sgmltag]+<a4j:log>+ example
====


[source, XML]
----
<a4j:log level="ALL" mode="inline" />

----

image::figu-Component_Reference-log-log_example.png[]

The log readout displays all messages.

====

[NOTE]
.Log renewal
====
The log is automatically renewed after each Ajax request. It does not need to be explicitly re-rendered. To clear previous requests, implement a [guilabel]#Clear# button or similar functionality.
====

[[sect-Component_Reference-log-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.AjaxLog+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIAjaxLog+
* [parameter]+component-family+: [classname]+org.richfaces.AjaxLog+
* [parameter]+renderer-type+: [classname]+org.richfaces.AjaxLogRenderer+


[[sect-Component_Reference-log-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

The [sgmltag]+<a4j:log>+ component is intended primarily for debugging during development. However it is still possible to style the component if desired.

include::skinning/log.asciidoc[]

[[sect-Component_Reference-Processing_management-status]]

=== [sgmltag]+<a4j:status>+

The [sgmltag]+<a4j:status>+ component displays the status of current Ajax requests. The status can be either in progress, complete, or an error is shown after a failed request.

[[sect-Component_Reference-status-Customizing_the_text]]

==== Customizing the text

The text display can be customized depending on the current status.

* The [varname]+startText+ attribute defines the text shown after the request has been started and is currently in progress. Set the styles for the text with the [varname]+startStyle+ and [varname]+startStyleClass+ attributes. Alternatively, use the +start+ facet to customize the text appearance.

* The [varname]+stopText+ attribute defines the text shown once the request is complete. Set the styles for the text with the [varname]+stopStyle+ and [varname]+stopStyleClass+ attributes. Alternatively, use the +stop+ facet to customize the text appearance.
+
If the [varname]+stopText+ attribute is not defined, and no facet exists for the stopped state, the complete status is simply not shown. In this way, only the progress of the request is displayed to the user, along with any errors.

* The [varname]+errorText+ attribute defines the text shown when an error has occurred. Set the styles for the text with the [varname]+errorStyle+ and [varname]+errorStyleClass+ attributes. Alternatively, use the +error+ facet to customize the text appearance.


[[exam-Component_Reference-status-Basic_status_usage]]

.Basic [sgmltag]+<a4j:status>+ usage
====


[source, XML]
----
<a4j:status startText="In progress..." stopText="Complete" />

----

====

[[sect-Component_Reference-status-Specifying_a_region]]

==== Specifying a region

The [sgmltag]+<a4j:status>+ component monitors the status of the region relevant to where it is placed.

* If unnamed and placed outside any forms, it monitors the status at the view level.
* If unnamed and placed inside a form, it monitors the status at the form level.


However, if identified with the [varname]+name+ attribute, the [sgmltag]+<a4j:status>+ component can monitor any Ajax component or behavior. Use the [varname]+status+ attribute on the Ajax component or behavior to reference the [varname]+name+ identifier of the [sgmltag]+<a4j:status>+ component.

[[exam-Component_Reference-status-Updating_a_referenced_status_component]]

.Updating a referenced [sgmltag]+<a4j:status>+ component
====


[source, XML]
----
<rich:panel>
   <f:facet name="header">
      <h:outputText value="User Details Panel" />
   </f:facet>
   <h:panelGrid columns="3">
      <h:outputText value="User name:" />
      <h:inputText value="#{userBean.name}">
         <a4j:ajax status="nameStatus" event="keyup" />
      </h:inputText>
      <a4j:status name="nameStatus">
         <f:facet name="start">
            <h:graphicImage value="/images/ai.gif" />
         </f:facet>
      </a4j:status>
      <h:outputText value="Address:" />
      <h:inputText value="#{userBean.address}">
         <a4j:ajax status="addressStatus" event="keyup" />
      </h:inputText>
      <a4j:status name="addressStatus">
         <f:facet name="start">
            <h:graphicImage value="/images/ai.gif" />
         </f:facet>
      </a4j:status>
   </h:panelGrid>
</rich:panel>

----

====

[[sect-Component_Reference-status-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<a4j:status>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+start()+:: Switches status to the +start+ state.
[function]+stop()+:: Switches status to the +stop+ state.
[function]+error()+:: Switches status to the +error+ state.
[[sect-Component_Reference-status-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Status+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIStatus+
* [parameter]+component-family+: [classname]+org.richfaces.Status+
* [parameter]+renderer-type+: [classname]+org.richfaces.StatusRenderer+


[[part-Component_Reference-User_interface_components]]

= User interface components

[[chap-Component_Reference-inputs]]

== Rich inputs

This chapter details components for user input and interaction.

[[sect-Component_Reference-inputs-autocomplete]]

=== [sgmltag]+<rich:autocomplete>+

The [sgmltag]+<rich:autocomplete>+ component is an auto-completing input-box with built-in Ajax capabilities. It supports client-side suggestions, browser-like selection, and customization of the look and feel.

The auto-complete box is a standard JSF [classname]+UIInput+ control with added validation.

[[figu-Component_Reference-autocomplete-autocomplete]]
.[sgmltag]+<rich:autocomplete>+
image::figu-Component_Reference-autocomplete-autocomplete.png[]


[[sect-Component_Reference-autocomplete-Basic_usage]]

==== Basic usage

The [varname]+value+ attribute stores the text entered by the user for the auto-complete box. Suggestions shown in the auto-complete list can be specified using one of two different methods:

* The [varname]+autocompleteMethod+ attribute points to a method which returns a list of suggestions according to a supplied prefix.

[NOTE]
.+client+ and +lazyClient+ modes
====
The prefix is normally ignored in +client+ and +lazyClient+ modes. In these modes, the component requests the suggestion list once only, and performs filtering on the client.
====

* The [varname]+autocompleteList+ attribute points to a collection of suggestions.


[[exam-Component_Reference-autocomplete-Defining_suggestion_values]]

.Defining suggestion values
====

Using the [varname]+autocompleteMethod+  attribute::
+
[source, XML]
----
<rich:autocomplete value="#{bean.state}" autocompleteMethod="#{bean.autocomplete}" />

----
+
The [sgmltag]+<rich:autocomplete>+ component uses the [methodname]+bean.autocomplete+ method to provide suggestions, based on the entered prefix.

Using the [varname]+autocompleteList+  attribute::
+
[source, XML]
----
<rich:autocomplete value="#{bean.state}" autocompleteList="#{bean.suggestions}" />

----
+
The [sgmltag]+<rich:autocomplete>+ component retrieve the suggestion list from [methodname]+bean.suggestions+.
====

[[sect-Component_Reference-autocomplete-Submission_modes]]

==== Submission modes

Use the [varname]+mode+ attribute to determine how the suggestion list is requested:

* The +client+ setting pre-loads data to the client and uses the input to filter the possible suggestions.
* The +ajax+ setting fetches suggestions with every input change using Ajax requests.
* The +lazyClient+ setting pre-loads data to the client and uses the input to filter the possible suggestions. The filtering does not start until the input length matches a minimum value. Set the minimum value with the [varname]+minChars+ attribute.
* The +cachedAjax+ setting pre-loads data via Ajax requests when the input length matches a minimum value. Set the minimum value with the [varname]+minChars+ attribute. All suggestions are handled on the client until the input prefix is changed, at which point a new request is made based on the new input prefix.


[[sect-Component_Reference-autocomplete-Interactivity_options]]

==== Interactivity options

Users can type into the text field to enter a value, which also searches through the suggestion items in the drop-down box. By default, the first suggestion item is selected as the user types. This behavior can be deactivated by setting [code]+selectFirst="false"+.

Setting [code]+autofill="true"+ causes the [sgmltag]+<rich:autocomplete>+ to fill the text field box with a matching suggestion as the user types.

To allow users to enter multiple values separated by specific characters, use the [varname]+tokens+ attribute. As the user types, a suggestion will present as normal. When they enter a character specified as a token, this begins a new suggestion process, and the component only uses text entered after the token character for suggestions. For example, if [code]+tokens=", "+ is set, the [sgmltag]+<rich:autocomplete>+ component uses both the comma and space characters as tokens to separate entries. When the user enters a comma or a space, a new suggestion process begins.

[NOTE]
.Using tokens
====
When declaring tokens, avoid using any characters that are present in the list of suggestions. This may cause unexpected behavior as the user expects the character to match suggestions instead of separating suggested entries.
====

[[sect-Component_Reference-autocomplete-Customizing_the_filter_in_client_and_lazyClient_modes]]

==== Customizing the filter in +client+ and +lazyClient+ modes

The [sgmltag]+<rich:autocomplete>+ component uses the JavaScript [function]+startsWith()+ method to create the list of suggestions. The filtering is performed on the client side. Alternatively, use the [varname]+clientFilterFunction+ attribute to specify a custom filtering function. The custom function must accept two parameters: the [varname]+subString+ parameter is the filtering value as typed into the text box by the user, and the [varname]+value+ parameter is an item in the list of suggestions against which the [varname]+subString+ must be checked. Each item is iterated through and passed to the function as the [varname]+value+ parameter. The custom function must return a boolean value indicating whether the passed item meets the conditions of the filter, and the suggestion list is constructed from successful items.

[[exam-Component_Reference-autocomplete-Customizing_the_filter]]

.Customizing the filter
====

This example demonstrates how to use a custom filter with the [varname]+clientFilterFunction+ attribute. The custom filter determines if the sub-string is contained anywhere in the suggestion item, instead of just at the start.


[source, XML]
----
<script>
   function customFilter(subString, value){
      if(subString.length>=1) {
         if(value.indexOf(subString)!=-1)
            return true;
      }else return false;
   };
</script>
<h:form>
   <rich:autocomplete mode="client" minChars="0" autofill="false"
                      clientFilterFunction="customFilter"
                      autocompleteMethod="#{autocompleteBean.autocomplete}" />
</h:form>
----

====

[[sect-Component_Reference-autocomplete-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:autocomplete>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the text field.
[function]+setValue(newValue)+:: Set the value of the text field to the [parameter]+newValue+ string passed as a parameter.
[function]+showPopup()+:: Show the pop-up list of completion values.
[function]+hidePopup()+:: Hide the pop-up list.
[function]+focus()+:: Focus the input element.
[[sect-Component_Reference-autocomplete-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Autocomplete+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIAutocomplete+
* [parameter]+component-family+: [classname]+javax.faces.Input+
* [parameter]+renderer-type+: [classname]+org.richfaces.AutocompleteRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.AutocompleteHandler+


[[sect-Component_Reference-autocomplete-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/autocomplete.asciidoc[]

[[sect-Component_Reference-inputs-calendar]]

=== [sgmltag]+<rich:calendar>+

The [sgmltag]+<rich:calendar>+ component allows the user to enter a date and time through an in-line or pop-up calendar. The pop-up calendar can navigate through months and years, and its look and feel can be highly customized.

[[figu-Component_Reference-calendar-calendar]]
.[sgmltag]+<rich:calendar>+
image::figu-Component_Reference-calendar-calendar.png[]


[[sect-Component_Reference-calendar-Basic_usage]]

==== Basic usage

Basic usage of the [sgmltag]+<rich:calendar>+ component requires only the [varname]+value+ attribute, which holds the currently selected date. <<exam-Component_Reference-calendar-Basic_usage>> shows a basic declaration, with the value pointing to a bean property. The bean property holds the selected date.

[[exam-Component_Reference-calendar-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:calendar value="#{bean.dateTest}" />

----

====

[[sect-Component_Reference-calendar-Behavior_and_appearance]]

==== Behavior and appearance

The [sgmltag]+<rich:calendar>+ component is presented as a pop-up by default, appearing as a text field with a button to expand the full pop-up calendar. To render the calendar in-line on the page instead, set [code]+popup="false+. This displays the full calendar without the text field and display button.

To add keyboard support for manual input, set [code]+enableManualInput="true"+. To disable the calendar from any user input, set [code]+disabled="true"+.

To change the appearance of the display button from the standard calendar icon, use the [varname]+buttonIcon+ and [varname]+buttonDisabledIcon+ attributes to replace the icon with a specified file. Alternatively, use the [varname]+buttonLabel+ attribute to display text on the button without an icon. If [varname]+buttonLabel+ is specified then both the [varname]+buttonIcon+ and [varname]+buttonDisabledIcon+ attributes are ignored. To hide the text field box, set [code]+showInput="false"+.

The calendar features a [guibutton]#Today# button for locating today's date on the calendar. This can be set to three different values using the [varname]+todayControlMode+ attribute:

* +hidden+, which does not display the button;
* +select+, the default setting, which scrolls the calendar to the current month and selects the date; and
* +scroll+, which scrolls the calendar to the month but does not select the date.
* +inactive+, which displays the date but performs no action when clicked.


To make the entire calendar read-only, set [code]+readonly="true"+. This allows months and years to be browsed through with the arrow controls, but dates and times cannot be selected.

Calendar also supports keyboard navigation, with the pop-up appearing when calendar gains focus, if [code]+enableManualInput="true"+ is set the pop-up can be brought up by the kbd:[up arrow] key.

* arrows keys - changing days/weeks
* pageDown, pageUp - changing months
* shift + pageDown, pageUp - changing years
* Enter - applying the selected date
* T - selecting today
* C - clearing the selection
* H - opening the Time editor
** up/down arrows - increasing/decreasing value
** TAB - switching between hours, minutes, seconds, am/pm
** Esc - closing the editor
** Enter - saving the value and closing the editor

[[sect-Component_Reference-calendar-Time_of_day]]

==== Time of day

The [sgmltag]+<rich:calendar>+ component can additionally allow a time of day to be specified with the date. After selecting a date the option to set a time becomes available. The default time can be set with the [varname]+defaultTime+ attribute. If the time is altered and a new date is selected, it will not reset unless [code]+resetTimeOnDateSelect="true"+ is specified.

The date selection feature is activated if the time is present in the [varname]+datePattern+ attribute for the calendar.

[NOTE]
.Support for seconds
====
In RichFaces 4, the [sgmltag]+<rich:calendar>+ component supports times that include seconds. Previous versions of RichFaces only supported hours and minutes.
====

[[sect-Component_Reference-calendar-Localization_and_formatting]]

==== Localization and formatting

Date and time strings can be formatted in a set pattern. Use standard locale formatting strings specified by *_ISO 8601_* (for example, +d/M/yy HH:mm a+) with the [varname]+datePattern+ attribute to format date and time strings.

To set the locale of the calendar, use the [varname]+locale+ attribute. The calendar will render month and day names in the relevant language. For example, to set the calendar to the US locale, specify [code]+locale="en/US"+.

Use an application resource bundle to localize the calendar control labels. Define the following strings in the resource bundle:

* The [property]+RICH_CALENDAR_APPLY_LABEL+ string is the label for the [guibutton]#Apply# button.
* The [property]+RICH_CALENDAR_TODAY_LABEL+ string is the label for the [guibutton]#Today# button.
* The [property]+RICH_CALENDAR_CLOSE_LABEL+ string is the label for the [guibutton]#Close# button.
* The [property]+RICH_CALENDAR_OK_LABEL+ string is the label for the [guibutton]#OK# button.
* The [property]+RICH_CALENDAR_CLEAN_LABEL+ string is the label for the [guibutton]#Clean# button.
* The [property]+RICH_CALENDAR_CANCEL_LABEL+ string is the label for the [guibutton]#Cancel# button.


Alternatively, use the [classname]+org.richfaces.calendar+ resource bundle with Java Archive files ( [acronym]++JAR++ s) defining the same properties.

[[sect-Component_Reference-calendar-Using_a_data_model]]

==== Using a data model

The look and feel of the [sgmltag]+<rich:calendar>+ component can be customized through the use of a data model on the server side. The component supports two different ways of loading data from the server side through defining the [varname]+mode+ attribute.

When the [varname]+mode+ attribute is not specified, the component uses the +client+ mode. The +client+ mode loads an initial portion of data within a set date range. The range can be defined by using the [varname]+preloadDateRangeBegin+ and [varname]+preloadDateRangeEnd+ attributes. Additional data requests for months outside the range are not sent.

Alternatively, with [code]+mode="ajax"+ the [sgmltag]+<rich:calendar>+ requests portions of data from the data model every time the month is switched. The data model can be defined through the [varname]+dataModel+ attribute, which points to an object that implements the [classname]+CalendarDataModel+ interface. If the [varname]+dataModel+ attribute is not defined or has a value of +null+, the +ajax+ mode functions the same as the +client+ mode.

[[sect-Component_Reference-calendar-Client-side_customization]]

==== Client-side customization

Instead of using a data model, the [sgmltag]+<rich:calendar>+ component can be customized on the client-side using JavaScript. Use the [varname]+dayClassFunction+ attribute to reference the function that determines the CSS style class for each day cell. Use the [varname]+dayDisableFunction+ to reference the function that enables or disables a day cell. <<exam-Component_Reference-calendar-Client-side_customization>> demonstrates how client-side customization can be used to style different days in a calendar.

[[exam-Component_Reference-calendar-Client-side_customization]]

.Client-side customization
====


[source, XML]
----
<style>
   .everyThirdDay {
      background-color: gray;
   }
   .weekendBold {
      font-weight: bold;
      font-style: italic;
   }
</style>
<script type="text/javascript">
   var curDt = new Date();
   function disablementFunction(day){
      if (day.isWeekend) return false;
      if (curDt==undefined){
         curDt = day.date.getDate();
      }
      if (curDt.getTime() - day.date.getTime() &lt; 0) return true;
      else return false;
   }
   function disabledClassesProv(day){
      if (curDt.getTime() - day.date.getTime() &gt;= 0) return 'rf-ca-boundary-dates';
      var res = '';
      if (day.isWeekend) res+='weekendBold ';
      if (day.day%3==0) res+='everyThirdDay';
      return res;
   }
</script>
<rich:calendar dayDisableFunction="disablementFunction"
               dayClassFunction="disabledClassesProv"
               boundaryDatesMode="scroll" />

----

====

[[sect-Component_Reference-calendar-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:calendar>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+showPopup()+:: Expand the pop-up calendar element.
[function]+hidePopup()+:: Collapse the pop-up calendar element.
[function]+switchPopup()+:: Invert the state of the pop-up calendar element.
[function]+getValue()+:: Return the selected date value of the calendar.
[function]+getValueAsString()+:: Return the selected date value of the calendar as a formatted string.
[function]+setValue(newValue)+:: Set the selected date value to the [parameter]+newValue+ date passed as a parameter. If the new date is not in the currently displayed month, a request is performed to display the correct month.
[function]+resetValue()+:: Clear the selected date value.
[function]+today()+:: Select today's date.
[function]+getCurrentMonth()+:: Return the number of the month currently being displayed.
[function]+getCurrentYear()+:: Return the number of the year currently being displayed.
[function]+showSelectedDate()+:: Show the calendar month that contains the currently selected date.
[function]+showDateEditor()+:: Show the date editor pop-up.
[function]+hideDateEditor()+:: Hide the date editor pop-up.
[function]+showTimeEditor()+:: Show the time editor pop-up.
[function]+hideTimeEditor()+:: Hide the time editor pop-up.
[function]+focus()+:: Focus the input element.
[[sect-Component_Reference-calendar-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Calendar+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICalendar+
* [parameter]+component-family+: [classname]+org.richfaces.Calendar+
* [parameter]+renderer-type+: [classname]+org.richfaces.CalendarRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.CalendarHandler+


[[sect-Component_Reference-calendar-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/calendar.asciidoc[]

[[sect-Component_Reference-inputs-editor]]

=== [sgmltag]+<rich:editor>+

The [sgmltag]+<rich:editor>+ component is used for creating a WYSIWYG editor on a page.

[[figu-Component_Reference-editor-editor]]
.[sgmltag]+<rich:editor>+
image::figu-Component_Reference-editor-editor.png[width="400"]


[sgmltag]+<rich:editor>+ component is based on the CKEditor implementation.

When rendering a [sgmltag]+<rich:editor>+, a textarea is rendered to the page and once the page is completely loaded (ready state), the textarea is enhanced using a CKEditor script and replaced with a full-featured WYSIWYG editor.

[[sect-Component_Reference-editor-Basic_usage]]

==== Basic usage

Basic usage requires the [varname]+value+ attribute to point to the expression for the current value of the component.

.Basic usage of [sgmltag]+<rich:editor>+
====


[source, XML]
----
<rich:editor value="#{backingBean.editedValue}" />

<h:outputText escape="false" value="#{backingBean.editedValue}" />
----

Note that the editor produces HTML markup and to be able to render it's output, the markup needs to be unescaped (as with [sgmltag]+<h:outputText>+ component in example above).

====

The dimensions of the editor can be managed using [parameter]+width+ and [parameter]+height+ attributes.

The [parameter]+readonly+ attribute can be used to switch the editor into a read-only mode.

The [parameter]+tabindex+ attribute specifies the position of the current element in the tabbing order for the current document.

[NOTE]
====

The [code]+ResourceServlet+  has to be registered for the [code]+url-pattern+ [code]+/org.richfaces.resources/\*+  in order to serve the editor resources (JavaScript, CSS, images) correctly. Check the _RichFaces Developer's Guide_  for further details.

====

[NOTE]
====

The [sgmltag]+<rich:editor>+  requires the [sgmltag]+<h:body>+  component to be present in the view and must be an ancestor of the editor in order for the resource dependencies to render correctly.

====

[NOTE]
====

The [sgmltag]+<rich:editor>+ inside a [sgmltag]+<rich:popupPanel>+ requires the [parameter]+domElementAttachment+ attribute of the popup panel to be set to "parent".

====

[[sect-Component_Reference-editor-Styling]]

==== Styling

There are several options to customize the style of the editor:

* [parameter]+style, styleClass+: customizes the style of the editor and underlying textarea
* [parameter]+editorStyle, editorClass+: customizes the style of the CKEditor instance
* [parameter]+textareaStyle, textareaClass+: customizes the style of the underlying textarea


[[sect-Component_Reference-editor-Editor_skins]]

==== Editor skins

The [sgmltag]+<rich:editor>+ is skinnable using the JavaScript API of the CKeditor.  Refer to the http://docs.ckeditor.com/#!/guide/dev_skins[CKeditor documentation on installing skins] for details on how to customize the look and feel of the editor component.

[[sect-Component_Reference-editor-Advanced_configuration]]

==== Advanced configuration

The basic set of [sgmltag]+<rich:editor>+ attributes allows you to support common use-cases for a WYSIWYG editor. However the underlying CKEditor implementation supports many more configuration options.

Use the [parameter]+config+ attribute to define any of these advanced configuration options supported by the CKEditor. This configuration is written in JavaScript object format and its value is interpolated for EL expressions (making configuration dynamic).

There are two ways to define the configuration: the [parameter]+config+ attribute or a facet named [parameter]+config+. The facet takes precedence over attribute when both are defined.


[source, XML]
----
<rich:editor config="startupFocus: #{userPreferences.startupFocus}" />

<rich:editor>
    <f:facet name="config">
        startupFocus: #{userPreferences.startupFocus}
    </f:facet>
</rich:editor>
----

In the above samples, the [sgmltag]+<rich:editor>+ is configured to take focus after loading the page as defined by the userPreference bean. Definitions using either attribute or facet are equivalent.

[NOTE]
====

For further configuration options, refer to link:$$http://docs.ckeditor.com/#!/guide$$[CKEditor 4 Developer Guide]  and link:$$http://docs.ckeditor.com/#!/api/CKEDITOR.config$$[CKEditor 4 configuration reference].

====

[[sect-Component_Reference-editor-Toolbar_customization]]

==== Toolbar customization

The [sgmltag]+<rich:editor>+ supports a [parameter]+toolbar+ attribute, which is able to change the configuration of the toolbar's button set. There are two configurations available: [code]+basic+ (default), [code]+full+ (enables all of the features).

It is also possible to define a custom toolbar using the CKEditor toolbar configuration in a [code]+config+ facet:


[source, XML]
----
<rich:editor toolbar="CustomToolbar">
    <f:facet name="config">
        toolbar_CustomToolbar:
        [
        { name: 'document', items : [ 'NewPage','Preview' ] },
        { name: 'clipboard', items : [ 'Cut','Copy','Paste','-','Undo','Redo' ] },
        { name: 'editing', items : [ 'Find','Replace','-','SelectAll','-','Scayt' ] },
        { name: 'insert', items : [ 'Image', 'Flash', 'Table', 'HorizontalRule',
                 'Smiley', 'SpecialChar', 'PageBreak', 'Iframe' ] },
                '/',
        { name: 'styles', items : [ 'Styles','Format' ] },
        { name: 'basicstyles', items : [ 'Bold','Italic','Strike','-','RemoveFormat' ] },
        { name: 'paragraph', items : [ 'NumberedList','BulletedList','-','Outdent','Indent','-','Blockquote' ] },
        { name: 'links', items : [ 'Link','Unlink','Anchor' ] },
        { name: 'tools', items : [ 'Maximize' ] }
        ]
        </f:facet>
</rich:editor>
----

Note that toolbar name ( [code]+CustomToolbar+) needs to match the [code]+toolbar_<name>+ configuration option.

[[sect-Component_Reference-editor-Internationalization_and_localization]]

==== Internationalization and localization

The [sgmltag]+<rich:editor>+ comes with a [parameter]+lang+ attribute which allows you to change the localization of the editor. For language configuration options, refer to http://www.w3.org/TR/html4/struct/dirlang.html.

The [parameter]+lang+ attribute influences following settings:

* _underlying textarea_ - specifies the i18n settings for received and submitted content
* _editor value_ - specifies the i18n settings for value edited in WYSIWYG mode
* _default settings of localization_ of editor controls and interface


However the interface first localized using the browser configuration (usually determined by client system settings). To force the editor to use a specific localization for the interface, you use the advanced CKEditor configuration option [code]+language+, as in following sample:


[source, XML]
----
<rich:editor lang="fr" config="language: 'fr'" />
----

The above sample forces the editor to use a french interface, suppressing the browser preferred settings.

[[sect-Component_Reference-editor-Client_side_event_handlers]]

==== Client-side event handlers

The [sgmltag]+<rich:editor>+ component produces set of events for handling component specific interaction.

* [parameter]+init+ - once the editor is initialized and ready to be handle user interaction
* [parameter]+focus+ - once the editor is focused
* [parameter]+blur+ - once the editor is blurred
* [parameter]+change+ - fired on blur event when editor content has been changed after previous focus
* [parameter]+dirty+ - fired immediately after editor content has been changed


Events can be handled either by registering a JavaScript event handler or by attaching JSF behavior:


[source, XML]
----
<rich:editor value="#{backingBean.editorValue}">
    <a4j:ajax event="change" render="editorOutput" />
    <a4j:ajax event="dirty" render="editorOutput">
        <a4j:attachQueue requestDelay="1000" />
    </a4j:ajax>
</rich:editor>

<a4j:outputPanel id="editorOutput">
    <h:outputText escape="false" value="#{backingBean.editorValue}" />
</a4j:outputPanel>
----

The example above shows the editor and its output, which is updated every second after each instant change or immediately after user focus leaves the editor area.

[[sect-Component_Reference-editor-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:editor>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the input control.
[function]+setValue(newValue)+:: Set the value of the input control to the [parameter]+newValue+ string passed as a parameter.
[function]+getEditor()+:: Returns the CKEditor object instance associated to given [sgmltag]+<rich:editor>+ component.
[function]+getInput()+:: Returns the associated textarea.
[function]+focus()+:: Gives focus to this component
[function]+blur()+:: Removes focus from this component
[function]+isFocused()+:: Returns +true+ if this component is focused
[function]+isDirty()+:: Returns +true+ if editor is focused and it was edited from last focus event (reset by blur event, by using [code]+setValue(newValue)+ call and when component is re-rendered)
[function]+isValueChanged()+:: Returns +true+ if the control's value has been changed from the default (reset by [code]+setValue(newValue)+ call and when component is re-rendered)
[function]+isReadonly()+:: Returns +true+ if editor content is editable.
[function]+setReadonly(readonly)+:: When +readonly+ is +true+, editor will be switched to editable state. Otherwise, it will be switched to readonly state.
[[sect-Component_Reference-editor-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Editor+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIEditor+
* [parameter]+component-family+: [classname]+org.richfaces.Editor+
* [parameter]+renderer-type+: [classname]+org.richfaces.EditorRenderer+


[[sect-Component_Reference-editor-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/editor.asciidoc[]

[[sect-Component_Reference-inputs-fileUpload]]

=== [sgmltag]+<rich:fileUpload>+

The [sgmltag]+<rich:fileUpload>+ component allows the user to upload files to a server. It features multiple uploads, progress bars, restrictions on file types, and restrictions on sizes of the files to be uploaded.

[[sect-Component_Reference-fileUpload-Basic_usage]]

==== Basic usage

Basic usage requires the [varname]+fileUploadListener+ attribute. Use the attribute to reference a listener function on the server side after each file is uploaded. The listener should process files as required, such as storing them in the [filename]+session/db/filesystem/+ directory. The component itself does not store uploaded files, so if the listener is not implemented they are not stored anywhere.

[[exam-Component_Reference-fileUpload-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:fileUpload fileUploadListener="#{bean.listener}" />

----

====

[[sect-Component_Reference-fileUpload-Upload_settings]]

==== Upload settings

Files are uploaded to either the temporary folder (different for each operating system) or to [acronym]#RAM# (random-access memory), depending on the value of the [parameter]+org.richfaces.fileUpload.createTempFiles+ context parameter of the [filename]+web.xml+ settings file for the project. If the parameter is set to +true+, the files are uploaded to the temporary folder.

To limit the maximum size of the uploaded files, define the byte size with the [varname]+maxfileSize+ parameter on the component or with [parameter]+org.richfaces.fileUpload.maxRequestSize+ context parameter of the [filename]+web.xml+ settings file for the project.

[[sect-Component_Reference-fileUpload-Sanitizing_file_upload_input]]

==== Sanitizing file upload input

Any file is accepted by rich:fileUpload component by default. There are several parameters available for limiting what can user upload to the server:

[varname]+maxFilesQuantity+:: The [varname]+maxFilesQuantity+ parameter defines maximum number of files allowed to be uploaded. After a number of files in the list equals to the value of this attribute, "Add" button disappears and nothing could be uploaded even if you clear the whole list. In order to upload files again you should rerender the component.
[varname]+acceptedTypes+:: The [varname]+acceptedTypes+ parameter defines comma separated list of file extensions accepted by component. The component does not provide any feedback when rejecting file. For introducing feedback for rejection, use [varname]+ontyperejected+ parameter.
[varname]+ontyperejected+:: The [varname]+ontyperejected+ parameter defines event handler when file does not meet conditions stated by [varname]+acceptedTypes+ parameter.
[varname]+maxFileSize+:: The [varname]+maxFileSize+ parameter defines the maximum allowed size for a file.
[varname]+onsizerejected+:: The [varname]+onsizerejected+ parameter defines event handler when file exceeds the size defined by [varname]+maxFileSize+ parameter.
[[sect-Component_Reference-fileUpload-Interactivity_options]]

==== Interactivity options

Set the [varname]+immediateUpload+ attribute to +true+ to upload files as soon as they are added to the list, rather than waiting for the user to press the [guibutton]#Upload# button.

The text labels used in the component can be completely customized. Labels for the various controls of the component can be set using the following parameters:

[varname]+addLabel+:: The [varname]+addLabel+ parameter sets the label for the [guibutton]#Add# button.
[varname]+clearAllLabel+:: The [varname]+clearAllLabel+ parameter sets the label for the [guibutton]#Clear All# button.
[varname]+clearLabel+:: The [varname]+clearLabel+ parameter sets the label for the [guibutton]#Clear# button.
[varname]+uploadLabel+:: The [varname]+uploadLabel+ parameter sets the label for the [guibutton]#Upload# button.

The [sgmltag]+<rich:fileUpload>+ component provides a built-in progress bar to indicate the progress of each file that is uploaded. This progress bar can be replaced with a [sgmltag]+<rich:progressBar>+ component added to the +progress+ facet. Refer to <<sect-Component_Reference-Output_and_messages-progressBar>> for details on the [sgmltag]+<rich:progressBar>+ component.

To disable the [sgmltag]+<rich:fileUpload>+ component, use the [varname]+disabled+ attribute.

[[sect-Component_Reference-fileUpload-fileUpload_client-side_events]]

==== [sgmltag]+<rich:fileUpload>+ client-side events

There are a number of event handlers specific to the [sgmltag]+<rich:fileUpload>+ component:

* [varname]+filesubmit+ is triggered before a file is uploaded.
* [varname]+uploadcomplete+ is triggered after all files in the list have finished uploading.


[[sect-Component_Reference-fileUpload-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.FileUpload+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIFileUpload+
* [parameter]+component-family+: [classname]+org.richfaces.FileUpload+
* [parameter]+renderer-type+: [classname]+org.richfaces.FileUploadRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.FileUploadHandler+


[[sect-Component_Reference-fileUpload-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/fileUpload.asciidoc[]

[[sect-Component_Reference-inputs-inplaceInput]]

=== [sgmltag]+<rich:inplaceInput>+

The [sgmltag]+<rich:inplaceInput>+ component allows information to be entered in-line in blocks of text, improving readability of the text. Multiple input regions can be navigated with keyboard navigation. The component has three functional states: the _view_ state, where the component displays its initial setting, such as "click to edit"; the _edit_ state, where the user can input text; and the "changed" state, where the new value for the component has been confirmed but can be edited again if required.

[[sect-Component_Reference-inplaceInput-Basic_usage]]

==== Basic usage

Basic usage requires the [varname]+value+ attribute to point to the expression for the current value of the component. Validation and conversion rules for the JSF [classname]+UIInput+ control apply as usual.

[[sect-Component_Reference-inplaceInput-Interactivity_options]]

==== Interactivity options

When in the initial _view_ state, the starting label can be set using the [varname]+defaultLabel+ attribute. Alternatively, if the initial value is already set through the [varname]+value+ attribute, this is displayed instead.

Once the user has entered text, the label is stored in the model specified by the [varname]+value+ attribute. The use of the default label and value is shown in <<exam-Component_Reference-inplaceInput-Default_label_and_value>>.

[[exam-Component_Reference-inplaceInput-Default_label_and_value]]

.Default label and value
====


[source, XML]
----
<rich:inplaceInput value="#{bean.value}" defaultLabel="click to edit"/>

----

====

By default, the event to switch the component to the _edit_ state is a single mouse click. This can be changed using the [varname]+editEvent+ attribute to specify a different event.

The user can confirm and save their input in multiple ways:

* By default, pressing the kbd:[Enter] key will confirm and save the input.
* If [code]+showControls="true"+ is set, buttons for confirming or canceling are added to the component.
* If [code]+saveOnBlur="true"+ is set, the input is saved on the component's blur event.


Pressing the kbd:[Esc] key cancels editing in all cases.

[[sect-Component_Reference-inplaceInput-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:inplaceInput>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the input control.
[function]+setValue(newValue)+:: Set the value of the input control to the [parameter]+newValue+ string passed as a parameter.
[function]+isEditState()+:: Returns +true+ if the control is currently in the _edit_ state, or +false+ if the control is currently in the _view_ state.
[function]+isValueChanged()+:: Returns +true+ if the control's value has been changed from the default.
[function]+save()+:: Saves the current item as the control's value.
[function]+cancel()+:: Cancel editing the value.
[function]+getInput()+:: Return the DOM element for the input.
[function]+open()+:: Turn on the editable state and focus the input.
[[sect-Component_Reference-inplaceInput-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.InplaceInput+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIInplaceInput+
* [parameter]+component-family+: [classname]+org.richfaces.InplaceInput+
* [parameter]+renderer-type+: [classname]+org.richfaces.InplaceInputRenderer+


[[sect-Component_Reference-inplaceInput-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/inplaceInput.asciidoc[]

[[sect-Component_Reference-inputs-inplaceSelect]]

=== [sgmltag]+<rich:inplaceSelect>+

The [sgmltag]+<rich:inplaceSelect>+ component is similar to the [sgmltag]+<rich:inplaceInput>+ component, except that the [sgmltag]+<rich:inplaceSelect>+ component uses a drop-down selection box to enter text instead of a regular text field. Changes can be rendered either in-line or for the whole block, and inputs can be focused with keyboard navigation. The component is based on the JSF [classname]+UISelectOne+ component, so all the standard rules for value definition, processing, conversion, and validation apply.

The component has three functional states:

* When in the _view_ state, the component displays its initial setting, such as "click to edit".
* When in the _edit_ state, the user can select a value from a drop-down list.
* When in the _changed_ state, the new value for the component has been confirmed, but it can be edited again if required.


[[figu-Component_Reference-inplaceSelect-inplaceSelect]]
.[sgmltag]+<rich:inplaceSelect>+
image::figu-Component_Reference-inplaceSelect-inplaceSelect.png[]


[[sect-Component_Reference-inplaceSelect-Basic_usage]]

==== Basic usage

Basic usage requires the [varname]+value+ attribute to point to the expression for the current value of the component and a list of items. The list of items can be defined using the JSF components [sgmltag]+<f:selectItem/>+ and [sgmltag]+<f:selectItems/>+.

[[exam-Component_Reference-inplaceSelect-Defining_list_items_for_inplaceSelect]]

.Defining list items for [sgmltag]+<rich:inplaceSelect>+
====


[source, XML]
----
<rich:inplaceSelect value="#{bean.inputValue}" defaultLabel="click to edit" >
    <f:selectItems value="#{bean.selectItems}" />
    <f.selectItem itemValue="1" itemLabel="Item 1" />
    <f.selectItem itemValue="2" itemLabel="Item 2" />
    <f.selectItem itemValue="3" itemLabel="Item 3" />
    <f.selectItem itemValue="4" itemLabel="Item 4" />
</rich:inplaceSelect>

----

====

[[sect-Component_Reference-inplaceSelect-Interactivity_options]]

==== Interactivity options

When in the initial _view_ state, the starting label can be set using the [varname]+defaultLabel+ attribute, such as [code]+defaultLabel="click to edit"+. Alternatively, if the initial value is already set through the [varname]+value+ attribute, this is displayed instead.

By default, the event to switch the component to the _edit_ state is a single mouse click. This can be changed using the [varname]+editEvent+ attribute to specify a different event. When switching to _edit_ mode, the drop-down list of possible values will automatically be displayed; this can be deactivated by setting [code]+openOnEdit="false"+.

Once a new value for the control is saved, the state switches to the "changed" state. Saving a new value for the control can be performed in a number of ways:

* Once the user selects an item from the drop-down list, the item is saved as the new control value. This is the default setting. If [code]+saveOnSelect="false"+ is set, the component applies the selected item but remains in the _edit_ state so a different selection could be chosen. The value is then applied when the kbd:[Enter] key is pressed.
* If [code]+saveOnBlur="true"+ is set, the selected item is saved as the new control value when the control loses focus.
* If [code]+showControls="true"+ is set, buttons are added to the control to confirm or cancel the selection. The new control value is only saved once the user confirms the selection using the button.


Pressing the kbd:[Esc] key cancels editing in all cases.

[[sect-Component_Reference-inplaceSelect-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:inplaceSelect>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the select control.
[function]+setValue(newValue)+:: Set the value of the select control to the [parameter]+newValue+ string passed as a parameter.
[function]+isEditState()+:: Returns +true+ if the control is currently in the _edit_ state, or +false+ if the control is currently in the _view_ state.
[function]+isValueChanged()+:: Returns +true+ if the control's value has been changed from the default.
[function]+save()+:: Saves the current item as the control's value.
[function]+cancel()+:: Cancel editing the value.
[function]+getInput()+:: Return the input entered into the control by the user.
[function]+getLabel()+:: Return the default label of the control.
[function]+setLabel(newLabel)+:: Set the default label of the control to the [parameter]+newLabel+ string passed as a parameter.
[function]+showPopup()+:: Show the pop-up list of possible values.
[function]+hidePopup()+:: Hide the pop-up list.
[function]+open()+:: Turn on the editable state and focus the input.
[[sect-Component_Reference-inplaceSelect-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.InplaceSelect+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIInplaceSelect+
* [parameter]+component-family+: [classname]+org.richfaces.Select+
* [parameter]+renderer-type+: [classname]+org.richfaces.InplaceSelectRenderer+


[[sect-Component_Reference-inplaceSelect-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/inplaceSelect.asciidoc[]

[[sect-Component_Reference-inputs-inputNumberSlider]]

=== [sgmltag]+<rich:inputNumberSlider>+

The [sgmltag]+<rich:inputNumberSlider>+ component provides a slider for changing numerical values. Optional features include control arrows to step through the values, a tool-tip to display the value while sliding, and a text field for typing the numerical value which can then be validated against the slider's range.

[[figu-Component_Reference-inputNumberSlider-inputNumberSlider]]
.[sgmltag]+<rich:inputNumberSlider>+
image::figu-Component_Reference-inputNumberSlider-inputNumberSlider.png[]


[[sect-Component_Reference-inputNumberSlider-Basic_usage]]

==== Basic usage

Basic use of the component with no attributes specified will render a slider with a minimum value of 0, a maximum of 100, and a gradient step of 1, together with a text field for typing the desired numerical value. The slider is labeled with the minimum and maximum boundary values, and a tool-tip showing the current value is shown while sliding the slider. The [varname]+value+ attribute is used for storing the currently selected value of the slider. Standard conversion and validation for the JSF [classname]+UIInput+ component is applied.

[[sect-Component_Reference-inputNumberSlider-Interactivity_options]]

==== Interactivity options

The text field can be removed by setting [code]+showInput="false"+.

The properties of the slider can be set with the attributes [varname]+minValue+, [varname]+maxValue+, and [varname]+step+.

The minimum and maximum labels on the slider can be hidden by setting [code]+showBoundaryValues="false"+. The tool-tip showing the current value can be hidden by setting [code]+showToolTip="false"+.

Arrow controls can be added to either side of the slider to adjust the value incrementally by setting [code]+showArrows="true"+. Clicking the arrows move the slider indicator in that direction by the gradient step, and clicking and holding the arrows moves the indicator continuously. The time delay for each step when updating continuously can be defined using the [varname]+delay+ attribute.

[[sect-Component_Reference-inputNumberSlider-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:inputNumberSlider>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the slider control.
[function]+setValue(newValue)+:: Set the value of the slider control to the [parameter]+newValue+ integer passed as a parameter.
[function]+increase()+:: Increase the value of the slider control by the gradient step amount.
[function]+decrease()+:: Decrease the value of the slider control by the gradient step amount.
[function]+focus()+:: Focus the input element.
[[sect-Component_Reference-inputNumberSlider-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.InputNumberSlider+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlInputNumberSlider+
* [parameter]+component-family+: [classname]+org.richfaces.Input+
* [parameter]+renderer-type+: [classname]+org.richfaces.InputNumberSliderRenderer+


[[sect-Component_Reference-inputNumberSlider-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/inputNumberSlider.asciidoc[]

[[sect-Component_Reference-inputs-inputNumberSpinner]]

=== [sgmltag]+<rich:inputNumberSpinner>+

The [sgmltag]+<rich:inputNumberSpinner>+ component is a single-line input field with buttons to increase and decrease a numerical value. The value can be changed using the corresponding directional keys on a keyboard, or by typing into the field.

[[figu-Component_Reference-inputNumberSpinner-inputNumberSpinner]]
.[sgmltag]+<rich:inputNumberSpinner>+
image::figu-Component_Reference-inputNumberSpinner-inputNumberSpinner.png[]


[[sect-Component_Reference-inputNumberSpinner-Basic_usage]]

==== Basic usage

Basic use of the component with no attributes specified will render a number spinner with a minimum value of 1, a maximum value of 100, and a gradient step of 1.

These default properties can be re-defined with the attributes [varname]+minValue+, [varname]+maxValue+, and [varname]+step+ respectively. The starting value of the spinner is the minimum value unless otherwise specified with the [varname]+value+ attribute.

[[sect-Component_Reference-inputNumberSpinner-Interactivity_options]]

==== Interactivity options

When changing the value using the buttons, raising the value above the maximum or cause the spinner to restart at the minimum value. Likewise, when lowering below the minimum value the spinner will reset to the maximum value. This behavior can be deactivated by setting [code]+cycled="false"+, which will cause the buttons to stop responding when the reach the maximum or minimum value.

The ability to change the value by typing into the text field can be disabled by setting [code]+enableManualInput="false"+.

[[sect-Component_Reference-inputNumberSpinner-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:inputNumberSpinner>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the spinner control.
[function]+setValue(newValue)+:: Set the value of the spinner control to the [parameter]+newValue+ integer passed as a parameter.
[function]+increase()+:: Increase the value of the spinner control by the gradient step amount.
[function]+decrease()+:: Decrease the value of the spinner control by the gradient step amount.
[function]+focus()+:: Focus the input element.
[[sect-Component_Reference-inputNumberSpinner-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.InputNumberSpinner+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlInputNumberSpinner+
* [parameter]+component-family+: [classname]+org.richfaces.Input+
* [parameter]+renderer-type+: [classname]+org.richfaces.InputNumberSpinnerRenderer+


[[sect-Component_Reference-inputNumberSpinner-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/inputNumberSpinner.asciidoc[]

[[sect-Component_Reference-inputs-select]]

=== [sgmltag]+<rich:select>+

The [sgmltag]+<rich:select>+ component provides a drop-down list box for selecting a single value from multiple options. The [sgmltag]+<rich:select>+ component can be configured as a [sgmltag]+<rich:autocomplete>+, where it will accept typed input. The component also supports keyboard navigation. The [sgmltag]+<rich:select>+ component functions similarly to the JSF [classname]+UISelectOne+ component.

The [sgmltag]+<rich:select>+ can optionally be used in an auto-completing mode, where the values in the drop-down list are provided dynamically using either the [varname]+autocompleteMethod+ or [varname]+autocompleteList+ attributes.
If these attributes are omitted, the component operates in the traditional non-auto-completing mode.
Refer to the individual http://docs.jboss.org/richfaces/latest_4_X/vdldoc/rich/select.html[attribute documentation] to see which attributes are applicable only with an auto-completing select list.
Additionally refer to the <<sect-Component_Reference-inputs-autocomplete, [sgmltag]+<rich:autocomplete>+ section>> for details on configuring the ajax behaviour of the [sgmltag]+<rich:select>+ component.


[[figu-Component_Reference-select-select]]
.[sgmltag]+<rich:select>+
image::figu-Component_Reference-select-select.png[]


[[sect-Component_Reference-select-Basic_usage]]

==== Basic usage

Simple usage of the [sgmltag]+<rich:select>+ component requires the [varname]+value+ attribute to store the selected value. Additionally, child tags to manage the list of selections are required. The child tags can either be a number of [sgmltag]+<f:selectItem>+ tags or a [sgmltag]+<f:selectItems>+ tag which points to a data model containing a list of selection items. The [varname]+value+ attribute is used to store the current selection.

[[exam-Component_Reference-select-Selection_items]]

.Selection items
====

Using multiple [sgmltag]+<f:selectItem>+  tags::
[source, XML]
----
<rich:select>
   <f:selectItem itemValue="0" itemLabel="Option 1" />
   <f:selectItem itemValue="1" itemLabel="Option 2" />
   <f:selectItem itemValue="2" itemLabel="Option 3" />
   <f:selectItem itemValue="3" itemLabel="Option 4" />
   <f:selectItem itemValue="4" itemLabel="Option 5" />
</rich:select>

----

Using a single [sgmltag]+<f:selectItems>+  tag::
[source, XML]
----
<rich:select>
   <f:selectItems value="#{bean.options}" />
</rich:select>

----

====

The arrow keys on a keyboard can be used to highlight different items in the list. If the control loses focus or the kbd:[Enter] key is pressed, the highlighted option is chosen as the value and the list is closed. Pressing the kbd:[Esc] key will close the list but not change the value.

[[sect-Component_Reference-select-Using_manual_input]]

==== Using manual input

The [sgmltag]+<rich:select>+ component allows the user to type into a text field to scroll through or filter the list. By default, the [sgmltag]+<rich:select>+ component functions as a drop-down list with no manual input. To add keyboard support for manual input, set [code]+enableManualInput="true"+.

Once the user begins typing, the first available matching option is highlighted. If the typed text does not match any values in the list, no value is chosen and the drop-down list displays as empty. Other keyboard interaction remains the same as the basic drop-down list.

The standard JSF [sgmltag]+<h:selectOne>+ component does not offer this extended keyboard support. However, since the [sgmltag]+<rich:select>+ component is still based on the JSF [classname]+UISelectOne+ component, it will not accept a value that does not match any items in the drop-down list. If an invalid value is entered, it is highlighted as erroneous and validation messages appear with the submission.

[[sect-Component_Reference-select-Advanced_options]]

==== Advanced options

Use the [varname]+defaultLabel+ attribute to set a place-holder label, such as [code]+defaultLabel="select an option"+.

Server-side processing occurs in the same manner as for an [sgmltag]+<h:selectOneMenu>+ component. As such, custom objects used for selection items should use the same converters as for an [sgmltag]+<h:selectOneMenu>+ component.

[[sect-Component_Reference-select-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:select>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Get the current value of the text field.
[function]+setValue(newValue)+:: Set the value of the text field to the [parameter]+newValue+ string passed as a parameter.
[function]+getLabel()+:: Return the default label of the control.
[function]+showPopup()+:: Show the pop-up list of completion values.
[function]+hidePopup()+:: Hide the pop-up list.
[function]+focus()+:: Focus the input element.
[[sect-Component_Reference-select-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Select+
* [parameter]+component-class+: [classname]+org.richfaces.component.UISelect+
* [parameter]+component-family+: [classname]+org.richfaces.Select+
* [parameter]+renderer-type+: [classname]+org.richfaces.SelectRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.AutocompleteHandler+


[[sect-Component_Reference-select-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/select.asciidoc[]

[[sect-Component_Reference-inputs-orderingList]]

=== [sgmltag]+<rich:orderingList>+

The [sgmltag]+<rich:orderingList>+ is a component for ordering items in a list (client-side).

[[figu-Component_Reference-orderingList-orderingList]]
.[sgmltag]+<rich:select>+
image::figu-Component_Reference-orderingList-orderingList.png[]


[[sect-Component_Reference-orderingList-Basic_usage]]

==== Basic usage

To use the [sgmltag]+<rich:orderingList>+ bind the [varname]+value+ attribute to the list to be ordered. The [varname]+var+ attribute specifies a variable to use when iterating through the list values. The [varname]+var+ attribute is used within the [varname]+itemLabel+ to assign the object value to be displayed. Similarly, the [varname]+var+ attribute is used within the [varname]+itemValue+ attribute to specify the object value mapped by the display value. If the itemValue is not of type [classname]+String+, a converter must be specified for this itemValue using either the [varname]+converter+ attribute, or a nested [sgmltag]+<f:converter>+ tag.

[[exam-Component_Reference-orderingList-ItemLabel_use]]

.ItemLabel/ItemValue use
====

Using the [varname]+itemLabel+  and [varname]+itemValue+  attributes::
[source, XML]
----
<rich:orderingList value="#{listSelectBean.capitals}" var="capital" itemValue="#{capital}" itemLabel="#{capital.name}">
    <f:converter converterId="CapitalsConverter" />
</rich:orderingList>
----

====

The arrow keys on a keyboard can be used to highlight different items in the list. Pressing the ctrlmodifier with the arrow keys will move the selected item up or down within the list.

[[sect-Component_Reference-orderingList-Column_layout]]

==== Column Layout

In addition to the above simple itemLabel display, the [sgmltag]+<rich:orderingList>+ supports a columnar layout of the itemValues to be sorted. This is achieved by nesting [sgmltag]+<rich:column>+ tags within the orderingList, and referencing the [varname]+var+ attribute from within the [sgmltag]+<rich:column>+ EL.

[[exam-Component_Reference-orderingList-column]]

.Nested [sgmltag]+<rich:column>+ tags
====

Using [sgmltag]+<rich:column>+  tags nested within the [sgmltag]+<rich:orderingList>+::
[source, XML]
----
<rich:orderingList value="#{listSelectBean.capitals}" var="capital"  listWidth="300px">
    <f:converter converterId="CapitalsConverter" />
    <rich:column>
        <f:facet name="header">Flag</f:facet>
        <h:graphicImage value="#{capital.stateFlag}" alt="flag"  width="33"/>
    </rich:column>
    <rich:column>
        <f:facet name="header">Name</f:facet>
        #{capital.name}
    </rich:column>
    <rich:column>
        <f:facet name="header">State</f:facet>
        #{capital.state}
    </rich:column>
</rich:orderingList>
----

====

When using [sgmltag]+<rich:column>+ tags to layout the [sgmltag]+<rich:orderingList>+ items, the [varname]+itemLabel+ attribute is irrelevant, and may be left out.

[[sect-Component_Reference-orderingList-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:orderingList>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getList()+:: Returns the javascript list object backing the [sgmltag]+<rich:orderingList>+. This list can be used to select/unselect item(s).
[function]+up()+:: Move the currently selected item(s) up one step.
[function]+down()+:: Move the currently selected item(s) down one step.
[function]+upTop()+:: Move the currently selected item(s) to the top of the list.
[function]+downBottom()+:: Move the currently selected item(s) to the bottom of the list.
[function]+toggleButtons()+:: Activate/de-activate the orderingList buttons based on the current component item state.
[function]+focus()+:: Focus the list (to use keyboard navigation).
[[sect-Component_Reference-orderingList-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.OrderingList+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIOrderingList+
* [parameter]+component-family+: [classname]+org.richfaces.SelectMany+
* [parameter]+renderer-type+: [classname]+org.richfaces.OrderingListRenderer+


[[sect-Component_Reference-orderingList-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/orderingList.asciidoc[]

[[sect-Component_Reference-inputs-pickList]]

=== [sgmltag]+<rich:pickList>+

The [sgmltag]+<rich:pickList>+ is a component for selecting items from a list. Additionally, it allows for the selected items to be ordered (client-side). From the client side perspective, items are added/removed from the source list, and removed/added to the target list. However it is important to note that the server-side source of items is never modified, and always represents the list of all items available for selection. If the list of unselected items is required, it can be determined by subtracting the collection of all selected items from the collection of all available items.

[[figu-Component_Reference-pickList-pickList]]
.[sgmltag]+<rich:select>+
image::figu-Component_Reference-pickList-pickList.png[]


[[sect-Component_Reference-pickList-Basic_usage]]

==== Basic usage

To use the [sgmltag]+<rich:pickList>+ bind the [varname]+value+ attribute to the target list, where the selected items will be stored. The list of source items is provided by nesting a [classname]+SelectItem+ source, such as a [sgmltag]+<f:selectItems>+ tag, or a list of [sgmltag]+<f:selectItem>+ tags. If the itemValue of the [classname]+SelectItem+ is not of type [classname]+String+, a converter must be specified for this itemValue using either the [varname]+converter+ attribute, or a nested [sgmltag]+<f:converter>+ tag.

[[exam-Component_Reference-pickList-ItemLabel_use]]

.Simple pickList use
====

Using the default [classname]+SelectItem+  itemLabel to generate the pickList source and target items.::
[source, XML]
----
<rich:pickList value="#{listSelectBean.selectedCapitals}"
               sourceCaption="Available cities" targetCaption="Selected cities"
               listWidth="170px" listHeight="100px"
               orderable="true">
    <f:selectItems value="#{listSelectBean.capitals}" var="capital" itemValue="#{capital}" itemLabel="#{capital.name}" />
    <f:converter converterId="CapitalsConverter" />
</rich:pickList>
----

====

The items in the target list can be ordered client-side by setting the [varname]+orderable+ attribute of the [sgmltag]+<rich:pickList>+ tag to [code]+true+. The arrow keys on a keyboard can then be used to highlight different items in the target list, and pressing the ctrlmodifier with the arrow keys will move the selected item up or down within the target list.

[[sect-Component_Reference-pickList-Column_layout]]

==== Column Layout

In addition to the above simple [classname]+SelectItem+ itemLabel display, the [sgmltag]+<rich:pickList>+ supports a columnar layout of the items to be selected. This is achieved by adding a [varname]+var+ attribute used to represent the collection of nested [classname]+SelectItems+, and nesting [sgmltag]+<rich:column>+ tags within the pickList. The [varname]+var+ attribute of the [sgmltag]+<f:selectItem>+ is then referenced from within the [sgmltag]+<rich:column>+ EL.

[[exam-Component_Reference-pickList-column]]

.Nested [sgmltag]+<rich:column>+ tags
====

Using [sgmltag]+<rich:column>+  tags nested within the [sgmltag]+<rich:pickList>+::
[source, XML]
----
<rich:pickList value="#{listSelectBean.selectedCapitals}" var="capital" listHeight="200px">
    <f:selectItems value="#{listSelectBean.capitals}" />
    <f:converter converterId="CapitalsConverter" />
    <rich:column>
        <f:facet name="header">Flag</f:facet>
        <h:graphicImage value="#{capital.stateFlag}" alt="flag" width="33"/>
    </rich:column>
    <rich:column>
        <f:facet name="header">Name</f:facet>
        #{capital.name}
    </rich:column>
    <rich:column>
        <f:facet name="header">State</f:facet>
        #{capital.state}
    </rich:column>
</rich:pickList>
----

====

[[sect-Component_Reference-pickList-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:pickList>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getSourceList()+:: Returns the javascript list object backing the [sgmltag]+<rich:pickList>+ source list. This list can be used to select/unselect item(s).
[function]+getTargetList()+:: Returns the javascript list object backing the [sgmltag]+<rich:pickList>+ target list. This list can be used to select/unselect item(s).
[function]+add()+:: Add the currently selected items to the target list, removing them from the source list.
[function]+addAll()+:: Add all the source items to the target list, removing them from the source list.
[function]+remove()+:: Remove the currently selected items from the target list, adding them to the source list.
[function]+removeAll()+:: Remove all the source items from the target list, adding them to the source list.
[function]+toggleButtons()+:: Activate/de-activate the pickList buttons based on the current component item state.
[function]+focus()+:: Focus the source list (to use keyboard navigation).
[[sect-Component_Reference-pickList-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.PickList+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPickList+
* [parameter]+component-family+: [classname]+org.richfaces.SelectMany+
* [parameter]+renderer-type+: [classname]+org.richfaces.PickListRenderer+


[[sect-Component_Reference-pickList-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/pickList.asciidoc[]

[[chap-Component_Reference-Panels]]

== Panels

This chapter details those components which act as panels and containers to hold groups of other components.

[[sect-Component_Reference-Panels-panel]]

=== [sgmltag]+<rich:panel>+

The [sgmltag]+<rich:panel>+ component is a bordered panel with an optional header.

[[figu-Component_Reference-panel-panel]]
.[sgmltag]+<rich:panel>+
image::figu-Component_Reference-panel-panel.png[]


[[sect-Component_Reference-panel-Basic_usage]]

==== Basic usage

No attributes need to be listed for basic usage. a [sgmltag]+<rich:panel>+ without any attributes defined renders a bordered region with no header.

[[sect-Component_Reference-panel-Adding_a_header]]

==== Adding a header

To add a header to the panel, use the [varname]+header+ attribute to specify the text to appear in the header. Alternatively the header can be constructed using a header facet. <<exam-Component_Reference-panel-Adding_a_header>> demonstrates the two different approaches.

[[exam-Component_Reference-panel-Adding_a_header]]

.Adding a header
====


[source, XML]
----
<rich:panel header="This is the panel header">
    <h:outputText value="This is the panel content" />
</rich:panel>

----


[source, XML]
----
<rich:panel>
    <f:facet name="header">
        <h:outputText value="This is the panel header">
    </f:facet>
    <h:outputText value="This is the panel content" />
</rich:panel>

----

Both the examples render an identical panel.

[quote]
____
[[figu-Component_Reference-panel-Adding_a_header]]
.Adding a header
image::figu-Component_Reference-panel-Adding_a_header.png[]



____

====

[[sect-Component_Reference-panel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Panel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPanel+
* [parameter]+component-family+: [classname]+org.richfaces.Panel+
* [parameter]+renderer-type+: [classname]+org.richfaces.PanelRenderer+


[[sect-Component_Reference-panel-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/panel.asciidoc[]

[[sect-Component_Reference-Panels-accordion]]

=== [sgmltag]+<rich:accordion>+

The [sgmltag]+<rich:accordion>+ is a series of panels stacked on top of each other, each collapsed such that only the header of the panel is showing. When the header of a panel is clicked, it is expanded to show the content of the panel. Clicking on a different header will collapse the previous panel and epand the selected one. Each panel contained in a [sgmltag]+<rich:accordion>+ component is a [sgmltag]+<rich:accordionItem>+ component.

[[figu-Component_Reference-accordion-accordion]]
.A [sgmltag]+<rich:accordion>+ component containing three [sgmltag]+<rich:accordionItem>+ components
image::figu-Component_Reference-accordion-accordion.png[]


[[sect-Component_Reference-accordion-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:accordion>+ component requires no attributes for basic usage. The component can contain any number of [sgmltag]+<rich:accordionItem>+ components as children. The headers of the [sgmltag]+<rich:accordionItem>+ components control the expanding and collapsing when clicked. Only a single [sgmltag]+<rich:accordionItem>+ can be displayed at a time. Refer to <<sect-Component_Reference-Panels-accordionItem>> for details on the [sgmltag]+<rich:accordionItem>+ component.

[NOTE]
.Form elements required
====
All [sgmltag]+<rich:tabPanel>+ components should be wrapped in a form element when using either +ajax+ or +server+ mode, as usual for submitting components.
====

[[sect-Component_Reference-accordion-Switching_panels]]

==== Switching panels

The [varname]+activeItem+ attribute holds the active panel name. This name is a reference to the [varname]+name+ identifier of the active child [sgmltag]+<rich:accordionItem>+ component.

The switching mode for performing submissions is determined by the [varname]+switchType+ attribute, which can have one of the following three values:

+server+:: The default setting. Activation of a [sgmltag]+<rich:accordionItem>+ component causes the parent [sgmltag]+<rich:accordion>+ component to perform a common submission, completely refreshing the page. Only one panel at a time is rendered to the client side.
+ajax+:: Activation of a [sgmltag]+<rich:accordionItem>+ component causes the parent [sgmltag]+<rich:accordion>+ component to perform an Ajax form submission, and the content of the panel is rendered. Only one panel at a time is rendered to the client side.
+client+:: Activation of a [sgmltag]+<rich:accordionItem>+ component causes the parent [sgmltag]+<rich:accordion>+ component to perform updates on the client side. All the panels are rendered on the client side during the initial page render. JavaScript changes the styles such that one panel component becomes hidden while the other is shown.
[[sect-Component_Reference-accordion-accordion_client-side_events]]

==== [sgmltag]+<rich:accordion>+ client-side events

In addition to the standard Ajax events and HTML events, the [sgmltag]+<rich:accordion>+ component uses the client-side events common to all switchable panels:

* The [varname]+itemchange+ event points to the function to perform when the switchable item is changed.
* The [varname]+beforeitemchange+ event points to the function to perform when before the switchable item is changed.


[[sect-Component_Reference-accordion-accordion_server-side_events]]

==== [sgmltag]+<rich:accordion>+ server-side events

The [sgmltag]+<rich:accordion>+ component uses the server-side events common to all switchable panels:

* The [varname]+ItemChangeEvent+ event occurs on the server side when an item is changed through Ajax using the +server+ mode. It can be processed using the [varname]+ItemChangeListener+ attribute. Refer to <<sect-Component_Reference-Panels-itemChangeListener>> for details on the [sgmltag]+<rich:itemChangeListener>+ tag.


[[sect-Component_Reference-accordion-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:accordion>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions, which are common to all switchable panels:

[function]+getItems()+:: Return an array of the items contained in the accordion control.
[function]+getItemsNames()+:: Return an array of the names of the items contained in the accordion control.
[function]+switchToItem(itemName)+:: Switch to and display the item identified by the [parameter]+itemName+ string passed as a parameter.
[function]+firstItem()+, [function]+prevItem()+, [function]+nextItem()+, [function]+lastItem()+:: Get the name of the first item, the previous item, the next item, or the last item.
[[sect-Component_Reference-accordion-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Accordion+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIAccordion+
* [parameter]+component-family+: [classname]+org.richfaces.Accordion+
* [parameter]+renderer-type+: [classname]+org.richfaces.AccordionRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.TogglePanelTagHandler+


[[sect-Component_Reference-accordion-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/accordion.asciidoc[]

[[sect-Component_Reference-Panels-accordionItem]]

==== [sgmltag]+<rich:accordionItem>+

The [sgmltag]+<rich:accordionItem>+ component is a panel for use with the [sgmltag]+<rich:accordion>+ component. [sgmltag]+<rich:accordionItem>+ components can be added dynamically using iteration models with the [sgmltag]+<c:forEach>+ tag.

[[sect-Component_Reference-accordionItem-Basic_usage]]

===== Basic usage

Basic usage of the [sgmltag]+<rich:accordionItem>+ component requires the [varname]+header+ attribute, which provides the text on the panel header. The panel header is all that is visible when the accordion item is collapsed.

Alternatively the +header+ facet could be used in place of the [varname]+header+ attribute. This would allow for additional styles and custom content to be applied to the tab.

[[sect-Component_Reference-accordionItem-accordionItem_client-side_events]]

===== [sgmltag]+<rich:accordionItem>+ client-side events

In addition to the standard HTML events, the [sgmltag]+<rich:accordionItem>+ component uses the client-side events common to all switchable panel items:

* The [varname]+enter+ event points to the function to perform when the mouse enters the panel.
* The [varname]+leave+ event points to the function to perform when the mouse leaves the panel.


[[sect-Component_Reference-accordionItem-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.AccordionItem+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIAccordionItem+
* [parameter]+component-family+: [classname]+org.richfaces.AccordionItem+
* [parameter]+renderer-type+: [classname]+org.richfaces.AccordionItemRenderer+


[[sect-Component_Reference-Panels-collapsiblePanel]]

=== [sgmltag]+<rich:collapsiblePanel>+

The [sgmltag]+<rich:collapsiblePanel>+ component is a collapsible panel that shows or hides content when the header bar is activated. It is a simplified version of [sgmltag]+<rich:togglePanel>+ component.

[[figu-Component_Reference-collapsiblePanel-collapsiblePanel]]
.[sgmltag]+<rich:collapsiblePanel>+
image::figu-Component_Reference-collapsiblePanel-collapsiblePanel.png[]


[[sect-Component_Reference-collapsiblePanel-Basic_usage]]

==== Basic usage

Basic usage requires the header content is specified either by the [varname]+header+ attribute, or by the [varname]+headerExpanded+ / [varname]+headerCollapsed+ facets. Additionally the panel requires content to display when it is expanded. Content is added as child elements like a standard panel.

[[sect-Component_Reference-collapsiblePanel-Expanding_and_collapsing_the_panel]]

==== Expanding and collapsing the panel

The switching mode for performing submissions is determined by the [varname]+switchType+ attribute, which can have one of the following three values:

+server+:: This is the default setting. The [sgmltag]+<rich:collapsiblePanel>+ component performs a common submission, completely refreshing the page. Only one panel at a time is rendered to the client side.
+ajax+:: The [sgmltag]+<rich:collapsiblePanel>+ component performs an Ajax form submission, and only the content of the panel is refreshed. Only one panel at a time is rendered to the client side.
+client+:: The [sgmltag]+<rich:collapsiblePanel>+ component changes the state on the client side without any additional requests being sent.
[[sect-Component_Reference-collapsiblePanel-Appearance]]

==== Appearance

The appearance of the [sgmltag]+<rich:collapsiblePanel>+ component can be customized using facets. The +headerExpanded+ and +headerCollapsed+ CSS fclasses are used to style the appearance of the panel when it is expanded and collapsed respectively.

[[sect-Component_Reference-collapsiblePanel-collapsiblePanel_server-side_events]]

==== [sgmltag]+<rich:collapsiblePanel>+ server-side events

The [sgmltag]+<rich:collapsiblePanel>+ component uses the following unique server-side events:

* The [varname]+PanelToggleEvent+ event occurs on the server side when the [sgmltag]+<rich:collapsiblePanel>+ component is expanded or collapsed in either the +ajax+ or +server+ modes. It can be processed using the [varname]+panelTogglerListener+ attribute.


[[sect-Component_Reference-collapsiblePanel-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:collapsiblePanel>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+switchPanel()+:: Switch the state of the collapsible panel (expanded or collapsed).
[function]+expand()+:: Expand this collapsible panel.
[function]+collapse()+:: Collapse this collapsible panel.
[function]+isExpanded()+:: Returns +true+ if this collapsible panel is expanded.
[[sect-Component_Reference-collapsiblePanel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.CollapsiblePanel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICollapsiblePanel+
* [parameter]+component-family+: [classname]+org.richfaces.CollapsiblePanel+
* [parameter]+renderer-type+: [classname]+org.richfaces.CollapsiblePanelRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.CollapsiblePanelTagHandler+


[[sect-Component_Reference-collapsiblePanel-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/collapsiblePanel.asciidoc[]

[[sect-Component_Reference-Panels-panelToggleListener]]

==== [sgmltag]+<rich:panelToggleListener>+

Use the [sgmltag]+<rich:panelToggleListener>+ tag to register a [classname]+PanelToggleListener+ class on a parent [sgmltag]+<rich:collapsiblePanel>+ component. The class provided as a listener must implement the [interfacename]+org.richfaces.event.PanelToggleListener+ interface. The [methodname]+processPanelToggle+ method accepts an [classname]+org.richface.event.PanelToggleEvent+ event as a parameter.

[[sect-Component_Reference-Panels-popupPanel]]

=== [sgmltag]+<rich:popupPanel>+

The [sgmltag]+<rich:popupPanel>+ component provides a pop-up panel or window that appears in front of the rest of the application. The [sgmltag]+<rich:popupPanel>+ component functions either as a modal window which blocks interaction with the rest of the application while active, or as a non-modal window. It can be positioned on the screen, dragged to a new position by the user, and re-sized.

[[sect-Component_Reference-popupPanel-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:popupPanel>+ does not require any compulsory attributes, though certain use cases require different attributes.

[[sect-Component_Reference-popupPanel-Showing_and_hiding_the_pop-up]]

==== Showing and hiding the pop-up

If [code]+show="true"+ then the pop-up panel will display when the page is first loaded.

The [sgmltag]+<rich:popupPanel>+ component can be shown and hidden manually using the [code]+show()+ and [code]+hide()+ methods from the JavaScript API. These can be implemented using two different approaches:

* Using the [sgmltag]+<rich:componentControl>+ component. For details on the component, refer to <<sect-Component_Reference-Functionality_extension-componentControl>>.
* Using the [code]+rich:component+ function. For details on the function, refer to <<sect-Component_Reference-Functions-component>>.


For explicit referencing when using the functions, the component can be given an [varname]+id+ identifier.

<<exam-Component_Reference-popupPanel-popupPanel_example>> demonstrates basic use of both the [sgmltag]+<rich:componentControl>+ component and the [code]+rich:component+ function to show and hide the [sgmltag]+<rich:popupPanel>+ component.

[[exam-Component_Reference-popupPanel-popupPanel_example]]

.[sgmltag]+<rich:popupPanel>+ example
====


[source, XML]
----
<h:commandButton value="Show the panel">
    <rich:componentControl target="popup" operation="show" />
</h:commandButton>
...
<rich:popupPanel id="popup">
    <p><a href="#" onclick="#{rich:component('popup')}.hide()">Hide the panel</a></p>
</rich:popupPanel>
----

====

[IMPORTANT]
.Placement
====
The [sgmltag]+<rich:popupPanel>+ component is usually rendered in front of any other objects on the page. This is achieved by attaching the component to the [sgmltag]+<body>+ element of the page, and setting a very high _"z-index"_ (the stack order of the object). This approach is taken because relatively-positioned elements could still overlap the pop-up panel if they exist at higher levels of the [acronym]#DOM# hierarchy, even if their z-index is less than the [sgmltag]+<rich:popupPanel>+ component.

If the [sgmltag]+<rich:popupPanel>+ is to participate in submitting child components/behaviors, then a form element must be nested within the [sgmltag]+<rich:popupPanel>+. Alternatively, if no overlapping elements exist, the [sgmltag]+<rich:popupPanel>+ component can be reattached to its original [acronym]#DOM# element by setting [varname]+domElementAttachment+ to either +parent+ or +form+.
====

[[sect-Component_Reference-popupPanel-Modal_and_non-modal_panels]]

==== Modal and non-modal panels

By default, the [sgmltag]+<rich:popupPanel>+ appears as a modal window that blocks interaction with the other objects on the page. To implement a non-modal window instead, set [code]+modal="false"+. This will allow interaction with other objects outside the pop-up panel.

[[sect-Component_Reference-popupPanel-Size_and_positioning]]

==== Size and positioning

The pop-up panel can be both re-sized and re-positioned by the user. The minimum possible size for the panel can be set with the [varname]+minWith+ and [varname]+minHeight+ attributes. These abilities can be deactivated by setting [code]+resizable+ or [code]+movable+ to +false+ as necessary.

The pop-up panel can be automatically sized when it is shown if the [varname]+autosized+ attribute is set to +true+.

[NOTE]
.Embedded objects in the panel
====
Embedded objects inserted into the [acronym]#HTML# with the [sgmltag]+<embed>+ tag could be rendered in front of a [sgmltag]+<rich:popupPanel>+ component in some browsers. The [sgmltag]+<rich:popupPanel>+ component can be forcibly rendered in front of these objects by setting [code]+overlapEmbedObjects="true"+.

However, due to the additional script processing required when using the [varname]+overlapEmbedObjects+ attribute, applications can suffer from decreased performance. As such, [varname]+overlapEmbedObjects+ should only be set to +true+ when [sgmltag]+<embed>+ or [sgmltag]+<object>+ tags are being used in the parent view. Do not set it to +true+ for applications that do not require it.
====

[[sect-Component_Reference-popupPanel-Header_and_controls]]

==== Header and controls

A panel header and associated controls can be added to the [sgmltag]+<rich:popupPanel>+ component through the use of facets. The +header+ facet displays a title for the panel, and the +controls+ facet can be customized to allow window controls such as a button for closing the pop-up. <<exam-Component_Reference-popupPanel-Header_and_controls>> demonstrates the use of the facets.

[[exam-Component_Reference-popupPanel-Header_and_controls]]

.Header and controls
====


[source, XML]
----
<h:commandLink value="Show pop-up">
    <rich:componentControl target="popup" operation="show" />
</h:commandLink>
...
<rich:popupPanel id="popup" modal="false" autosized="true" resizeable="false">
    <f:facet name="header">
        <h:outputText value="The title of the panel" />
    </f:facet>
    <f:facet name="controls">
        <h:graphicImage value="/pages/close.png" style="cursor:pointer" onclick="#{rich:component('popup')}.hide()" />
    </f:facet>
    <p>
        This is the content of the panel.
    </p>
</rich:popupPanel>

----

[quote]
____

[[figu-Component_Reference-popupPanel-Header_and_controls]]
.Header and controls
image::figu-Component_Reference-popupPanel-Header_and_controls.png[]
____

====

[[sect-Component_Reference-popupPanel-Contents_of_the_pop-up]]

==== Contents of the pop-up

The [sgmltag]+<rich:popupPanel>+ component can contain any other component just like a normal panel.

Contents of the [sgmltag]+<rich:popupPanel>+ component which are positioned relatively may be trimmed if they extend beyond the borders of the pop-up panel. For certain in-line controls this behavior may be preferable, but for other dynamic controls it could be undesirable. If the [varname]+trimOverlayedElements+ attribute is set to +false+ then child components will not be trimmed if they extend beyond the borders of the pop-up panel. For example, if using a calendar, select, or other pop-up component, set [code]+trimOverlayedElements="false"+.

[[sect-Component_Reference-popupPanel-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:popupPanel>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getTop()+:: Return the top co-ordinate for the position of the pop-up panel.
[function]+getLeft()+:: Return the left co-ordinate for the position of the pop-up panel.
[function]+moveTo(top,left)+:: Move the pop-up panel to the co-ordinates specified with the [parameter]+top+ and [parameter]+left+ parameters.
[function]+resize(width,height)+:: Resize the pop-up panel to the size specified with the [parameter]+width+ and [parameter]+height+ parameters.
[function]+show()+:: Show the pop-up panel.
[function]+hide()+:: Hide the pop-up panel.
[[sect-Component_Reference-popupPanel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.PopupPanel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPopupPanel+
* [parameter]+component-family+: [classname]+org.richfaces.PopupPanel+
* [parameter]+renderer-type+: [classname]+org.richfaces.PopupPanelRenderer+


[[sect-Component_Reference-popupPanel-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/popupPanel.asciidoc[]

[[sect-Component_Reference-Panels-tabPanel]]

=== [sgmltag]+<rich:tabPanel>+

The [sgmltag]+<rich:tabPanel>+ component provides a set of tabbed panels for displaying one panel of content at a time. The tabs can be highly customized and themed. Each tab within a [sgmltag]+<rich:tabPanel>+ container is a [sgmltag]+<rich:tab>+ component. Refer to <<sect-Component_Reference-Panels-tab>> for further details on the [sgmltag]+<rich:tab>+ component.

[[figu-Component_Reference-tabPanel-tabPanel_component]]
.A [sgmltag]+<rich:tabPanel>+ component containing three [sgmltag]+<rich:tab>+ components
image::figu-Component_Reference-tabPanel-tabPanel_component.png[]


[NOTE]
.Form elements required
====
All [sgmltag]+<rich:tabPanel>+ components should be wrapped in a form element when using either +ajax+ or +server+ mode, as usual for submitting components.
====

[[sect-Component_Reference-tabPanel-Switching_tabs]]

==== Switching panels

The [code]+activeItem+ attribute holds the active tab name. This name is a reference to the [varname]+name+ identifier of the active child [sgmltag]+<rich:tab>+ component.

The switching mode for performing submissions is determined by the [code]+switchType+ attribute, which can have one of the following three values:

+server+:: The default setting. Activation of a [sgmltag]+<rich:tab>+ component causes the parent [sgmltag]+<rich:tabPanel>+ component to perform a common submission, completely refreshing the page. Only one tab at a time is rendered to the client side.
+ajax+:: Activation of a [sgmltag]+<rich:tab>+ component causes the parent [sgmltag]+<rich:tabPanel>+ component to perform an Ajax form submission, and the content of the tab panel is refreshed. Only one tab at a time is rendered to the client side.
+client+:: Activation of a [sgmltag]+<rich:tab>+ component causes the parent [sgmltag]+<rich:tabPanel>+ component to update on the client side. All the tabs are rendered to the client during the initial page render. JavaScript changes the styles such that one tab becomes hidden while the other is shown.
[[sect-Component_Reference-tabPanel-tabPanel_client-side_events]]

==== [sgmltag]+<rich:tabPanel>+ client-side events

In addition to the standard Ajax events and HTML events, the [sgmltag]+<rich:tabPanel>+ component uses the client-side events common to all switchable panels:

* The [varname]+itemchange+ event points to the function to perform when the switchable item is changed.
* The [varname]+beforeitemchange+ event points to the function to perform when before the switchable item is changed.


[[sect-Component_Reference-tabPanel-tabPanel_server-side_events]]

==== [sgmltag]+<rich:tabPanel>+ server-side events

The [sgmltag]+<rich:tabPanel>+ component uses the server-side events common to all switchable panels:

* The [varname]+ItemChangeEvent+ event occurs on the server side when an item is changed through Ajax using the +server+ mode. It can be processed using the [varname]+ItemChangeListener+ attribute. Refer to <<sect-Component_Reference-Panels-itemChangeListener>> for details on the [sgmltag]+<rich:itemChangeListener>+ tag.


[[sect-Component_Reference-tabPanel-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:tabPanel>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions, which are common to all switchable panels:

[function]+getItems()+:: Return an array of the tabs contained in the tab panel.
[function]+getItemsNames()+:: Return an array of the names of the tabs contained in the tab panel.
[function]+switchToItem(itemName)+:: Switch to and display the item identified by the [parameter]+itemName+ string passed as a parameter.
[function]+firstItem()+, [function]+prevItem()+, [function]+nextItem()+, [function]+lastItem()+:: Get the name of the first item, the previous item, the next item, or the last item.
[[sect-Component_Reference-tabPanel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.TabPanel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITabPanel+
* [parameter]+component-family+: [classname]+org.richfaces.TabPanel+
* [parameter]+renderer-type+: [classname]+org.richfaces.TabPanelRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.TogglePanelTagHandler+


[[sect-Component_Reference-tabPanel-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/tabPanel.asciidoc[]

[[sect-Component_Reference-Panels-tab]]

==== [sgmltag]+<rich:tab>+

The [sgmltag]+<rich:tab>+ component represents an individual tab inside a [sgmltag]+<rich:tabPanel>+ component, including the tab's content. Clicking on the tab header will bring its corresponding content to the front of other tabs.

[[sect-Component_Reference-tab-Basic_usage]]

===== Basic usage

Basic usage of the [sgmltag]+<rich:tab>+ component requires only the tab header and tab content. No additional attributes are required.

The [varname]+header+ attribute provides the text on the tab header. The content of the tab is then detailed inside the [sgmltag]+<rich:tab>+ tags.

Alternatively, the +header+ facet could be used in place of the [varname]+header+ attribute. This would allow custom components to be applied to the tab header. The component also supports three facets to customize the appearance depending on the current state of the tab:

+headerActive+  facet:: This facet is used when the tab is the currently active tab.
+headerInactive+  facet:: This facet is used when the tab is not currently active.
+headerDisabled+  facet:: This facet is used when the tab is disabled.
The +header+ facet is used in place of any state-based facet that has not been defined.

[[sect-Component_Reference-tab-Switching_tabs]]

===== Switching tabs

The switching mode for performing submissions can be inherited from the [varname]+switchType+ attribute of the parent [sgmltag]+<rich:tabPanel>+ component, or set individually for each [sgmltag]+<rich:tab>+ component. Refer to <<sect-Component_Reference-Panels-tabPanel>> for details on the [varname]+switchType+ attribute.

An individual tab can be disabled by setting [code]+disabled="true"+. Disabled tabs cannot be activated or switched to.

[[sect-Component_Reference-tab-tab_client-side_events]]

===== [sgmltag]+<rich:tab>+ client-side events

In addition to the standard HTML events, the [sgmltag]+<rich:tab>+ component uses the client-side events common to all switchable panel items:

* The [varname]+enter+ event points to the function to perform when the mouse enters the tab.
* The [varname]+leave+ attribute points to the function to perform when the mouse leaves the tab.


[[sect-Component_Reference-tab-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Tab+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITab+
* [parameter]+component-family+: [classname]+org.richfaces.Tab+
* [parameter]+renderer-type+: [classname]+org.richfaces.TabRenderer+


[[sect-Component_Reference-tab-Style_classes_and_skin_parameters]]

===== Style classes and skin parameters

The [sgmltag]+<rich:tab>+ component uses the same styles as those applied to the parent [sgmltag]+<rich:tabPanel>+ component. Refer to <<sect-Component_Reference-tabPanel-Style_classes_and_skin_parameters>> for details.

[[sect-Component_Reference-Panels-togglePanel]]

=== [sgmltag]+<rich:togglePanel>+

The [sgmltag]+<rich:togglePanel>+ component is used as a base for the other switchable components, the [sgmltag]+<rich:accordion>+ component and the [sgmltag]+<rich:tabPanel>+ component. It provides an abstract switchable component without any associated markup. As such, the [sgmltag]+<rich:togglePanel>+ component could be customized to provide a switchable component when neither an accordion component or a tab panel component is appropriate.

The [sgmltag]+<rich:togglePanel>+ component acts as a wrapper for multiple [sgmltag]+<rich:togglePanelItem>+ components. Each child component is displayed after being activated with the [sgmltag]+<rich:toggleControl>+ behavior.

Refer to <<sect-Component_Reference-Panels-toggleControl>> and <<sect-Component_Reference-Panels-togglePanel>> for details on how to use the components together.

[[sect-Component_Reference-togglePanel-Basic_usage]]

==== Basic usage

The initial state of the component can be configured using the [varname]+activeItem+ attribute, which points to a child component to display. Alternatively, if no [varname]+activeItem+ attribute is defined, the initial state will be blank until the user activates a panel component with a connected [sgmltag]+<rich:toggleControl>+ behavior.

The child components are shown in the order in which they are defined in the view, as shown in <<exam-Component_Reference-togglePanel-Basic_usage>>.

[NOTE]
.Form elements required
====
All [sgmltag]+<rich:tabPanel>+ components should be wrapped in a form element when using either +ajax+ or +server+ mode, as usual for submitting components.
====

[[exam-Component_Reference-togglePanel-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:togglePanel id="layout" activeItem="item1">
   <rich:togglePanelItem id="item1">
      <!--content-->
   </rich:togglePanelItem>
   <rich:togglePanelItem id="item2">
      <!--content-->
   </rich:togglePanelItem>
</rich:togglePanel>
<h:commandButton>
   <rich:toggleControl targetPanel="layout"/> <!--cycles through the states-->
</h:commandButton>

----

====

[[sect-Component_Reference-tab-Repeating_panels]]

==== Dynamic panel item generation

All the switchable components ( [sgmltag]+<rich:togglePanel>+, [sgmltag]+<rich:accordion>+ component and the [sgmltag]+<rich:tabPanel>+) can leverage the [sgmltag]+<a4j:repeat>+ tag to dynamically create child components. This can be useful when the definition of the panel items is determined at run-time from a backing bean list.

[[sect-Component_Reference-togglePanel-Toggling_between_panels]]

==== Toggling between components

The switching mode for performing submissions is determined by the [code]+switchType+ attribute, which can have one of the following three values:

+server+:: The default setting. Activation of a child component causes the parent [sgmltag]+<rich:togglePanel>+ component to perform a common submission, completely refreshing the page. Only one child at a time is rendered to the client side.
+ajax+:: Activation of a child component causes the parent [sgmltag]+<rich:togglePanel>+ component to perform an Ajax form submission, and the content of the panel is refreshed. Only one child at a time is rendered to the client side.
+client+:: Activation of a child component causes the parent [sgmltag]+<rich:togglePanel>+ component to update on the client side. All the items are rendered to the client side during the initial page render. JavaScript changes the styles such that one child component becomes hidden while the other is shown.
[[sect-Component_Reference-togglePanel-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:togglePanel>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions, which are common to all switchable panels:

[function]+getItems()+:: Return an array of the items contained in the toggle panel.
[function]+getItemsNames()+:: Return an array of the names of the items contained in the toggle panel.
[function]+switchToItem(itemName)+:: Switch to and display the item identified by the [parameter]+itemName+ string passed as a parameter.
[function]+firstItem()+, [function]+prevItem()+, [function]+nextItem()+, [function]+lastItem()+:: Get the name of the first item, the previous item, the next item, or the last item.
[[sect-Component_Reference-togglePanel-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.TogglePanel+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITogglePanel+
* [parameter]+component-family+: [classname]+org.richfaces.TogglePanel+
* [parameter]+renderer-type+: [classname]+org.richfaces.TogglePanelRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.TogglePanelTagHandler+


[[sect-Component_Reference-Panels-itemChangeListener]]

==== [sgmltag]+<rich:itemChangeListener>+

Use the [sgmltag]+<rich:itemChangeListener>+ tag to register an [classname]+ItemChangeListener+ class on a parent panel component. The class provided as a listener must implement the [interfacename]+org.richfaces.event.ItemChangeListener+ interface. The [methodname]+processItemChange+ method accepts an [classname]+org.richface.event.ItemChangeEvent+ event as a parameter.

The [sgmltag]+<rich:itemChangeListener>+ tag can be used with any of the switchable panel components:

* [sgmltag]+<rich:togglePanel>+ (refer to <<sect-Component_Reference-Panels-togglePanel>>)
* [sgmltag]+<rich:accordion>+ (refer to <<sect-Component_Reference-Panels-accordion>>)
* [sgmltag]+<rich:tabPanel>+ (refer to <<sect-Component_Reference-Panels-tabPanel>>)
* [sgmltag]+<rich:panelMenu>+ (refer to <<sect-Component_Reference-Menus_and_toolbars-panelMenu>>)


[[sect-Component_Reference-Panels-toggleControl]]

==== [sgmltag]+<rich:toggleControl>+

The [sgmltag]+<rich:toggleControl>+ behavior can be attached to any interface component, whether inside or outside the controlled panel itself. It works with a [sgmltag]+<rich:togglePanel>+ component to switch between different [sgmltag]+<rich:togglePanelItem>+ components. Refer to <<sect-Component_Reference-Panels-togglePanel>> and <<sect-Component_Reference-Panels-togglePanelItem>> for details on how to use the components together.

The [sgmltag]+<rich:toggleControl>+ implements the JSF [classname]+BehaviorHolder+ component, which provides events to attached components and behaviors.

[[sect-Component_Reference-toggleControl-Basic_usage]]

===== Basic usage

If the [sgmltag]+<rich:toggleControl>+ component is positioned inside a [sgmltag]+<rich:togglePanel>+ component, no panel attachment attributes need to be defined, as the control is assumed to switch through the [sgmltag]+<rich:togglePanelItem>+ components of its parent [sgmltag]+<rich:togglePanel>+ component.

A [sgmltag]+<rich:toggleControl>+ component can be located outside the [sgmltag]+<rich:togglePanel>+ component it needs to switch. Where this is the case, the [sgmltag]+<rich:togglePanel>+ is identified using the [varname]+targetPanel+ attribute.

[[sect-Component_Reference-toggleControl-Specifying_the_next_state]]

===== Specifying the next state

The [sgmltag]+<rich:toggleControl>+ component can switch the attached [sgmltag]+<rich:togglePanel>+ component in multiple ways:

* By default, the [sgmltag]+<rich:toggleControl>+ component will cycle through [sgmltag]+<rich:togglePanelItem>+ components in the order they are defined within the view.
[[exam-Component_Reference-toggleControl-Default_switching]]

.Default switching
====


[source, XML]
----
<rich:togglePanel id="layout">
   <rich:togglePanelItem>
      <!--content-->
   </rich:togglePanelItem>
   <rich:togglePanelItem>
      <!--content-->
   <rich:togglePanelItem>
</rich:togglePanel>
<h:commandButton>
   <rich:toggleControl targetPanel="layout"/> <!--cycles through the states-->
</h:commandButton>

----

====

* The next item to switch to can be explicitly defined by including a [sgmltag]+<rich:toggleControl>+ component within a [sgmltag]+<rich:togglePanelItem>+ component. Point the [varname]+targetItem+ to the [sgmltag]+<rich:togglePanelItem>+ to switch to when the state is next changed.
[[exam-Component_Reference-toggleControl-Explicit_switching]]

.Explicit switching
====


[source, XML]
----
<rich:togglePanel activeItem="item1">
   <rich:togglePanelItem id="item1">
      <!--content-->
      <h:commandButton>
         <rich:toggleControl targetItem="item2"> <!--switches to item2 -->
      </h:commandButton>
   </rich:togglePanelItem>
   <rich:togglePanelItem id="item2">
      <!--content-->
      <h:commandButton>
         <rich:toggleControl targetItem="item1"> <!--switches to item1 -->
      </h:commandButton>
   <rich:togglePanelItem>
</rich:togglePanel>

----

====

* Alternatively, use the [varname]+targetItem+ attribute with keywords to switch items. The +@first+, +@prev+, +@next+, and +@last+ keywords switch to the first item, the previous item, the next item, and the last item respectively.
[[exam-Component_Reference-toggleControl-Keyword-based_switching]]

.Keyword-based switching
====


[source, XML]
----
<rich:togglePanel activeItem="item1">
   <rich:togglePanelItem id="item1">
      <!--content-->
      <h:commandButton>
         <rich:toggleControl targetItem="@next"> <!--switches to next item (item2)-->
      </h:commandButton>
   </rich:togglePanelItem>
   <rich:togglePanelItem id="item2">
      <!--content-->
      <h:commandButton>
         <rich:toggleControl targetItem="@prev"> <!--switches to previous item (item1)-->
      </h:commandButton>
   <rich:togglePanelItem>
</rich:togglePanel>

----

====



[[sect-Component_Reference-toggleControl-Reference_data]]

===== Reference data

* [parameter]+client-behavior-renderer-type+: [classname]+org.richfaces.component.behavior.ToggleControl+
* [parameter]+behavior-id+: [classname]+org.richfaces.component.behavior.ToggleControl+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.CustomBehaviorHandler+
* [parameter]+behavior-class+: [classname]+org.richfaces.component.behavior.ToggleControl+
* [parameter]+client-behavior-renderer-class+: [classname]+org.richfaces.renderkit.html.ToggleControlRenderer+


[[sect-Component_Reference-Panels-togglePanelItem]]

==== [sgmltag]+<rich:togglePanelItem>+

The [sgmltag]+<rich:togglePanelItem>+ component is a switchable panel for use with the [sgmltag]+<rich:togglePanel>+ component. Use the [sgmltag]+<rich:togglePanelItem>+ component to define the content for a panel using nested components. Switching between [sgmltag]+<rich:togglePanelItem>+ components is handled by the [sgmltag]+<rich:toggleControl>+ behavior.

[[sect-Component_Reference-togglePanelItem-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.TogglePanelItem+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITogglePanelItem+
* [parameter]+component-family+: [classname]+org.richfaces.TogglePanelItem+
* [parameter]+renderer-type+: [classname]+org.richfaces.TogglePanelItemRenderer+


[[chap-Component_Reference-Tables_and_grids]]

== Tables and grids

This chapter covers all components related to the display of tables and grids.

[[sect-Component_Reference-Actions-repeat]]

=== [sgmltag]+<a4j:repeat>+

The non-visual [sgmltag]+<a4j:repeat>+ component is used to iterate through a data model. The component renders child content for every iteration according to the current object data.

The [sgmltag]+<a4j:repeat>+ component extends the standard [classname]+UIRepeat+ component to allow partial updates within iterations while sending Ajax requests. The component acts as a base for all the data iteration components detailed in this chapter.

[[sect-Component_Reference-repeat-Basic_usage]]

==== Basic usage

The contents of the collection are determined using Expression Language ( [acronym]#EL#). The data model for the contents is specified with the [varname]+value+ attribute. The [varname]+var+ attribute names the object to use when iterating through the collection. This object is then referenced in the relevant child components. <<exam-Component_Reference-repeat-repeat_example>> shows how to use [sgmltag]+<a4j:repeat>+ to maintain a simple table.

[[exam-Component_Reference-repeat-repeat_example]]

.[sgmltag]+<a4j:repeat>+ example
====


[source, XML]
----
<table>
    <tbody>
        <a4j:repeat value="#{repeatBean.items}" var="item">
            <tr>
                <td><h:outputText value="#{item.code}" id="item1" /></td>
                <td><h:outputText value="#{item.price}" id="item2" /></td>
            </tr>
        </a4j:repeat>
    </tbody>
</table>

----

Each row of a table contains two cells: one showing the item code, and the other showing the item price. The table is generated by iterating through items in the [code]+repeatBeans.items+ data model.

====

[[sect-Component_Reference-repeat-Limited_views_and_partial_updates]]

==== Limited views and partial updates

The [sgmltag]+<a4j:repeat>+ component uses other attributes common to iteration components, such as the [varname]+first+ attribute for specifying the first item for iteration, and the [varname]+rows+ attribute for specifying the number of rows of items to display.

Specific cells, rows, and columns can be updated without sending Ajax requests for the entire collection. Components that cause the change can specify which part of the table to update through the [varname]+render+ attribute. The [varname]+render+ attribute specifies which part of a table to update. The updated parts relate to where the action component is placed relative to the table:

Action components inside the table:: Use [code]+render=componentID+ where the component identified by _++componentID++_ is in the same row as the action component. The action component updates the single specified component, as demonstrated in <<exam-Component_Reference-repeat-Update_a_single_component>>.
[[exam-Component_Reference-repeat-Update_a_single_component]]

.Update a single component
====


[source, XML]
----
<rich:column>
   <a4j:commandButton render="col"></a4j:commandButton>
</rich:column>
<rich:column>
   <h:outputText value="#{car.model}" id="col"/>
</rich:column>

----

====

Action components outside the table:: Use [code]+render=tableId:rowId:cellId+ to specify the cell to update. The action component updates the cell with an identifier of _++cellId++_, which is within the row with an identifier of _++rowId++_, which is within the table with an identifier of _++tableId++_.

Instead of a specific identifier, any of the references could be variables, as demonstrated in <<exam-Component_Reference-repeat-Use_variables_to_specify_references>>.

[[exam-Component_Reference-repeat-Use_variables_to_specify_references]]
.Use variables to specify references
====

[source, XML]
----
render=tableId:@rows(bean.rowToUpdate):cellId
----

The @rows function accepts a collection of row keys to be updated.  Similarly the table@body shorthand can be used to specify that the entire table body should be updated.

====

[[sect-Component_Reference-repeat-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Repeat+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIRepeat+
* [parameter]+component-family+: [classname]+javax.faces.Data+
* [parameter]+renderer-type+: [classname]+org.richfaces.RepeatRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.html.RepeatHandler+


[[sect-Component_Reference-Tables_and_grids-dataTable]]

=== [sgmltag]+<rich:dataTable>+

The [sgmltag]+<rich:dataTable>+ component is used to render a table, including the table's caption. It works in conjunction with the [sgmltag]+<rich:column>+ and [sgmltag]+<rich:columnGroup>+ components to list the contents of a data model.

[NOTE]
.[sgmltag]+<rich:extendedDataTable>+
====
The [sgmltag]+<rich:dataTable>+ component does not include extended table features, such as data scrolling (including lazy Ajax loading), row selection, and column reordering. These features are available as part of the [sgmltag]+<rich:extendedDataTable>+ component; refer to <<sect-Component_Reference-Tables_and_grids-extendedDataTable>> for further details.
====

[[sect-Component_Reference-dataTable-Basic_usage]]

==== Basic usage

The [varname]+value+ attribute points to the data model, and the [varname]+var+ attribute specifies a variable to use when iterating through the data model.

In addition, the table requires a set of [sgmltag]+<rich:column>+ components to define the content of the table.

[[sect-Component_Reference-dataTable-Customizing_the_table]]

==== Customizing the table

The [varname]+first+ attribute specifies which item in the data model to start from, and the [varname]+rows+ attribute specifies the number of items to list. The +header+, +footer+, and +caption+ facets can be used to display text, and to customize the appearance of the table through skinning. demonstrates a simple table implementation.

The [varname]+keepSaved+ attribute defines whether this iteration component will reset saved children's state before rendering. By default, the state is reset if there are no faces messages with severity error or higher.

[[exam-Component_Reference-dataTable-dataTable_example]]

.[sgmltag]+<rich:dataTable>+ example
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" rows="5">
    <f:facet name="caption">
        <h:outputText value="United States Capitals" />
    </f:facet>
    <f:facet name="header">
        <h:outputText value="Capitals and States Table" />
    </f:facet>
    <rich:column>
        <f:facet name="header">State Flag</f:facet>
            <h:graphicImage value="#{cap.stateFlag}"/>
        <f:facet name="footer">State Flag</f:facet>
    </rich:column>
    <rich:column>
        <f:facet name="header">State Name</f:facet>
            <h:outputText value="#{cap.state}"/>
        <f:facet name="footer">State Name</f:facet>
    </rich:column>
    <rich:column >
        <f:facet name="header">State Capital</f:facet>
            <h:outputText value="#{cap.name}"/>
        <f:facet name="footer">State Capital</f:facet>
    </rich:column>
    <rich:column>
        <f:facet name="header">Time Zone</f:facet>
            <h:outputText value="#{cap.timeZone}"/>
        <f:facet name="footer">Time Zone</f:facet>
    </rich:column>
    <f:facet name="footer">
        <h:outputText value="Capitals and States Table" />
    </f:facet>
</rich:dataTable>


----

[quote]
____

[[figu-Component_Reference-dataTable_example-dataTable_example]]
.[sgmltag]+<rich:dataTable>+ example
image::figu-Component_Reference-dataTable_example.png[]
____

====

For details on filtering and sorting data tables, refer to <<sect-Component_Reference-Tables_and_grids-Table_filtering>> and <<sect-Component_Reference-Tables_and_grids-Table_sorting>>.

[[sect-Component_Reference-dataTable-Partial_updates]]

==== Partial updates

As [sgmltag]+<rich:dataTable>+ the component is based on the [sgmltag]+<a4j:repeat>+ component, it can be partially updated with Ajax. Refer to <<sect-Component_Reference-repeat-Limited_views_and_partial_updates>> for details on partially updating the [sgmltag]+<rich:dataTable>+ component.

The [sgmltag]+<rich:dataTable>+ component supports master-detail markup with collapsible sub-table sections. Refer to <<sect-Component_Reference-Tables_and_grids-collapsibleSubTable>> for full details on using the [sgmltag]+<rich:collapsibleSubTable>+ component.

Use the [varname]+rows+ attribute to specify the number of rows to show at a time. The table is then presented in pages of rows. Pages can be navigated by using a control such as the [sgmltag]+<rich:dataScroller>+ component. Refer to <<sect-Component_Reference-Tables_and_grids-dataScroller>> for full details on using the [sgmltag]+<rich:dataScroller>+ component.

[[sect-Component_Reference-dataTable-JavaScript_API]]

===== Meta-components

The DataTable supports a number of meta-component ids that can be used as a shorthand for specifying execute and render targets.  The following meta-components IDs are supported with the DataTable:

+@scroll+:: The scrollable part of the table
+@header+:: The table header
+@footer+:: The table footer
+@body+:: The table body

==== JavaScript API

The [sgmltag]+<rich:dataTable>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+expandAllSubTables()+:: Expand any sub-tables contained in the data table.
[function]+collapseAllSubTables()+:: Collapse any sub-tables contained in the data table.
[function]+switchSubTable(subtableId)+:: Switch the expanded or collapsed state of any sub-tables contained in the data table.
[function]+filter(columnId, newFilterValue, [isClearPreviousFilters])+:: Filter the table based on the column specified with the [parameter]+columnId+ parameter. Use the [parameter]+newFilterValue+ parameter as the filter value. The optional [parameter]+isClearPreviousFilters+ parameter is a boolean value which, if set to +true+, will clear any previous filters applied to the table.
[function]+sort(columnId, [direction], [isClearPreviousSorting])+:: Sort the table based on the column specified with the [parameter]+columnId+ parameter. The option [parameter]+direction+ parameter specifies whether to sort in ascending or descending order. The optional [parameter]+isClearPreviousSorting+ parameter is a boolean value which, if set to +true+, will clear any previous sorting applied to the table.
[[sect-Component_Reference-dataTable-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DataTable+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDataTable+
* [parameter]+component-family+: [classname]+org.richfaces.Data+
* [parameter]+renderer-type+: [classname]+org.richfaces.DataTableRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.DataTableHandler+


[[sect-Component_Reference-dataTable-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/dataTable.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-column]]

=== [sgmltag]+<rich:column>+

The [sgmltag]+<rich:column>+ component facilitates columns in a table. It supports merging columns and rows, sorting, filtering, and customized skinning.

[[sect-Component_Reference-column-Basic_usage]]

==== Basic usage

In general usage, the [sgmltag]+<rich:column>+ component is used in the same was as the JavaServer Faces ( [acronym]#JSF#) [sgmltag]+<h:column>+ component. It requires no extra attributes for basic usage, as shown in <<exam-Component_Reference-column-Basic_column_example>>.

[[exam-Component_Reference-column-Basic_column_example]]

.Basic column example
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" rows="5">
    <rich:column>
        <f:facet name="header">State Flag</f:facet>
        <h:graphicImage value="#{cap.stateFlag}"/>
    </rich:column>
    <rich:column>
        <f:facet name="header">State Name</f:facet>
        <h:outputText value="#{cap.state}"/>
    </rich:column>
    <rich:column >
        <f:facet name="header">State Capital</f:facet>
        <h:outputText value="#{cap.name}"/>
    </rich:column>
    <rich:column>
        <f:facet name="header">Time Zone</f:facet>
        <h:outputText value="#{cap.timeZone}"/>
    </rich:column>
</rich:dataTable>

----

[quote]
____

[[figu-Component_Reference-Basic_column_example-Basic_column_example]]
.Basic column example
image::figu-Component_Reference-column-Basic_column_example.png[]
____

====

[[sect-Component_Reference-column-Spanning_columns]]

==== Spanning columns

Columns can be merged by using the [varname]+colspan+ attribute to specify how many normal columns to span. The [varname]+colspan+ attribute is used in conjunction with the [varname]+breakRowBefore+ attribute on the next column to determine how the merged columns are laid out. <<exam-Component_Reference-column-Column_spanning_example>>.

[[exam-Component_Reference-column-Column_spanning_example]]

.Column spanning example
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" rows="5">
	<rich:column colspan="3">
        <h:graphicImage value="#{cap.stateFlag}"/>
    </rich:column>
    <rich:column breakBefore="true">
        <h:outputText value="#{cap.state}"/>
    </rich:column>
    <rich:column >
        <h:outputText value="#{cap.name}"/>
    </rich:column>
    <rich:column>
        <h:outputText value="#{cap.timeZone}"/>
    </rich:column>
</rich:dataTable>

----

[quote]
____

[[figu-Component_Reference-Column_spanning_example-Column_spanning_example]]
.Column spanning example
image::figu-Component_Reference-column-Column_spanning_example.png[]
____

====

[[sect-Component_Reference-column-Spanning_rows]]

==== Spanning rows

Similarly, the [varname]+rowspan+ attribute can be used to merge and span rows. Again the [varname]+breakRowBefore+ attribute needs to be used on related [sgmltag]+<rich:column>+ components to define the layout. <<exam-Component_Reference-column-Row_spanning_example>> and the resulting <<figu-Component_Reference-Complex_headers_using_column_groups>> show the first column of the table spanning three rows.

[[exam-Component_Reference-column-Row_spanning_example]]

.Row spanning example
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" rows="5">
    <rich:column rowspan="3">
        <f:facet name="header">State Flag</f:facet>
        <h:graphicImage value="#{cap.stateFlag}"/>
    </rich:column>
    <rich:column>
        <f:facet name="header">State Info</f:facet>
        <h:outputText value="#{cap.state}"/>
    </rich:column>
    <rich:column breakBefore="true">
        <h:outputText value="#{cap.name}"/>
    </rich:column>
    <rich:column breakBefore="true">
        <h:outputText value="#{cap.timeZone}"/>
    </rich:column>
</rich:dataTable>

----

[quote]
____

[[figu-Component_Reference-Row_spanning_example-Row_spanning_example]]
.Row spanning example
image::figu-Component_Reference-column-Row_spanning_example.png[]
____

====

For details on filtering and sorting columns, refer to <<sect-Component_Reference-Tables_and_grids-Table_filtering>> and <<sect-Component_Reference-Tables_and_grids-Table_sorting>>.

[[sect-Component_Reference-column-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Column+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIColumn+
* [parameter]+component-family+: [classname]+org.richfaces.Column+


[[sect-Component_Reference-Tables_and_grids-columnGroup]]

=== [sgmltag]+<rich:columnGroup>+

The [sgmltag]+<rich:columnGroup>+ component combines multiple columns in a single row to organize complex parts of a table. The resulting effect is similar to using the [varname]+breakRowBefore+ attribute of the [sgmltag]+<rich:column>+ component, but is clearer and easier to follow in the source code.

[[sect-Component_Reference-columnGroup-Complex_headers]]

==== Complex headers

The [sgmltag]+<rich:columnGroup>+ can also be used to create complex headers in a table. <<exam-Component_Reference-columnGroup-Complex_headers_using_column_groups>> and the resulting <<figu-Component_Reference-Complex_headers_using_column_groups>> demonstrate how complex headers can be achieved.

[[exam-Component_Reference-columnGroup-Complex_headers_using_column_groups]]

.Complex headers using column groups
====

[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" rows="5" id="sublist">
    <f:facet name="header">
        <rich:columnGroup>
            <rich:column rowspan="2">
                <h:outputText value="State Flag"/>
            </rich:column>
            <rich:column colspan="3">
                <h:outputText value="State Info"/>
            </rich:column>
            <rich:column breakBefore="true">
                <h:outputText value="State Name"/>
            </rich:column>
            <rich:column>
                <h:outputText value="State Capital"/>
            </rich:column>
            <rich:column>
                <h:outputText value="Time Zone"/>
            </rich:column>
        </rich:columnGroup>
    </f:facet>
    <rich:column>
        <h:graphicImage value="#{cap.stateFlag}"/>
    </rich:column>
    <rich:column>
        <h:outputText value="#{cap.state}"/>
    </rich:column>
    <rich:column>
        <h:outputText value="#{cap.name}"/>
    </rich:column>
    <rich:column>
        <h:outputText value="#{cap.timeZone}"/>
    </rich:column>
</rich:dataTable>

----

[quote]
____

[[figu-Component_Reference-Complex_headers_using_column_groups]]
.Complex headers using column groups
image::figu-Component_Reference-columnGroup-Complex_headers_using_column_groups.png[]
____

====

[[sect-Component_Reference-columnGroup-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.ColumnGroup+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIColumnGroup+
* [parameter]+component-family+: [classname]+org.richfaces.ColumnGroup+
* [parameter]+renderer-type+: [classname]+org.richfaces.ColumnGroupRenderer+


[[sect-Component_Reference-Tables_and_grids-collapsibleSubTable]]

=== [sgmltag]+<rich:collapsibleSubTable>+

The [sgmltag]+<rich:collapsibleSubTable>+ component acts as a child element to a [sgmltag]+<rich:dataTable>+ component. The [sgmltag]+<rich:collapsibleSubTable>+ component iterates through the child collections in the currently iterated object to create master-detail tables.

Additionally, the detail part of the table can be collapsed or expanded through different modes. The [sgmltag]+<rich:collapsibleSubTable>+ component works with the [sgmltag]+<rich:collapsibleSubTableToggler>+ component, which expands and collapses the sub-tables.

[[sect-Component_Reference-collapsibleSubTable-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:collapsibleSubTable>+ component requires the same basic attributes as the [sgmltag]+<rich:dataTable>+ component. The [varname]+value+ attribute points to the collection, and the [varname]+var+ attribute specifies a variable to use when iterating through the collection.

In addition, the [sgmltag]+<rich:collapsibleSubTable>+ component typically needs a corresponding [sgmltag]+<rich:collapsibleSubTableToggler>+ component to allow expanding and collapsing. Declare the [varname]+id+ identifier on the [sgmltag]+<rich:collapsibleSubTable>+ element so that the [sgmltag]+<rich:collapsibleSubTableToggler>+ component can reference it. Refer to <<sect-Component_Reference-Tables_and_grids-collapsibleSubTableToggler>> for details on the [sgmltag]+<rich:collapsibleSubTableToggler>+ component.

[[exam-Component_Reference-collapsibleSubTable-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:dataTable value="#{carsBean.inventoryVendorLists}" var="list">
   <f:facet name="header">
      <rich:columnGroup>
         <rich:column colspan="6">
            <h:outputText value="Cars marketplace" />
         </rich:column>
         <rich:column breakRowBefore="true">
            <h:outputText value="Model" />
         </rich:column>
         <rich:column>
            <h:outputText value="Price" />
         </rich:column>
         <rich:column>
            <h:outputText value="Mileage" />
         </rich:column>
         <rich:column>
            <h:outputText value="VIN Code" />
         </rich:column>
         <rich:column>
            <h:outputText value="Items stock" />
         </rich:column>
         <rich:column>
            <h:outputText value="Days Live" />
         </rich:column>
      </rich:columnGroup>
   </f:facet>
   <rich:column colspan="6">
      <rich:collapsibleSubTableToggler for="sbtbl" />
      <h:outputText value="#{list.vendor}" />
   </rich:column>
   <rich:collapsibleSubTable value="#{list.vendorItems}" var="item" id="sbtbl"
      expandMode="client">
      <rich:column>
         <h:outputText value="#{item.model}" />
      </rich:column>
      <rich:column>
         <h:outputText value="#{item.price}" />
      </rich:column>
      <rich:column>
         <h:outputText value="#{item.mileage}" />
      </rich:column>
      <rich:column>
         <h:outputText value="#{item.vin}" />
      </rich:column>
      <rich:column>
         <h:outputText value="#{item.stock}" />
      </rich:column>
      <rich:column>
         <h:outputText value="#{item.daysLive}" />
      </rich:column>
      <f:facet name="footer">
         <h:outputText value="Total of #{list.vendor} Cars: #{list.count}" />
      </f:facet>
   </rich:collapsibleSubTable>
</rich:dataTable>

----

The resulting tables contains multiple sub-tables, grouping the list of cars by vendor. Each sub-table can be expanded or collapsed using the toggle with the vendor's name. The screenshot shows all sub-tables collapsed except for the sub-table for Ford cars.

image::figu-Component_Reference-collapsibleSubTable-Basic_usage.png[A data table containing multiple collapsible sub-tables.]

====

[[sect-Component_Reference-collapsibleSubTable-Expanding_and_collapsing_the_sub-table]]

==== Expanding and collapsing the sub-table

Use the boolean [varname]+expanded+ attribute to control the current state of the sub-table.

The switching mode for performing submissions is determined by the [code]+expandMode+ attribute, which can have one of the following three values:

+server+:: The default setting. Expansion of the [sgmltag]+<rich:collapsibleSubTable>+ component performs a common submission, completely re-rendering the page.
+ajax+:: Expansion of the [sgmltag]+<rich:collapsibleSubTable>+ component performs an Ajax form submission, and the content of the data table is rendered.
+client+:: Expansion of the [sgmltag]+<rich:collapsibleSubTable>+ component updates the data table on the client side.
[[sect-Component_Reference-collapsibleSubTable-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.CollapsibleSubTable+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICollapsibleSubTable+
* [parameter]+component-family+: [classname]+org.richfaces.Data+
* [parameter]+renderer-type+: [classname]+org.richfaces.CollapsibleSubTableRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.CollapsibleSubTableHandler+


[[sect-Component_Reference-collapsibleSubTable-Style_classes]]

==== Style classes

include::skinning/collapsibleSubTable.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-collapsibleSubTableToggler]]

==== [sgmltag]+<rich:collapsibleSubTableToggler>+

The [sgmltag]+<rich:collapsibleSubTableToggler>+ component provides a toggle control for the user to expand and collapse sub-tables.

[[sect-Component_Reference-collapsibleSubTableToggler-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:collapsibleSubTableToggler>+ component requires the [varname]+for+ attribute. The [varname]+for+ attribute references the [varname]+id+ identifier of the [sgmltag]+<rich:collapsibleSubTable>+ component to control.

Refer to <<exam-Component_Reference-collapsibleSubTable-Basic_usage>> for an example using the [sgmltag]+<rich:collapsibleSubTable>+ component. In the example, the toggle control is placed in a column that spans the width of the table. Output text next to the toggle control displays the car vendor's name for that sub-table.

[[sect-Component_Reference-collapsibleSubTableToggler-Appearance]]

===== Appearance

The icons and labels of the [sgmltag]+<rich:collapsibleSubTableToggler>+ component can be customized. Use the [varname]+collapsedIcon+ and [varname]+expandedIcon+ attributes to specify icons for the toggler when it is collapsed and expanded respectively. Use the [varname]+collapsedLabel+ and [varname]+expandedLabel+ attributes to specify labels for the toggler when it is collapsed and expanded respectively.

[[sect-Component_Reference-collapsibleSubTableToggler-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.CollapsibleSubTableToggler+
* [parameter]+component-class+: [classname]+org.richfaces.component.UICollapsibleSubTableToggleControl+
* [parameter]+component-family+: [classname]+org.richfaces.CollapsibleSubTableToggler+
* [parameter]+renderer-type+: [classname]+org.richfaces.CollapsibleSubTableTogglerRenderer+


[[sect-Component_Reference-collapsibleSubTableToggler-Style_classes_and_skin_parameters]]

===== Style classes and skin parameters

include::skinning/collapsibleSubTableToggler.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-extendedDataTable]]

=== [sgmltag]+<rich:extendedDataTable>+

The [sgmltag]+<rich:extendedDataTable>+ component builds on the functionality of the [sgmltag]+<rich:dataTable>+ component, adding features such as scrolling for the table body (both horizontal and vertical), Ajax loading for vertical scrolling, frozen columns, row selection, and rearranging of columns. It also supports all the basic table features such as sorting, filtering, and paging using the [sgmltag]+<rich:dataScroller>+ component.

The [sgmltag]+<rich:extendedDataTable>+ component includes the following main attributes not included in the [sgmltag]+<rich:dataTable>+ component:

* [varname]+clientRows+
* [varname]+frozenColumns+
* [varname]+height+
* [varname]+onselectionchange+
* [varname]+selectedClass+
* [varname]+selection+
* [varname]+selectionMode+


[NOTE]
.Complex sub-tables
====
Due to the complex mark-up involved in the [sgmltag]+<rich:extendedDataTable>+ component, it does not support the use of the [sgmltag]+<rich:collapsibleSubTable>+ component. The [sgmltag]+<rich:collapsibleSubTable>+ component is only available with the [sgmltag]+<rich:dataTable>+ component.

Similarly, complex row and column spanning using the [varname]+breakRowBefore+, [varname]+colSpan+, and [varname]+rowSpan+ attributes is also not available with the [sgmltag]+<rich:extendedDataTable>+ component.
====

[[sect-Component_Reference-extendedDataTable-Basic_usage]]

==== Basic usage

Basic use of the [sgmltag]+<rich:extendedDataTable>+ component requires the [varname]+value+ and [varname]+var+ attributes, the same as with the [sgmltag]+<rich:dataTable>+ component. In addition, a set of columns must be included to define the table content. Refer to <<sect-Component_Reference-Tables_and_grids-dataTable>> for details.

[[sect-Component_Reference-extendedDataTable-Table_appearance]]

==== Table appearance

As with the [sgmltag]+<rich:dataTable>+ component, the look of the [sgmltag]+<rich:extendedDataTable>+ component can be customized using the +header+ and +footer+ facets.

[[sect-Component_Reference-extendedDataTable-Extended_features]]

==== Extended features

[[exam-Component_Reference-extendedDataTable-extendedDataTable_example]]

.[sgmltag]+<rich:extendedDataTable>+ example
====

This example [sgmltag]+<rich:extendedDataTable>+ component demonstrates horizontal and vertical scrolling and frozen columns. Each feature is detailed in this section.


[source, XML]
----
<rich:extendedDataTable value="#{carsBean.allInventoryItems}"
                        var="car" id="table" frozenColumns="2"
                        style="height:300px; width:500px;" selectionMode="none">
   <f:facet name="header">
      <h:outputText value="Cars marketplace" />
   </f:facet>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="vendor" />
      </f:facet>
      <h:outputText value="#{car.vendor}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="Model" />
      </f:facet>
      <h:outputText value="#{car.model}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="Price" />
      </f:facet>
      <h:outputText value="#{car.price}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="Mileage" />
      </f:facet>
      <h:outputText value="#{car.mileage}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="VIN Code" />
      </f:facet>
      <h:outputText value="#{car.vin}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="Items stock" />
      </f:facet>
      <h:outputText value="#{car.stock}" />
   </rich:column>
   <rich:column>
      <f:facet name="header">
         <h:outputText value="Days Live" />
      </f:facet>
      <h:outputText value="#{car.daysLive}" />
   </rich:column>
</rich:extendedDataTable>

----

image::figu-Component_Reference-Tables_and_grids-extendedDataTable_example.png[A data table made using the +&lt;rich:extendedDataTable&gt;+ component. It features horizontal and vertical scrolling and frozen columns.]

====

[[sect-Component_Reference-extendedDataTable-Scrolling]]

===== Scrolling

The example table shown in <<exam-Component_Reference-extendedDataTable-extendedDataTable_example>> features both horizontal and vertical scrolling. Scrolling occurs automatically when the contents of the table exceed the dimensions specified with the [varname]+height+ and [varname]+width+ attributes. Headers and footers remain in place and visible when the table is scrolled.

Large tables can use Ajax "lazy" loading to cache data on the client during scrolling. Use the [varname]+clientRows+ attribute to specify the number of rows to load. The specified number of rows are loaded on the initial rendering and with every vertical scroll. If the [varname]+clientRows+ attribute is not specified, all the rows are loaded on the client without the use of Ajax.

In addition to Ajax scrolling, the [sgmltag]+<rich:extendedDataTable>+ component can also be used with the [sgmltag]+<rich:dataScroller>+ component in the same way as a regular [sgmltag]+<rich:dataTable>+ component. If both the [varname]+clientRows+ and [varname]+rows+ attributes are included, Ajax loading occurs as defined by the [varname]+clientRows+ attribute, but the loading is limited to the current table page as determined by the [varname]+rows+ attribute. Refer to <<sect-Component_Reference-Tables_and_grids-dataScroller>> for full details on using the [sgmltag]+<rich:dataScroller>+ component.

[[sect-Component_Reference-extendedDataTable-Frozen_columns]]

===== Frozen columns

The example table shown in <<exam-Component_Reference-extendedDataTable-extendedDataTable_example>> has the first two columns frozen so that they remain visible if the user scrolls horizontally through the table. Note that the horizontal scrollbar does not encompass these frozen columns. To freeze columns, use the [varname]+frozenColumns+ attribute to specify the number of columns on the left-hand side of the table to freeze.

[[sect-Component_Reference-extendedDataTable-Row_selection]]

===== Row selection

Row selection is determined by the [varname]+selectionMode+ attribute. Setting the attribute to +none+ allows for no row selection capability. The example table shown in <<exam-Component_Reference-extendedDataTable-extendedDataTable_example>> does not allow row selection.

Setting the [varname]+selectionMode+ attribute to +single+ allows the user to select a single row at a time using the mouse. With the [varname]+selectionMode+ attribute set to +multiple+, the user can select multiple rows. Holding down the kbd:[Ctrl] key while clicking selects additional rows with each click. Holding down the kbd:[Shift] key while clicking selects all the rows in a range. Using kbd:[Ctrl + A] will result in selecting all the rows throughout the table.

The [varname]+selection+ attribute points to a collection of objects. It holds the [varname]+rowKey+ identifiers to track which rows are selected. <<exam-Component_Reference-extendedDataTable-Selecting_multiple_rows>> shows how to implement multiple row selection in the same table from <<exam-Component_Reference-extendedDataTable-extendedDataTable_example>>.

[[exam-Component_Reference-extendedDataTable-Selecting_multiple_rows]]

.Selecting multiple rows
====


[source, XML]
----
<rich:extendedDataTable value="#{extTableSelectionBean.inventoryItems}"
                        var="car" selection="#{extTableSelectionBean.selection}"
                        id="table" frozenColumns="2"
                        style="height:300px; width:500px;" selectionMode="multiple">
   ...

----

The accompanying [classname]+ExtSelectionBean+ bean handles which rows are selected. The rows are identified by their [varname]+rowKey+ identifiers.


[source, Java]
----
package org.richfaces.demo.tables;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.faces.bean.ManagedBean;
import javax.faces.bean.ManagedProperty;
import javax.faces.bean.SessionScoped;
import javax.faces.event.AjaxBehaviorEvent;

import org.richfaces.component.AbstractExtendedDataTable;
import org.richfaces.demo.tables.model.cars.InventoryItem;

@ManagedBean
@SessionScoped

public class ExtTableSelectionBean implements Serializable{

   private Collection<Object> selection;
   @ManagedProperty(value = "#{carsBean.allInventoryItems}")
   private List<InventoryItem> inventoryItems;
   private List<InventoryItem> selectionItems = new ArrayList<InventoryItem>();

   public void selectionListener(AjaxBehaviorEvent event){
      AbstractExtendedDataTable dataTable = (AbstractExtendedDataTable)event.getComponent();
      Object originalKey = dataTable.getRowKey();
      selectionItems.clear();
      for (Object selectionKey: selection) {
         dataTable.setRowKey(selectionKey);
         if (dataTable.isRowAvailable()){
            selectionItems.add((InventoryItem)dataTable.getRowData());
         }
      }
      dataTable.setRowKey(originalKey);
   }

   public Collection<Object> getSelection() {
      return selection;
   }

   public void setSelection(Collection<Object> selection) {
      this.selection = selection;
   }

   public List<InventoryItem> getInventoryItems() {
      return inventoryItems;
   }

   public void setInventoryItems(List<InventoryItem> inventoryItems) {
      this.inventoryItems = inventoryItems;
   }

   public List<InventoryItem> getSelectionItems() {
      return selectionItems;
   }

   public void setSelectionItems(List<InventoryItem> selectionItems) {
      this.selectionItems = selectionItems;
   }
}

----

image::figu-Component_Reference-Tables_and_grids-Selecting_multiple_rows.png[The example table with the first, second, third, and fifth rows selected.]

====

[[sect-Component_Reference-extendedDataTable-Rearranging_columns]]

===== Rearranging columns

Columns in a [sgmltag]+<rich:extendedDataTable>+ component can be rearranged by the user by dragging each column to a different position. A graphical representation of the column is displayed during dragging. <<figu-Component_Reference-extendedDataTable-Dragging_columns>> illustrates the [guilabel]#Price# column being dragged to a new location. The small blue arrow indicates where the column will be moved to if it is dropped in the current position. <<figu-Component_Reference-extendedDataTable-Rearranged_columns>> shows the result of dragging the [guilabel]#Price# column.

[[figu-Component_Reference-extendedDataTable-Dragging_columns]]
.Dragging columns
image::figu-Component_Reference-Tables_and_grids-Dragging_columns.png[width="444"]


[[figu-Component_Reference-extendedDataTable-Rearranged_columns]]
.Rearranged columns
image::figu-Component_Reference-Tables_and_grids-Rearranged_columns.png[width="444"]


[[sect-Component_Reference-extendedDataTable-State_saving]]

===== State saving

The [varname]+tableState+ attribute of the [sgmltag]+<rich:extendedDataTable>+ component can be used to bind state of the table (column width, sequence, sorting, filtering) to a backing-bean string property, for a later use. This state can be for example saved to a database, and it is different from standard JSF state saving mechanism.

[[sect-Component_Reference-extendedDataTable-Filtering_and_sorting]]

===== Meta-components

The ExtendedDataTable supports a number of meta-component ids that can be used as a shorthand for specifying execute and render targets.  The following meta-components IDs are supported with the ExtendedDataTable:

+@scroll+:: The scrollable part of the table
+@header+:: The table header
+@footer+:: The table footer
+@body+:: The table body

===== Filtering and sorting

The [sgmltag]+<rich:extendedDataTable>+ component can include filtering and sorting in the same way as a regular [sgmltag]+<rich:dataTable>+ component. For full details on filtering tables, refer to <<sect-Component_Reference-Tables_and_grids-Table_filtering>>. For full details on sorting tables, refer to <<sect-Component_Reference-Tables_and_grids-Table_sorting>>.

[[sect-Component_Reference-extendedDataTable-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:extendedDataTable>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+sort()+:: Sort the data table.
[function]+filter()+:: Filter the data table.
[function]+clearSorting()+:: Clear any sorting that is currently applied to the table.
[function]+clearFiltering()+:: Clear any filtering that is currently applied to the table.
[function]+selectRow(index)+:: Select the row specified by the [parameter]+index+ parameter.
[function]+selectRows([startIndex, stopIndex])+:: Select all the rows in the table. Optionally, select only those rows between the indexes specified with the [parameter]+startIndex+ and [parameter]+stopIndex+ parameters.
[function]+deselectRow+:: Deselect the row that is currently selected.
[function]+setActiveRow(index)+:: Set the active row to that specified by the [parameter]+index+ parameter.
[[sect-Component_Reference-extendedDataTable-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.ExtendedDataTable+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIExtendedDataTable+
* [parameter]+component-family+: [classname]+org.richfaces.Data+
* [parameter]+renderer-type+: [classname]+org.richfaces.ExtendedDataTableRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.ExtendedDataTableHandler+


[[sect-Component_Reference-extendedDataTable-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/extendedDataTable.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-dataGrid]]

=== [sgmltag]+<rich:dataGrid>+

The [sgmltag]+<rich:dataGrid>+ component is used to arrange data objects in a grid. Values in the grid can be updated dynamically from the data model, and Ajax updates can be limited to specific rows. The component supports +header+, +footer+, and +caption+ facets.

The [sgmltag]+<rich:dataGrid>+ component is similar in function to the JavaServer Faces [sgmltag]+<h:panelGrid>+ component. However, the [sgmltag]+<rich:dataGrid>+ component additionally allows iteration through the data model rather than just aligning child components in a grid layout.

[[figu-Component_Reference-dataGrid-The_dataGrid_component]]
.The [sgmltag]+<rich:dataGrid>+ component
image::figu-Component_Reference-dataGrid-The_dataGrid_component.png[]


[[sect-Component_Reference-dataGrid-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:dataGrid>+ component requires the [varname]+value+ attribute, which points to the data model, and the [varname]+var+ attribute, which holds the current variable for the collection of data.

[[sect-Component_Reference-dataGrid-Customizing_the_grid]]

==== Customizing the grid

The number of columns for the grid is specifed with the [varname]+columns+ attribute, and the number of elements to layout among the columns is determined with the [varname]+elements+ attribute. The [varname]+first+ attribute references the zero-based element in the data model from which the grid starts.

[[exam-Component_Reference-dataGrid-dataGrid_example]]

.[sgmltag]+<rich:dataGrid>+ example
====


[source, XML]
----
<rich:panel style="width:150px;height:200px;">
  <h:form>
    <rich:dataGrid value="#{dataTableScrollerBean.allCars}" var="car" columns="2" elements="4" first="1">
        <f:facet name="header">
          <h:outputText value="Car Store"></h:outputText>
      </f:facet>
      <rich:panel>
          <f:facet name="header">
            <h:outputText value="#{car.make} #{car.model}"></h:outputText>
          </f:facet>
          <h:panelGrid columns="2">
            <h:outputText value="Price:" styleClass="label"></h:outputText>
            <h:outputText value="#{car.price}"/>
            <h:outputText value="Mileage:" styleClass="label"></h:outputText>
            <h:outputText value="#{car.mileage}"/>
          </h:panelGrid>
      </rich:panel>
      <f:facet name="footer">
          <rich:dataScroller></rich:dataScroller>
      </f:facet>
    </rich:dataGrid>
  </h:form>
</rich:panel>

----

[quote]
____

[[figu-Component_Reference-dataGrid_example-dataGrid_example]]
.[sgmltag]+<rich:dataGrid>+ example
image::figu-Component_Reference-dataGrid-dataGrid_example.png[]

____

====

[[sect-Component_Reference-dataGrid-Patial_updates]]

==== Partial updates

As [sgmltag]+<rich:dataGrid>+ the component is based on the [sgmltag]+<a4j:repeat>+ component, it can be partially updated with Ajax. Refer to <<sect-Component_Reference-repeat-Limited_views_and_partial_updates>> for details on partially updating the [sgmltag]+<rich:dataGrid>+ component.

[[sect-Component_Reference-dataGrid-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DataGrid+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDataGrid+
* [parameter]+component-family+: [classname]+org.richfaces.Data+
* [parameter]+renderer-type+: [classname]+org.richfaces.DataGridRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.DataGridHandler+


[[sect-Component_Reference-dataGrid-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/dataGrid.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-list]]

=== [sgmltag]+<rich:list>+

The [sgmltag]+<rich:list>+ component renders a list of items. The list can be an numerically ordered list, an un-ordered bullet-point list, or a data definition list. The component uses a data model for managing the list items, which can be updated dynamically.

[[sect-Component_Reference-list-Basic_usage]]

==== Basic usage

The [varname]+var+ attribute names a variable for iterating through the items in the data model. The items to iterate through are determined with the [varname]+value+ attribute by using EL (Expression Language).

[[sect-Component_Reference-list-Type_of_list]]

==== Type of list

By default, the list is displayed as an un-ordered bullet-point list. The [varname]+type+ attribute is used to specify different list types:

+unordered+:: The default presentation. The list is presented as a series of bullet-points, similar to the [sgmltag]+<ul>+ HTML element.

[[figu-Component_Reference-list-Unordered_list]]
.Unordered list
image::figu-Component_Reference-list-Unordered_list.png[]


+ordered+:: The list is presented as a numbered series of items, similar to the [sgmltag]+<ol>+ HTML element.

[[figu-Component_Reference-list-Ordered_list]]
.Ordered list
image::figu-Component_Reference-list-Ordered_list.png[]


+definitions+:: The list is presented as a series of data definitions. Part of the data model, specified as the term, is listed prominently. The other associated data is listed after each term.

[[figu-Component_Reference-list-Data_definition_list]]
.Data definition list
image::figu-Component_Reference-list-Data_definition_list.png[]


The term is marked using the +term+ facet. The facet is required for all definition lists. Use of the facet is shown in <<exam-Component_Reference-list-Data_definition_list>>.
[[exam-Component_Reference-list-Data_definition_list]]

.Data definition list
====


[source, XML]
----
<h:form>
    <rich:list var="car" value="#{dataTableScrollerBean.allCars}" type="definitions" rows="5" title="Cars">
        <f:facet name="term">
            <h:outputText value="#{car.make} #{car.model}"></h:outputText>
        </f:facet>
        <h:outputText value="Price:" styleClass="label"></h:outputText>
        <h:outputText value="#{car.price}" /><br/>
        <h:outputText value="Mileage:" styleClass="label"></h:outputText>
        <h:outputText value="#{car.mileage}" /><br/>
    </rich:list>
</h:form>

----

====

[[sect-Component_Reference-list-Bullet_and_numeration_appearance]]

==== Bullet and numeration appearance

The appearance of bullet points for unordered lists or numeration for ordered lists can be customized through CSS, using the [property]+list-style-type+ property.

[[sect-Component_Reference-list-Customizing_the_list]]

==== Customizing the list

The [varname]+first+ attribute specifies which item in the data model to start from, and the [varname]+rows+ attribute specifies the number of items to list. The [varname]+title+ attribute is used for a floating tool-tip. <<exam-Component_Reference-list-list_example>> shows a simple example using the [sgmltag]+<rich:list>+ component.

[[exam-Component_Reference-list-list_example]]

.[sgmltag]+<rich:list>+ example
====


[source, XML]
----
<h:form>
    <rich:list var="car" value="#{dataTableScrollerBean.allCars}" rows="5" type="unordered" title="Car Store">
        <h:outputText value="#{car.make} #{car.model}"/><br/>
        <h:outputText value="Price:" styleClass="label"></h:outputText>
        <h:outputText value="#{car.price} "/><br/>
        <h:outputText value="Mileage:" styleClass="label"></h:outputText>
        <h:outputText value="#{car.mileage} "/><br/>
    </rich:list>
</h:form>

----

[quote]
____

[[figu-Component_Reference-list-list_example]]
.[sgmltag]+<rich:list>+ example
image::figu-Component_Reference-list-Unordered_list.png[]
____

====

[[sect-Component_Reference-list-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.List+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIList+
* [parameter]+component-family+: [classname]+org.richfaces.List+
* [parameter]+renderer-type+: [classname]+org.richfaces.ListRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.ListHandler+


[[sect-Component_Reference-list-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/list.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-dataScroller]]

=== [sgmltag]+<rich:dataScroller>+

The [sgmltag]+<rich:dataScroller>+ component is used for navigating through multiple pages of tables or grids.

[[figu-Component_Reference-dataScroller-The_dataScroller_component]]
.The [sgmltag]+<rich:dataScroller>+ component
image::figu-Component_Reference-dataScroller-The_dataScroller_component.png[]


[[sect-Component_Reference-dataScroller-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:dataScroller>+ must be placed in a facet of the table or grid it needs to control. Alternatively, use the [varname]+for+ attribute to bind the parent table or grid to the scroller.

The bound table or grid should also have the [varname]+rows+ attribute defined to limit the number of rows per page.

The [sgmltag]+<rich:dataScroller>+ component must be re-rendered whenever a filter changes on the bound table, so that the scroller matches the current model for the table.

[[exam-Component_Reference-dataScroller-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:dataTable id="table" value="#{capitalsBean.capitals}" var="cap" rows="5">
   <!-- table content -->
   ...
</rich:dataTable>
<rich:dataScroller for="table" maxPages="5">
   <f:facet name="first">
      <h:outputText value="First" />
   </f:facet>
   <f:facet name="last">
      <h:outputText value="Last" />
   </f:facet>
</rich:dataScroller>

----

====

[[sect-Component_Reference-dataScroller-Appearance_and_interactivity]]

==== Appearance and interactivity

The [varname]+page+ attribute is a value-binding attribute used to define and save the current page number.

The [sgmltag]+<rich:dataScroller>+ component provides a range of controllers for scrolling through tables and grids:

Controls for scrolling by a specific amount:: The component includes controls for switching to the first page, the last page, the next page, and the previous page, as well as controls for fast-forwarding or rewinding by a set amount. Use the [varname]+fastStep+ attribute to set the number of pages to skip when fast-forwarding or rewinding.
The appearance of these controls can be customized using the following facets: +first+, +last+, +next+, +previous+, +fastForward+, and +fastRewind+. Additionally, there are facets for the controls' disabled states: +first_disabled+, +last_disabled+, +next_disabled+, +previous_disabled+, +fastForward_disabled+, and +fastRewind_disabled+.
Page controls:: The component also features a series of numbered controls to jump to a specific page. Use the [varname]+maxPages+ attribute to limit the number of page controls that appear. The current page control is highlighted.
To add optional separators between controls, define the separators with the +controlsSeparator+ facet.

[[sect-Component_Reference-dataScroller-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:dataScroller>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+switchToPage(pageIndex)+:: Switch to the page specified with the [parameter]+pageIndex+ parameter.
[function]+next()+:: Switch to the next page.
[function]+previous()+:: Switch to the previous page.
[function]+first()+:: Switch to the first page.
[function]+last()+:: Switch to the last page.
[function]+fastForward()+:: Step forward through the pages by the [varname]+fastStep+ amount.
[function]+fastRewind()+:: Step backward through the pages by the [varname]+fastStep+ amount.
[[sect-Component_Reference-dataScroller-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DataScroller+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDataScroller+
* [parameter]+component-family+: [classname]+org.richfaces.DataScroller+
* [parameter]+renderer-type+: [classname]+org.richfaces.DataScrollerRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.DataScrollerHandler+


[[sect-Component_Reference-dataScroller-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/dataScroller.asciidoc[]

[[sect-Component_Reference-Tables_and_grids-Table_filtering]]

=== Table filtering

Tables entries can be filtered by the user through either the basic built-in filter inputs, or by defining external filter controls. Refer to <<sect-Component_Reference-Tables_and_grids-column>> for details on using the [sgmltag]+<rich:column>+ component in tables.

[[sect-Component_Reference-Table_filtering-filtering]]

==== Filter Definition

To define a filter for a column use either the [varname]+filter+ or [varname]+filterExpression+ attributes, then use the [varname]+filterValue+ attribute to point to an object which holds the current filtering value for the column. The attribute can be used to store filtering conditions in a session.

Use the [varname]+filterExpression+ attribute to define an expression that can be evaluated as a boolean value. The expression checks if each table entry satisfies the filtering condition when the table is rendered. For example, the expression might be a JSTL (JavaServer Pages Standard Tag Library) function such as [function]+contains+ or [function]+equals+.

Use the [varname]+filter+ attribute to define a filter interface. The attribute must use EL (Expression Language) to point to an object which implements the [interfacename]+org.richfaces.model.Filter<T>+ interface. The object must provide a single [methodname]+accept(T t)+ method. The method takes each iteration object as a parameter and returns a boolean value, which determines whether the object satisfies the filter. By defining a custom filter, you can implement complex business logic to filter a table.

[[sect-Component_Reference-Table_filtering-builtin_filtering]]

==== Built-in filter controls

The built-in filter controls of the [sgmltag]+<rich:column>+ component allow the user to enter text to use as the filtering value. The value of the built-in filter control is bound to the [varname]+filterValue+ attribute, which can either be an initial filtering value on the page, or a value binding on the server. The filterValue is then applied to the filter defined either by the [varname]+filterExpression+ or [varname]+filter+ column attributes.

The filterValue is of type [varname]+String+. Conversion is either done implicitly via EL in the [varname]+filterExpression+, or explicitly within the [varname]+filter+ function. The filter is processed and the table is rendered when the +onblur+ event occurs for the column.

[[exam-Component_Reference-Table_filtering-Basic_filtering]]

.Basic filtering
====


[source, XML]
----
<rich:extendedDataTable value="#{carsBean.allInventoryItems}" var="car" filterVar="filterValue">
    <f:facet name="header">
        <h:outputText value="Cars marketplace"/>
    </f:facet>
    <rich:column filterExpression="#{empty filterValue or fn:startsWith(car.model, filterValue)}"
                 filterValue="#{carsFilteringBean.modelFilter}">
        <f:facet name="header">Model</f:facet>
        <h:outputText value="#{car.model}"/>
    </rich:column>
    <rich:column filterExpression="#{empty filterValue or car.price ge filterValue}"
                 filterValue="#{carsFilteringBean.priceFilter}"
                 filterConverterMessage="Error converting the 'Price' filter value">
        <f:facet name="header">Price</f:facet>
        <h:outputText value="#{car.price}"/>
    </rich:column>
</rich:extendedDataTable>
----

The example uses the basic filtering method on both columns in the table.

====

[[sect-Component_Reference-Table_filtering-External_filtering]]

==== External filter controls

If you require more advanced filter controls use the external filtering properties of the [sgmltag]+<rich:column>+ component. With custom filter controls you can tailor the filter control, allowing for advanced use cases like select menus, checkboxes, etc. To use a custom filter control with the [varname]+extendedDataTable+ component, one must first disable the built-in filter control.

[NOTE]
.Disabling built-in filter controls
====
The built-in filter controls can be disabled on a column-by-column basis by setting the column attribute [varname]+filterType="custom"+. Alternatively one can disable filter controls for the whole application via the following context-param in the web.xml:


[source, XML]
----
<context-param>
    <param-name>org.richfaces.builtin.filter.enabled</param-name>
    <param-value>false</param-value>
</context-param>
----


====

[[exam-Component_Reference-Table_filtering-External_filtering]]

.Filtering example
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" id="table">

    <f:facet name="header">
        <rich:columnGroup>
            <rich:column>
                <h:outputText value="State Name" />
            </rich:column>
            <rich:column>
                <h:outputText value="State Time Zone" />
            </rich:column>
        </rich:columnGroup>
    </f:facet>
    <rich:column filter="#{filteringBean.stateFilter}">
        <f:facet name="header">
            <h:inputText value="#{filteringBean.stateFilterValue}" id="input">
                <a4j:ajax event="keyup" render="table@body">
                    <a4j:attachQueue  requestDelay="700"
                        ignoreDupResponses="true" />
                </a4j:ajax>
            </h:inputText>
        </f:facet>
        <h:outputText value="#{cap.state}" />
    </rich:column>
    <rich:column filterExpression="#{fn:containsIgnoreCase(cap.timeZone, filteringBean.zoneFilterValue)}">
        <f:facet name="header">
            <h:selectOneMenu value="#{filteringBean.zoneFilterValue}">
                <f:selectItems value="#{filteringBean.zoneList}" />
                <a4j:ajax event="change" render="table@body" />
            </h:selectOneMenu>
        </f:facet>
        <h:outputText value="#{cap.timeZone}" />
    </rich:column>
</rich:dataTable>
----

The example uses a filter expression on the first column and a filter method on the second column.

image::figu-Component_Reference-Table_filtering-External_filtering.png[A table of state capitals filtered by states beginning with the letter " a", further filtered to those states in the GMT-5 time zone.]

====

[[sect-Component_Reference-Tables_and_grids-Table_sorting]]

=== Table sorting

Tables entries can be sorted by defining external sorting algorithms. Refer to <<sect-Component_Reference-Tables_and_grids-column>> for details on using the [sgmltag]+<rich:column>+ component in tables.

[NOTE]
.Sorting non-English tables
====
To sort a table whose contents are not in English, add the +org.richfaces.datatableUsesViewLocale+ context parameter to the project's [filename]+web.xml+ settings file. Set the value of the context parameter to +true+.
====

[[sect-Component_Reference-Tables_and_grids-Comparator]]

==== Comparator Definition

Use the [varname]+comparator+ attribute of the [sgmltag]+<rich:column>+ to specify the comparator to use when sorting. If no [varname]+comparator+ is specified, the sorting algorithm will invoke the entries [varname]+compareTo+ method of the [varname]+sortBy+ values if they implement the [varname]+java.lang.Comparable+ interface. As a final fall back, the algorithm implements a null sort, sorting elements based on whether or not they are null.

[[sect-Component_Reference-Tables_and_grids-Basic_sorting]]

==== Built-in sort controls

The built-in sorting controls of the [sgmltag]+<rich:column>+ component allow a user to click the sort icons of a column to sort it in ascending or descending order.

Set the [varname]+sortBy+ attribute to indicate which value to use when sorting the column. Expressions in the [varname]+sortBy+ attribute must refer to the variable declared in the table's [varname]+var+ attribute, which is used to fill the contents of the table.

[[exam-Component_Reference-Table_sorting-Built_in_sorting]]

.Basic sorting
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" width="300px">
   <rich:column sortBy="#{cap.state}">
      <f:facet name="header">
         <h:outputText value="State Name"/>
      </f:facet>
      <h:outputText value="#{cap.state}"/>
   </rich:column>
   <rich:column sortBy="#{cap.name}">
      <f:facet name="header">
         <h:outputText value="State Capital"/>
      </f:facet>
      <h:outputText value="#{cap.name}"/>
   </rich:column>
</rich:dataTable>

----

The example uses the basic sorting method on both columns in the table.

====

Use the [varname]+sortOrder+ attribute to set how the table's contents are sorted when it is first loaded. By default, the value of the [varname]+sortOrder+ attribute is +unsorted+, so that table entries appear in the order the are contained in the data model. Use [code]+sortOrder="ascending"+ to sort the entries in ascending alphabetical or numerical order. Use [code]+sortOrder="descending"+ to sort the entries in descending alphabetical or numerical order. The [varname]+sortOrder+ attribute can also be used to externally set the sort order of a table when using the external sorting method; refer to <<sect-Component_Reference-Table_sorting-External_sorting>> for details.

[[sect-Component_Reference-Table_sorting-External_sorting]]

==== External sort controls

Set the [varname]+sortBy+ attribute to indicate which iteration object property to use when sorting the column. If using custom-defined rules for sorting, use the [varname]+comparator+ attribute instead. Set the [varname]+comparator+ attribute to point to your comparator method, which will be used when sorting the data model.

[NOTE]
.Disabling built-in sort controls
====
The built-in sort controls can be disabled on a column-by-column basis by setting the column attribute [varname]+sortType="custom"+. Alternatively one can disable sort controls for the whole application via the following context-param in the web.xml:


[source, XML]
----
<context-param>
    <param-name>org.richfaces.builtin.sort.enabled</param-name>
    <param-value>false</param-value>
</context-param>
----


====

Bind the [varname]+sortOrder+ attribute to bean properties to manage the sorting order. The bean must handle all the sorting algorithms. <<exam-Component_Reference-Table_sorting-Sorting>> demonstrates table sorting using an external control.

[[exam-Component_Reference-Table_sorting-Sorting]]

.Sorting
====


[source, XML]
----
<rich:dataTable value="#{capitalsBean.capitals}" var="cap" id="table">
    <rich:column>
        <f:facet name="header">
            State Flag
        </f:facet>
        <h:graphicImage value="#{cap.stateFlag}" alt="flag" />
    </rich:column>
    <rich:column sortBy="#{cap.name}" id="name" sortOrder="#{capitalsSortingBean.capitalsOrder}">
        <f:facet name="header">
            <a4j:commandLink value="Sort by Capital Name" render="table" action="#{capitalsSortingBean.sortByCapitals}" />
        </f:facet>
        <h:outputText value="#{cap.name}" />
    </rich:column>
    <rich:column sortBy="#{cap.state}" id="state" sortOrder="#{capitalsSortingBean.statesOrder}">
        <f:facet name="header">
            <a4j:commandLink value="Sort by State Name" render="table" action="#{capitalsSortingBean.sortByStates}" />
        </f:facet>
        <h:outputText value="#{cap.state}" />
    </rich:column>
    <rich:column sortBy="#{cap.timeZone}" id="timeZone" comparator="#{capitalsSortingBean.timeZoneComparator}"
        sortOrder="#{capitalsSortingBean.timeZonesOrder}">
        <f:facet name="header">
            <a4j:commandLink value="Sort by Time Zone" render="table" action="#{capitalsSortingBean.sortByTimeZones}" />
        </f:facet>
        <h:outputText value="#{cap.timeZone}" />
    </rich:column>
</rich:dataTable>
----

The example uses an external control to manage the table's sorting.

====

When multiple columns are capable of being sorted at the same time, set the priority by which the columns are sorted with the [varname]+sortPriorities+ attribute. The attribute must contain a list of column identifiers in the order of the sorting sequence.

[[chap-Component_Reference-Trees]]

== Trees

Read this chapter for details on components that use tree structures.

[[sect-Component_Reference-Trees-tree]]

=== [sgmltag]+<rich:tree>+

The [sgmltag]+<rich:tree>+ component provides a hierarchical tree control. Each [sgmltag]+<rich:tree>+ component typically consists of [sgmltag]+<rich:treeNode>+ child components. The appearance and behavior of the tree and its nodes can be fully customized.

[[sect-Component_Reference-tree-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:tree>+ component requires the [varname]+value+ attribute to point to the data model for populating the tree. The data model must be either an [interfacename]+org.richfaces.model.TreeNode+ interface, an [varname]+org.richfaces.model.TreeDataModel+ interface, or a [interfacename]+javax.swing.tree.TreeNode+ interface. The [varname]+var+ attribute declares the variable used for iterating through the data model, so that child [sgmltag]+<rich:treeNode>+ components can reference each iteration.

Ideally, the [sgmltag]+<rich:tree>+ component needs one or more [sgmltag]+<rich:treeNode>+ components to work with the data model. However if no [sgmltag]+<rich:treeNode>+ components are provided the tree creates default nodes instead.

[[exam-Component_Reference-tree-Basic_usage]]

.Basic usage
====

This example demonstrates basic usage of the [sgmltag]+<rich:tree>+ component using an [interfacename]+org.richfaces.model.TreeNode+ data model.

First extend the [classname]+org.richfaces.model.TreeNodeImpl+ and add the data fields you require, with appropriate accessor methods, as in:


[source, Java]
----
import org.richfaces.model.TreeNodeImpl;

public class DataHolderTreeNodeImpl extends TreeNodeImpl {
    private Object data;

    public DataHolderTreeNodeImpl() {
        super();
    }

    public DataHolderTreeNodeImpl(boolean leaf, Object data) {
        super(leaf);
        this.data = data;
    }

    public Object getData() {
        return data;
    }

    @Override
    public String toString() {
        return super.toString() + " >> " + data;
    }
}
----

Then, the data model is constructed as follows:


[source, Java]
----
private DataHolderTreeNodeImpl stationRoot;
private DataHolderTreeNodeImpl rootNodes;

public DataHolderTreeNodeImpl getRootNodes() {
    if (rootNodes == null) {
        String[] kickRadioFeed = {"Hall & Oates - Kiss On My List",
                "David Bowie - Let's Dance",
                "Lyn Collins - Think (About It)",
                "Kim Carnes - Bette Davis Eyes",
                "KC & the Sunshine Band - Give It Up"};
        stationRoot = new DataHolderTreeNodeImpl(false, "KickRadio");
        for (int i = 0; i<kickRadioFeed.length; i++) {
            DataHolderTreeNodeImpl child = new DataHolderTreeNodeImpl(true, kickRadioFeed[i]);
            stationRoot.addChild(i, child);
        }
        rootNodes = new DataHolderTreeNodeImpl();
        rootNodes.addChild(0, stationRoot);
    }
    return rootNodes;
}

----

The tree then accesses the nodes of the model using the +station+ variable:


[source, XML]
----
<rich:tree value="#{stations.stationNodes}" var="station">
   <rich:treeNode>
      <h:outputText value="#{station}" />
   </rich:treeNode>
</rich:tree>

----

image::exam-Component_Reference-tree-Basic_usage.png[]

====

[[sect-Component_Reference-tree-Appearance]]

==== Appearance

Different nodes in the tree can have different appearances, such as node icons, depending on the type of data the node contains. Use the [varname]+nodeType+ attribute to differentiate the types of nodes; the node is then rendered according to the [sgmltag]+<rich:treeNode>+ component with the corresponding [varname]+type+ attribute. <<exam-Component_Reference-tree-nodeType_attribute>> shows a [sgmltag]+<rich:tree>+ component with three different child [sgmltag]+<rich:treeNode>+ components defined to represent three different node appearances. Refer to <<sect-Component_Reference-treeNode-Appearance>> for details on customizing the appearance of [sgmltag]+<rich:treeNode>+ components.

[[exam-Component_Reference-tree-nodeType_attribute]]

.[varname]+nodeType+ attribute
====


[source, XML]
----
<rich:tree style="width:300px" value="#{library.data}" var="item" nodeType="#{item.type}">
   <rich:treeNode type="artist" iconExpanded="/images/tree/singer.png" iconCollapsed="/images/tree/singer.png">
      <h:outputText value="#{item.name}" />
   </rich:treeNode>
   <rich:treeNode type="album" iconExpanded="/images/tree/disc.png" iconCollapsed="/images/tree/disc.png">
      <h:outputText value="#{item.album}" />
   </rich:treeNode>
   <rich:treeNode type="song" iconLeaf="/images/tree/song.png">
      <h:outputText value="#{item.title}" />
   </rich:treeNode>
</rich:tree>

----

image::exam-Component_Reference-tree-nodeType_attribute.png[]

====

If the [varname]+nodeType+ attribute returns null, the node is rendered as a " _typeless_" (or default) node. The _typeless_ node is the first child [sgmltag]+<rich:treeNode>+ component with a valid [varname]+rendered+ attribute, but without a defined [varname]+type+ attribute.

If the [varname]+nodeType+ attribute is not included and there are no child [sgmltag]+<rich:treeNode>+ components, the tree constructs a default node itself.

Icons for different nodes and node states can be defined for the whole tree using the following attributes:

[varname]+iconLeaf+:: The [varname]+iconLeaf+ attribute points to the icon to use for any node that does not contain any child nodes.
[varname]+iconExpanded+  and [varname]+iconCollapsed+:: The [varname]+iconExpanded+ and [varname]+iconCollapsed+ attributes point to the icons to use for expanded and collapsed nodes respectively. If these attributes are defined, the [varname]+icon+ attribute is not used.
[[sect-Component_Reference-tree-Expanding_and_collapsing_tree_nodes]]

==== Expanding and collapsing tree nodes

The mode for performing submissions when nodes are expanded or collapsed is determined by the [varname]+toggleType+ attribute, which can have one of the following three values:

+ajax+:: This is the default setting. The [sgmltag]+<rich:tree>+ component performs an Ajax form submission, and only the content of the tree is rendered.
+server+:: The [sgmltag]+<rich:tree>+ component performs a common submission, completely refreshing the page.
+client+:: The [sgmltag]+<rich:tree>+ component updates on the client side through JavaScript, without any additional requests or updates. All nodes are rendered to the client during the initial page rendering.

By default, tree nodes are expanded and collapsed through the [guibutton]#\+# and [guibutton]#-# controls. To expand or collapse a tree node using an action event such as a mouse click, specify the event with the [varname]++toggleNodeEvent++ attribute.

[[sect-Component_Reference-tree-Selecting_tree_nodes]]

==== Selecting tree nodes

The mode for performing submissions when nodes are selected is determined by the [varname]+selectionType+ attribute, which can have one of the following three values:

+ajax+:: This is the default setting. The [sgmltag]+<rich:tree>+ component performs an Ajax form submission, and only the content of the tree is rendered.
+client+:: The [sgmltag]+<rich:tree>+ component updates on the client side using JavaScript, without any additional requests or updates.
[[sect-Component_Reference-tree-Identifying_nodes_with_the_rowKeyConverter_attribute]]

==== Identifying nodes with the [varname]+rowKeyConverter+ attribute

If the [sgmltag]+<rich:tree>+ component uses a custom data model, the data model provides unique keys for tree nodes so they can be identified during a client request. The [sgmltag]+<rich:tree>+ component can use strings as key values. These strings may contain special characters that are not allowed by browsers, such as the left angle bracket (<) and ampersand (&). To allow these characters in the keys, a row key converter must be provided.

To apply a converter to the [sgmltag]+<rich:tree>+ component, define it with the [varname]+rowKeyConverter+ attribute.

[[sect-Component_Reference-tree-Event_handling]]

==== Event handling

In addition to the standard Ajax events and HMTL events, the [sgmltag]+<rich:tree>+ component uses the following client-side events:

* The [varname]+nodetoggle+ event is triggered when a node is expanded or collapsed.
* The [varname]+beforenodetoggle+ event is triggered before a node is expanded or collapsed.
* The [varname]+selectionchange+ event is triggered when a node is selected.
* The [varname]+beforeselectionchange+ event is triggered before a node is selected.


The [sgmltag]+<rich:tree>+ component uses the following server-side listeners:

* The [varname]+toggleListener+ listener processes expand and collapse events.
* The [varname]+selectionChangeListener+ listener processes the request when a node is selected.


[[sect-Component_Reference-tree-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Tree+
* [parameter]+component-class+: [classname]+org.richfaces.component.UItree+
* [parameter]+component-family+: [classname]+org.richfaces.Tree+
* [parameter]+renderer-type+: [classname]+org.richfaces.TreeRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.TreeHandler+


[[sect-Component_Reference-tree-Style_classes]]

==== Style classes

Styling for the [sgmltag]+<rich:tree>+ component is mostly applied to the tree nodes. Refer to <<sect-Component_Reference-treeNode-Style_classes_and_skin_parameters>> for details on styling tree nodes. In addition, the [sgmltag]+<rich:tree>+ component can make use of the style classes outlined in <<tree-Style_classes>>.

include::skinning/tree.asciidoc[]

[[sect-Component_Reference-Actions-treeSelectionChangeListener]]

==== [sgmltag]+<rich:treeSelectionChangeListener>+

Use the [sgmltag]+<rich:treeSelectionChangeListener>+ tag to register a [classname]+TreeSelectionChangeListener+ class on a parent [sgmltag]+<rich:tree>+ component. The class provided as a listener must implement the [interfacename]+org.richfaces.event.TreeSelectionChangeListener+ interface. The [methodname]+processTreeSelectionChange+ method accepts an [classname]+org.richface.event.TreeSelectionChangeEvent+ event as a parameter.

[[sect-Component_Reference-Trees-treeNode]]

==== [sgmltag]+<rich:treeNode>+

The [sgmltag]+<rich:treeNode>+ component is a child component of the [sgmltag]+<rich:tree>+ component. It represents nodes in the parent tree. The appearance and functionality of each tree node can be customized.

[[sect-Component_Reference-treeNode-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:treeNode>+ component must be a child of a [sgmltag]+<rich:tree>+ component or a tree adaptor component. It does not need any attributes declared for basic usage, but can provide markup templates for tree nodes of particular types. Default markup is used if the tree node type is not specified. Refer to <<exam-Component_Reference-tree-Basic_usage>> for an example of basic [sgmltag]+<rich:treeNode>+ component usage.

[[exam-Component_Reference-treeNode-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:tree nodeType="#{node.type}" var="node"
           value="#{treeBean.rootNodes}">
   <rich:treeNode type="country">
      #{node.name}
   </rich:treeNode>
   <rich:treeNode type="state">
      #{node.name}
   </rich:treeNode>
   <rich:treeNode type="city">
      #{node.name}
   </rich:treeNode>
</rich:tree>

----

The example renders a simple tree of countries. Each country node expands to show state nodes for that country, and each state node expands to show city nodes for that state.

====

[[sect-Component_Reference-treeNode-Appearance]]

===== Appearance

Refer to <<sect-Component_Reference-tree-Appearance>> for the [sgmltag]+<rich:tree>+ component for details and examples on styling nodes and icons. Icon styling for individual [sgmltag]+<rich:treeNode>+ components uses the same attributes as the parent [sgmltag]+<rich:tree>+ component: [varname]+iconLeaf+, [varname]+iconExpanded+, and [varname]+iconCollapsed+. Icon-related attributes specified for child [sgmltag]+<rich:treeNode>+ components overwrite any global icon attributes of the parent [sgmltag]+<rich:tree>+ component.

Use the [varname]+rendered+ attribute to determine whether the node should actually be rendered in the tree or not. Using the [varname]+rendered+ attribute in combination with the [sgmltag]+<rich:treeNode>+ [varname]+type+ attribute can allow further style differentiation between node content.

[[sect-Component_Reference-treeNode-Interactivity]]

===== Interactivity

Interactivity with individual nodes, such as expanding, collapsing, and other event handling, can be managed by the parent [sgmltag]+<rich:tree>+ component. Refer to <<sect-Component_Reference-tree-Expanding_and_collapsing_tree_nodes>> and <<sect-Component_Reference-tree-Event_handling>> for further details.

Use the [varname]+expanded+ attribute to determine whether the node is expanded or collapsed.

[[sect-Component_Reference-treeNode-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.TreeNode+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITreeNode+
* [parameter]+component-family+: [classname]+org.richfaces.TreeNode+
* [parameter]+renderer-type+: [classname]+org.richfaces.TreeNodeRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.TreeNodeHandler+


[[sect-Component_Reference-treeNode-Style_classes_and_skin_parameters]]

===== Style classes and skin parameters

include::skinning/treeNode.asciidoc[]

[[sect-Component_Reference-Actions-treeToggleListener]]

===== [sgmltag]+<rich:treeToggleListener>+

Use the [sgmltag]+<rich:treeToggleListener>+ tag to register a [classname]+TreeToggleListener+ class on a parent [sgmltag]+<rich:treeNode>+ component. The class provided as a listener must implement the [interfacename]+org.richfaces.event.TreeToggleListener+ interface. The [methodname]+processTreeToggle+ method accepts an [classname]+org.richface.event.TreeToggleEvent+ event as a parameter.

[[sect-Component_Reference-Trees-Tree_adaptors]]

=== Tree adaptors

Use a tree adaptor to populate a tree model declaratively from a non-hierarchical model, such as a list or a map.

[[sect-Component_Reference-Tree_adaptors-treeModelAdaptor]]

==== [sgmltag]+<rich:treeModelAdaptor>+

The [sgmltag]+<rich:treeModelAdaptor>+ component takes an object which implements the [interfacename]+Map+ or [interfacename]+Iterable+ interfaces. It adds all the object entries to the parent node as child nodes.

[[sect-Component_Reference-treeModelAdaptor-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:treeModelAdaptor>+ component is added as a nested child component to a [sgmltag]+<rich:tree>+ component, or to another tree adaptor component.

The [sgmltag]+<rich:treeModelAdaptor>+ component requires the [varname]+nodes+ attribute for basic usage. The [varname]+nodes+ attribute defines a collection of elements to iterate through for populating the nodes.

Define the appearance of each node added by the adaptor with a child [sgmltag]+<rich:treeNode>+ component. Refer to <<sect-Component_Reference-Trees-treeNode>> for details on the [sgmltag]+<rich:treeNode>+ component.

[[sect-Component_Reference-treeModelAdaptor-Identifying_nodes]]

===== Identifying nodes

Adaptors that use [interfacename]+Map+ interfaces or models with non-string keys require a row key converter in order to correctly identify nodes. Refer to <<sect-Component_Reference-tree-Identifying_nodes_with_the_rowKeyConverter_attribute>> for details on the use of the [varname]+rowKeyConverter+ attribute.

Adaptors that use [interfacename]+Iterable+ interfaces have simple integer row keys. A default converter is provided and does not need to be referenced explicitly.

[[sect-Component_Reference-treeModelAdaptor-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.treeModelAdaptor+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITreeModelAdaptor+
* [parameter]+component-family+: [classname]+org.richfaces.TreeModelAdaptor+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.TreeModelAdaptorHandler+


[[sect-Component_Reference-Tree_adaptors-treeModelRecursiveAdaptor]]

==== [sgmltag]+<rich:treeModelRecursiveAdaptor>+

The [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component iterates through recursive collections in order to populate a tree with hierarchical nodes, such as for a file system with multiple levels of directories and files.

[[sect-Component_Reference-treeModelRecursiveAdaptor-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component is an extension of the [sgmltag]+<rich:treeModelAdaptor>+ component. As such, the [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component uses all of the same attributes. Refer to <<sect-Component_Reference-Tree_adaptors-treeModelAdaptor>> for details on the [sgmltag]+<rich:treeModelAdaptor>+ component.

In addition, the [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component requires the [varname]+roots+ attribute. The [varname]+roots+ attribute defines the collection to use at the top of the recursion. For subsequent levels, the [varname]+nodes+ attribute is used for the collection.

<<exam-Component_Reference-treeModelRecursiveAdaptor-Basic_usage>> demonstrates how the [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component can be used in conjunction with the [sgmltag]+<rich:treeModelAdaptor>+ component to recursively iterate through a file system and create a tree of directories and files.

[[exam-Component_Reference-treeModelRecursiveAdaptor-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:tree var="item">
   <rich:treeModelRecursiveAdaptor roots="#{fileSystemBean.sourceRoots}" nodes="#{item.directories}" >
      <rich:treeNode>
         #{item.shortPath}
      </rich:treeNode>
      <rich:treeModelAdaptor nodes="#{item.files}">
         <rich:treeNode>#{item}</rich:treeNode>
      </rich:treeModelAdaptor>
   </rich:treeModelRecursiveAdaptor>
</rich:tree>

----

The [sgmltag]+<rich:treeModelRecursiveAdaptor>+ component references the [classname]+FileSystemBean+ class as the source for the data.


[source, Java]
----
@ManagedBean
@RequestScoped
public class FileSystemBean {
   private static final String SRC_PATH = "/WEB-INF";

   private List<FileSystemNode> srcRoots;

   public synchronized List<FileSystemNode> getSourceRoots() {
      if (srcRoots == null) {
         srcRoots = new FileSystemNode(SRC_PATH).getDirectories();
      }
      return srcRoots;
   }
}

----

The [classname]+FileSystemBean+ class in turn uses the [classname]+FileSystemNode+ class to recursively iterate through the collection.


[source, Java]
----
public class FileSystemNode {
   ...
   public synchronized List<FileSystemNode> getDirectories() {
      if (directories == null) {
         directories = Lists.newArrayList();
         Iterables.addAll(directories, transform(filter(getResourcePaths(), containsPattern("/$")), FACTORY));
      }
      return directories;
   }

   public synchronized List<String> getFiles() {
      if (files == null) {
         files = new ArrayList<String>();
         Iterables.addAll(files, transform(filter(getResourcePaths(), not(containsPattern("/$"))), TO_SHORT_PATH));
      }
      return files;
   }

   private Iterable<String> getResourcePaths() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        ExternalContext externalContext = facesContext.getExternalContext();
        Set<String> resourcePaths = externalContext.getResourcePaths(this.path);

      if (resourcePaths == null) {
         resourcePaths = Collections.emptySet();
      }
      return resourcePaths;
   }
   ...
}

----

The [function]+getDirectories()+ function is used recursively until the object has the collection of children. The model adaptor calls the [function]+getFiles()+ function at each level in order to add the file nodes.

The resulting tree hierarchically lists the directories and files in the collection.

image::exam-Component_Reference-treeModelRecursiveAdaptor-Basic_usage.png[A hierarchical tree detailing a file system.]

====

[[sect-Component_Reference-treeModelRecursiveAdaptor-Identifying_nodes]]

===== Identifying nodes

Adaptors that use [interfacename]+Map+ interfaces or models with non-string keys require a row key converter in order to correctly identify nodes. Refer to <<sect-Component_Reference-tree-Identifying_nodes_with_the_rowKeyConverter_attribute>> for details on the use of the [varname]+rowKeyConverter+ attribute.

Adaptors that use [interfacename]+Iterable+ interfaces have simple integer row keys. A default converter is provided and does not need to be referenced explicitly.

[[sect-Component_Reference-treeModelRecursiveAdaptor-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.TreeModelRecursiveAdaptor+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITreeModelRecursiveAdaptor+
* [parameter]+component-family+: [classname]+org.richfaces.TreeModelRecursiveAdaptor+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.TreeModelRecursiveAdaptorHandler+


[[chap-Component_Reference-Menus_and_toolbars]]

== Menus and toolbars

Read this chapter for details on menu and toolbar components.

[[sect-Component_Reference-Menus_and_toolbars-dropDownMenu]]

=== [sgmltag]+<rich:dropDownMenu>+

The [sgmltag]+<rich:dropDownMenu>+ component is used for creating a drop-down, hierarchical menu. It can be used with the [sgmltag]+<rich:toolbar>+ component to create menus in an application's toolbar.

[[figu-Component_Reference-dropDownMenu-dropDownMenu]]
.[sgmltag]+<rich:dropDownMenu>+
image::figu-Component_Reference-dropDownMenu-dropDownMenu.png[]


[[sect-Component_Reference-dropDownMenu-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:dropDownMenu>+ component only requires the [varname]+label+ attribute for basic usage. Use the [varname]+label+ attribute to define the text label that appears as the title of the menu. Clicking on the title drops the menu down.

Alternatively, use the +label+ facet to define the menu title. If the +label+ facet is used, the [varname]+label+ attribute is not necessary.

[[sect-Component_Reference-dropDownMenu-Menu_content]]

==== Menu content

To set the content of the drop-down menu and any sub-menus, use the [sgmltag]+<rich:menuItem>+, [sgmltag]+<rich:menuGroup>+, and [sgmltag]+<rich:menuSeparator>+ components. These components are detailed in <<sect-Component_Reference-Menus_and_toolbars-Menu_sub-components>>.

[[sect-Component_Reference-dropDownMenu-Appearance]]

==== Appearance

Use the [varname]+jointPoint+ and [varname]+direction+ attributes to determine the direction and location of the menu when it appears. The [varname]+jointPoint+ and [varname]+direction+ attributes both use the following settings:

+topLeft+, +topRight+, +bottomLeft+, +bottomRight+:: When used with the [varname]+jointPoint+ attribute, the menu is attached to the top-left, top-right, bottom-left, or bottom-right of the control as appropriate.
+
When used with the [varname]+direction+ attribute, the menu appears to the top-left, top-right, bottom-left, or bottom-right of the joint location as appropriate.
+auto+:: The direction or joint location is determined automatically.
+autoLeft+, +autoRight+, +topAuto+, +bottomAuto+:: When used with the [varname]+jointPoint+ attribute, the joint location is determined automatically, but defaults to either the left, right, top, or bottom of the control as appropriate.
+
When used with the [varname]+direction+ attribute, the menu direction is determined automatically, but defaults to either the left, right, top, or bottom of the joint location as appropriate.

[[sect-Component_Reference-dropDownMenu-Expanding_and_collapsing_the_menu]]

==== Expanding and collapsing the menu

By default, the menu drops down when the title is clicked. To drop down with a different event, use the [varname]+showEvent+ attribute to define the event instead.

Menus can be navigated using the keyboard. Additionally, menus can be navigated programmatically using the JavaScript [acronym]#API#. The JavaScript API allows the following methods:

[methodname]+show()+:: The [methodname]+show()+ method shows the menu.
[methodname]+hide()+:: The [methodname]+hide()+ method hides the menu.
[methodname]+activateItem(menuItemId)+:: The [methodname]+activateItem(menuItemId)+ activates the menu item with the [parameter]+menuItemId+ identifier.

Use the [varname]+mode+ attribute to determine how the menu requests are submitted:

* +server+, the default setting, submits the form normally and completely refreshes the page.
* +ajax+ performs an Ajax form submission, and re-renders elements specified with the [varname]+render+ attribute.
* +client+ causes the [varname]+action+ and [varname]+actionListener+ items to be ignored, and the behavior is fully defined by the nested components or custom JavaScript instead of responses from submissions.


[[sect-Component_Reference-dropDownMenu-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DropDownMenu+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDropDownMenu+
* [parameter]+component-family+: [classname]+org.richfaces.DropDownMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.DropDownMenuRenderer+


[[sect-Component_Reference-dropDownMenu-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/dropDownMenu.asciidoc[]

[[sect-Component_Reference-Menus_and_toolbars-contextMenu]]

=== [sgmltag]+<rich:contextMenu>+

The [sgmltag]+<rich:contextMenu>+ component is used for creating a hierarchical context menu that are activated on events like +onmouseover+ , +onclick+ etc. The component can be applied to any element on the page.

[[figu-Component_Reference-contextMenu-contextMenu]]
.[sgmltag]+<rich:contextMenu>+
image::figu-Component_Reference-contextMenu-contextMenu.png[]


[[sect-Component_Reference-contextMenu-Basic_usage]]

==== Basic usage

To set the content of the context menu and any sub-menus, use the [sgmltag]+<rich:menuItem>+, [sgmltag]+<rich:menuGroup>+, and [sgmltag]+<rich:menuSeparator>+ components. These components are detailed in <<sect-Component_Reference-Menus_and_toolbars-Menu_sub-components>>.

[[sect-Component_Reference-contextMenu-Appearance]]

==== Appearance

Use the [varname]+direction+ attribute to determine the direction of the menu when it appears. The [varname]+direction+ attribute uses the following settings:

+topLeft+, +topRight+, +bottomLeft+, +bottomRight+:: The menu appears to the top-left, top-right, bottom-left, or bottom-right of the activation point.
+auto+:: The direction is determined automatically.
+autoLeft+, +autoRight+, +topAuto+, +bottomAuto+:: The menu direction is determined automatically, but defaults to either the left, right, top, or bottom of the activation point as appropriate.
[[sect-Component_Reference-contextMenu-Expanding_and_collapsing_the_menu]]

==== Expanding and collapsing the menu

By default, the menu is activated when the +contextmenu+ event is observed (ie. a right-click). To activate on a different event, use the [varname]+showEvent+ attribute to define the event instead.

Menus can be navigated using the keyboard. Additionally, menus can be navigated programmatically using the JavaScript [acronym]#API#. The JavaScript API allows the following methods:

[methodname]+show()+:: The [methodname]+show()+ method shows the menu.
[methodname]+hide()+:: The [methodname]+hide()+ method hides the menu.
[methodname]+activateItem(menuItemId)+:: The [methodname]+activateItem(menuItemId)+ activates the menu item with the [parameter]+menuItemId+ identifier.

Use the [varname]+mode+ attribute to determine how the menu requests are submitted:

* +server+, the default setting, submits the form normally and completely refreshes the page.
* +ajax+ performs an Ajax form submission, and re-renders elements specified with the [varname]+render+ attribute.
* +client+ causes the [varname]+action+ and [varname]+actionListener+ items to be ignored, and the behavior is fully defined by the nested components or custom JavaScript instead of responses from submissions.

==== Text substitutions

To avoid creating many menus in iterable components that perform the same actions but only differ in content you can create one menu and reuse it with substituting its text content.

[source, XML]
----
<rich:contextMenu id="menu" attached="false">
    <rich:menuItem action="#{bean.edit}">{Edit}</rich:menuItem>
    <rich:menuItem action="#{bean.delete}">{Delete}</rich:menuItem>
</rich:contextMenu>
----

The text will be replaced by calling the [varname]+show+ event with corresponding parameters:

[source, JavaScript]
----
menu.show(event, { replace:
    { Edit: "Change Photo #{photo.name}", Delete: "Remove Photo #{photo.name}"}
});
----

It can be achieved by using [sgmltag]+<rich:componentControl>+ with parameters:

[source, XML]
----
<rich:componentControl event="click" target="menu" operation="show">
    <a4j:param noEscape="true" value="event" />
    <rich:hashParam name="replace">
        <f:param name="Edit" value="Change Photo #{photo.name}" />
        <f:param name="Delete" value="Remove Photo #{photo.name}" />
    </rich:hashParam>
</rich:componentControl>
----

[[sect-Component_Reference-contextMenu-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.ContextMenu+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIContextMenu+
* [parameter]+component-family+: [classname]+org.richfaces.ContextMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.ContextMenuRenderer+


[[sect-Component_Reference-contextMenu-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/contextMenu.asciidoc[]

[[sect-Component_Reference-Menus_and_toolbars-Menu_sub-components]]

=== Menu sub-components

The [sgmltag]+<rich:menuItem>+, [sgmltag]+<rich:menuGroup>+, and [sgmltag]+<rich:menuSeparator>+ components are used to construct menus for the [sgmltag]+<rich:dropDownMenu>+ component. Refer to <<sect-Component_Reference-Menus_and_toolbars-dropDownMenu>> for more details on the [sgmltag]+<rich:dropDownMenu>+ component.

[[sect-Component_Reference-Menus_and_toolbars-menuItem]]

==== [sgmltag]+<rich:menuItem>+

The [sgmltag]+<rich:menuItem>+ component represents a single item in a menu control. The [sgmltag]+<rich:menuItem>+ component can be also be used as a seperate component without a parent menu component, such as on a toolbar.

[[sect-Component_Reference-menuItem-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:menuItem>+ component requires the [varname]+label+ attribute for basic usage. The [varname]+label+ attribute is the text label for the menu item.

[[sect-Component_Reference-menuItem-Appearance]]

===== Appearance

Icons can be added to menu items through the use of two icon attributes. The [varname]+icon+ attribute specifies the normal icon, while the [varname]+iconDisabled+ attribute specifies the icon for a disabled item.

Alternatively, define facets with the names +icon+ and +iconDisabled+ to set the icons. If facets are defined, the [varname]+icon+ and [varname]+iconDisabled+ attributes are ignored. Using facets for icons allows more complex usage; example shows a checkbox being used in place of an icon.

[[exam-Component_Reference-menuItem-Icon_facets]]

.Icon facets
====


[source, XML]
----
<rich:menuItem value="Show comments">
   <f:facet name="icon">
      <h:selectBooleanCheckbox value="#{bean.property}"/>
   </f:facet>
</rich:menuItem>

----

====

[[sect-Component_Reference-menuItem-Submission_modes]]

===== Submission modes

Use the [varname]+submitMode+ attribute to determine how the menu item requests are submitted:

* +server+, the default setting, submits the form normally and completely refreshes the page.
* +ajax+ performs an Ajax form submission, and re-renders elements specified with the [varname]+render+ attribute.
* +client+ causes the [varname]+action+ and [varname]+actionListener+ items to be ignored, and the behavior is fully defined by the nested components instead of responses from submissions.


[[sect-Component_Reference-menuItem-JavaScript_API]]

===== JavaScript API

The [sgmltag]+<rich:menuItem>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+activate()+:: Activate the menu item as though it were selected.
[[sect-Component_Reference-menuItem-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.MenuItem+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIMenuItem+
* [parameter]+component-family+: [classname]+org.richfaces.DropDownMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.MenuItemRenderer+


[[sect-Component_Reference-Menus_and_toolbars-menuGroup]]

==== [sgmltag]+<rich:menuGroup>+

The [sgmltag]+<rich:menuGroup>+ component represents an expandable sub-menu in a menu control. The [sgmltag]+<rich:menuGroup>+ component can contain a number of [sgmltag]+<rich:menuItem>+ components, or further nested [sgmltag]+<rich:menuGroup>+ components.

[[sect-Component_Reference-menuGroup-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:menuGroup>+ component requires the [varname]+label+ attribute for basic usage. The [varname]+label+ attribute is the text label for the menu item. Alternatively, use the +label+ facet to define content for the label.

Additionally, the [sgmltag]+<rich:menuGroup>+ component must contain child [sgmltag]+<rich:menuItem>+ components or [sgmltag]+<rich:menuGroup>+ components.

[[sect-Component_Reference-menuGroup-Appearance]]

===== Appearance

Icons can be added to menu groups through the use of two icon attributes. The [varname]+icon+ attribute specifies the normal icon, while the [varname]+iconDisabled+ attribute specifies the icon for a disabled group.

The [sgmltag]+<rich:menuGroup>+ component can be positioned using the [varname]+jointPoint+ and [varname]+direction+ attributes, the same as the parent menu control. For details on the [varname]+jointPoint+ and [varname]+direction+ attributes, refer to <<sect-Component_Reference-dropDownMenu-Appearance>>.

[[sect-Component_Reference-menuGroup-JavaScript_API]]

===== JavaScript API

The [sgmltag]+<rich:menuGroup>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+show()+:: Show the menu group.
[function]+hide()+:: Hide the menu group.
[[sect-Component_Reference-menuGroup-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.MenuGroup+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIMenuGroup+
* [parameter]+component-family+: [classname]+org.richfaces.DropDownMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.MenuGroupRenderer+


[[sect-Component_Reference-Menus_and_toolbars-menuSeparator]]

==== [sgmltag]+<rich:menuSeparator>+

The [sgmltag]+<rich:menuSeparator>+ component represents a separating divider in a menu control.

[[sect-Component_Reference-menuSeparator-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:menuSeparator>+ component does not require any attributes for basic usage. Add it as a child to a menu component to separator menu items and menu groups.

[[sect-Component_Reference-menuSeparator-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.MenuSeparator+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIMenuSeparator+
* [parameter]+component-family+: [classname]+org.richfaces.DropDownMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.MenuSeparatorRenderer+


[[sect-Component_Reference-Menus_and_toolbars-panelMenu]]

=== [sgmltag]+<rich:panelMenu>+

The [sgmltag]+<rich:panelMenu>+ component is used in conjunction with [sgmltag]+<rich:panelMenuItem>+ and [sgmltag]+<rich:panelMenuGroup>+ to create an expanding, hierarchical menu. The [sgmltag]+<rich:panelMenu>+ component's appearance can be highly customized, and the hierarchy can stretch to any number of sub-levels.

[[exam-Component_Reference-panelMenu-panelMenu]]

.panelMenu
====


[source, XML]
----
<rich:panelMenu mode="ajax"
                topGroupExpandedRightIcon="chevronUp"
                topGroupCollapsedRightIcon="chevronDown"
                groupExpandedLeftIcon="disc"
                groupCollapsedLeftIcon="disc">
   <rich:panelMenuGroup label="Group 1">
      <rich:panelMenuItem label="Item 1.1"/>
      <rich:panelMenuItem label="Item 1.2"/>
      <rich:panelMenuItem label="Item 1.3"/>
   </rich:panelMenuGroup>
   <rich:panelMenuGroup label="Group 2">
      <rich:panelMenuItem label="Item 2.1"/>
      <rich:panelMenuItem   label="Item 2.2"/>
      <rich:panelMenuItem label="Item 2.3"/>
      <rich:panelMenuGroup label="Group 2.4">
         <rich:panelMenuItem label="Item 2.4.1"/>
         <rich:panelMenuItem label="Item 2.4.2"/>
         <rich:panelMenuItem label="Item 2.4.3"/>
      </rich:panelMenuGroup>
      <rich:panelMenuItem label="Item 2.5"/>
   </rich:panelMenuGroup>
   <rich:panelMenuItem label="Item 3"/>
</rich:panelMenu>

----

image::figu-Component_Reference-panelMenu-panelMenu.png[A panel menu. The first menu group is collapsed. The second menu group is expanded; it contains menu items and a further menu group, which is currently selected and expanded. The third menu item is not a group and as such is not expandable.]

====

[[sect-Component_Reference-panelMenu-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:panelMenu>+ component does not need any extra attributes declared for basic usage. However, it does require child [sgmltag]+<rich:panelMenuGroup>+ and [sgmltag]+<rich:panelMenuItem>+ components. Refer to <<sect-Component_Reference-Menus_and_toolbars-panelMenuGroup>> and <<sect-Component_Reference-Menus_and_toolbars-panelMenuItem>> for details on these child components.

[[sect-Component_Reference-panelMenu-Interactivity_options]]

==== Interactivity options

The [varname]+activeItem+ attribute is used to point to the name of the currently selected menu item.

By default, the event to expand the menu is a mouse click. Set the [varname]+expandEvent+ attribute to specify a different event to expand menus. Multiple levels of sub-menus can be expanded in one action. Set [code]+expandSingle="true"+ to only expand one sub-menu at a time.

Similarly, the default event to collapse the menu is a mouse click. Set the [varname]+collapseEvent+ attribute to specify a different event to collapse menus.

As with other control components, set [code]+disabled="true"+ to disable the [sgmltag]+<rich:panelMenu>+ comonent. Child menu components can be disabled in the same way.

[[sect-Component_Reference-panelMenu-Appearance]]

==== Appearance

Icons for the panel menu can be chosen from a set of standard icons. Icons can be set for the top panel menu, child panel menus, and child item. There are three different menu states that the icon represents, as well as icons for both the left and right side of the item title.

[varname]+topGroupExpandedLeftIcon+, [varname]+topGroupExpandedRightIcon+:: These attributes determine the icons for the top level menu when it is expanded.
[varname]+topGroupCollapsedLeftIcon+, [varname]+topGroupCollapsedRightIcon+:: These attributes determine the icons for the top level menu when it is collapsed.
[varname]+topGroupDisabledLeftIcon+, [varname]+topGroupDisabledRightIcon+:: These attributes determine the icons for the top level menu when it is disabled.
[varname]+topItemLeftIcon+, [varname]+topItemRightIcon+:: These attributes determine the icons for a top level menu item.
[varname]+topItemDisabledLeftIcon+, [varname]+topItemDisabledRightIcon+:: These attributes determine the icons for a top level menu item when it is disabled.
[varname]+groupExpandedLeftIcon+, [varname]+groupExpandedRightIcon+:: These attributes determine the icons for sub-menus that are not the top-level menu when they are expanded.
[varname]+groupCollapsedLeftIcon+, [varname]+groupCollapsedRightIcon+:: These attributes determine the icons for sub-menus that are not the top-level menu when they are collapsed.
[varname]+groupDisabledLeftIcon+, [varname]+groupDisabledRightIcon+:: These attributes determine the icons for sub-menus that are not the top-level menu when they are disabled.
[varname]+itemLeftIcon+, [varname]+itemRightIcon+:: These attributes determine the icons for items in the menus.
[varname]+itemDisabledLeftIcon+, [varname]+itemDisabledRightIcon+:: These attributes determine the icons for items in the menus when they are disabled.

<<exam-Component_Reference-panelMenu-panelMenu>> demonstrates the use of icon declaration at the panel menu level. The standard icons are shown in <<figu-Component_Reference-panelMenu-Standard_icons>>.

[[figu-Component_Reference-panelMenu-Standard_icons]]
.[sgmltag]+<Standard icons>+
image::figu-Component_Reference-panelMenuGroup-Standard_icons.png[]


Alternatively, point the icon attributes to the paths of image files. The image files are then used as icons.

Any icons specified by child [sgmltag]+<rich:panelMenuGroup>+ and [sgmltag]+<rich:panelMenuItem>+ components overwrite the relevant icons declared with the parent [sgmltag]+<rich:panelMenu>+ component.

[[sect-Component_Reference-panelMenu-Submission_modes]]

==== Submission modes

The [varname]+itemMode+ attribute defines the submission mode for normal menu items that link to content, and the [varname]+groupMode+ attribute defines the submission mode for menu items that expand and collapse. The settings for these attributes apply to the entire menu unless a menu item defines its own individual [varname]+itemMode+ or [varname]+groupMode+. The possible values for [varname]+itemMode+ and [varname]+groupMode+ are as follows:

* +server+, the default setting, which submits the form normally and completely refreshes the page.
* +ajax+, which performs an Ajax form submission, and re-renders elements specified with the [varname]+render+ attribute.
* +client+, which causes the [varname]+action+ and [varname]+actionListener+ items to be ignored, and the behavior is fully defined by the nested components instead of responses from submissions.


[[sect-Component_Reference-panelMenu-panelMenu_server-side_events]]

==== [sgmltag]+<rich:panelMenu>+ server-side events

The [sgmltag]+<rich:panelMenu>+ component fires the +ItemChangeEvent+ event on the server side when the menu is changed. The event only fires in the +server+ and +ajax+ submission modes. The event provides the [varname]+itemChangeListener+ attribute to reference the event listener. Refer to <<sect-Component_Reference-Panels-itemChangeListener>> for details on the [sgmltag]+<rich:itemChangeListener>+ tag.

[[sect-Component_Reference-panelMenu-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:panelMenu>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+expandAll()+:: Expand all the panel menu groups in the component.
[function]+collapseAll()+:: Collapse all the panel menu groups in the component.
[function]+selectItem(id)+:: Select the menu item with the [parameter]+id+ identifier.
[[sect-Component_Reference-panelMenu-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.PanelMenu+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPanelMenu+
* [parameter]+component-family+: [classname]+org.richfaces.PanelMenu+
* [parameter]+renderer-type+: [classname]+org.richfaces.PanelMenuRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.html.PanelMenuTagHandler+


[[sect-Component_Reference-panelMenu-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/panelMenu.asciidoc[]

[[sect-Component_Reference-Menus_and_toolbars-panelMenuGroup]]

==== [sgmltag]+<rich:panelMenuGroup>+

The [sgmltag]+<rich:panelMenuGroup>+ component defines a group of [sgmltag]+<rich:panelMenuItem>+ components inside a [sgmltag]+<rich:panelMenu>+.

[[sect-Component_Reference-panelMenuGroup-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:panelMenuGroup>+ component needs the [varname]+label+ attribute declared, which specifies the text to show for the menu entry. Alternatively, the +label+ facet can be used to specify the menu text.

In addition, the [sgmltag]+<rich:panelMenuGroup>+ component at least one [sgmltag]+<rich:panelMenuGroup>+ or [sgmltag]+<rich:panelMenuItem>+ components as child elements.

[[sect-Component_Reference-panelMenuGroup-Appearance]]

===== Appearance

Icons for the menu group are inherited from the parent [sgmltag]+<rich:panelMenu>+ component. Refer to <<sect-Component_Reference-panelMenu-Appearance>> for details on icon attributes and facets. Alternatively, the menu group's icons can be re-defined at the [sgmltag]+<rich:panelMenuGroup>+ component level, and these settings will be used instead of the parent component's settings.

[[sect-Component_Reference-panelMenuGroup-Submission_modes]]

===== Submission modes

If the [varname]+mode+ attribute is unspecified, the submission behavior for the group is inherited from the parent [sgmltag]+<rich:panelMenu>+. Otherwise, the [varname]+groupMode+ setting of the panel menu is used instead of the parent's behavior. Refer to <<sect-Component_Reference-panelMenu-Submission_modes>> for submission mode settings.

[[sect-Component_Reference-panelMenuGroup-panelMenuGroup_server-side_events]]

===== [sgmltag]+<rich:panelMenuGroup>+ server-side events

The [sgmltag]+<rich:panelMenuGroup>+ component fires the +ActionEvent+ event on the server side when the menu group receives a user action. The event only fires in the +server+ and +ajax+ submission modes. The event provides the [varname]+action+ attribute to specify the user action method, and the [varname]+actionListener+ attribute to reference the event listener.

[[sect-Component_Reference-panelMenuGroup-JavaScript_API]]

===== JavaScript API

The [sgmltag]+<rich:panelMenuGroup>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+expand()+:: Expand this panel menu group.
[function]+collapse()+:: Collapse this panel menu group.
[function]+select(id)+:: Select the menu item with the [parameter]+id+ identifier.
[[sect-Component_Reference-panelMenuGroup-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.PanelMenuGroup+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPanelMenuGroup+
* [parameter]+component-family+: [classname]+org.richfaces.PanelMenuGroup+


[[sect-Component_Reference-Menus_and_toolbars-panelMenuItem]]

==== [sgmltag]+<rich:panelMenuItem>+

The [sgmltag]+<rich:panelMenuItem>+ component represents a single item inside a [sgmltag]+<rich:panelMenuGroup>+ component, which is in turn part of a [sgmltag]+<rich:panelMenu>+ component.

[[sect-Component_Reference-panelMenuItem-Basic_usage]]

===== Basic usage

The [sgmltag]+<rich:panelMenuItem>+ component needs the [varname]+label+ attribute declared, which specifies the text to show for the menu entry. Alternatively, the +label+ facet can be used to specify the menu text.

[[sect-Component_Reference-panelMenuItem-Appearance]]

===== Appearance

Icons for the menu item are inherited from the parent [sgmltag]+<rich:panelMenu>+ or [sgmltag]+<rich:panelMenuGroup>+ component. Refer to <<sect-Component_Reference-panelMenu-Appearance>> for details on icon attributes and facets. Alternatively, the menu item's icons can be re-defined at the [sgmltag]+<rich:panelMenuItem>+ component level, and these settings will be used instead of the parent component's settings.

[[sect-Component_Reference-panelMenuItem-Submission_modes]]

===== Submission modes

If the [varname]+mode+ is unspecified, the submission behavior for the item is inherited from the parent [sgmltag]+<rich:panelMenu>+. Otherwise, the [varname]+itemMode+ setting from the panel menu is used instead of the parent's behavior.

[[sect-Component_Reference-panelMenuItem-panelMenuItem_server-side_events]]

===== [sgmltag]+<rich:panelMenuItem>+ server-side events

The [sgmltag]+<rich:panelMenuItem>+ component fires the +ActionEvent+ event on the server side when the menu item receives a user action. The event only fires in the +server+ and +ajax+ submission modes. The event provides the [varname]+action+ attribute to specify the user action performed, and the [varname]+actionListener+ attribute to reference the event listener.

[[sect-Component_Reference-panelMenuItem-JavaScript_API]]

===== JavaScript API

The [sgmltag]+<rich:panelMenuItem>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+select()+:: Select this menu item.
[[sect-Component_Reference-panelMenuItem-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.PanelMenuItem+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPanelMenuItem+
* [parameter]+component-family+: [classname]+org.richfaces.PanelMenuItem+


[[sect-Component_Reference-Menus_and_toolbars-toolbar]]

=== [sgmltag]+<rich:toolbar>+

The [sgmltag]+<rich:toolbar>+ component is a horizontal toolbar. Any JavaServer Faces ( [acronym]#JSF#) component can be added to the toolbar.

[[figu-Component_Reference-toolbar-toolbar]]
.[sgmltag]+<rich:toolbar>+
image::figu-Component_Reference-toolbar-toolbar.png[]


[[sect-Component_Reference-toolbar-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:toolbar>+ component does not require any attributes to be defined for basic usage. Add child components to the [sgmltag]+<rich:toolbar>+ component to have them appear on the toolbar when rendered.

[[exam-Component_Reference-toolbar-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:toolbar>
   <h:commandLink value="News" />
   <h:commandLink value="Reviews" />
   <h:commandLink value="Galleries" />
</rich:toolbar>

----

====

[[sect-Component_Reference-toolbar-Appearance]]

==== Appearance

Set the width and height of the toolbar using the common [varname]+width+ and [varname]+height+ attributes.

Items on the toolbar can be separated by a graphical item separator. Use the [varname]+itemSeparator+ attribute to specify one of the standard separator styles:

* +none+, the default appearance, does not show any item separators.
* +disc+ shows a small circular disc to separate items: image:figu-Component_Reference-toolbar-disc.png[]
* +grid+ shows a grid pattern to separate items: image:figu-Component_Reference-toolbar-grid.png[]
* +line+ shows a vertical line to separate items: image:figu-Component_Reference-toolbar-line.png[]
* +square+ shows a small square to separate items: image:figu-Component_Reference-toolbar-square.png[]


Alternatively, use the [varname]+itemSeparator+ attribute to specify a URL to an image. The image is then used as an item separator. The appearance of the item separator can be additionally customized by using the +itemSeparator+ facet.

[[sect-Component_Reference-toolbar-Grouping_items]]

==== Grouping items

Group together multiple items on the toolbar by using the [sgmltag]+<rich:toolbarGroup>+ child component. Refer to <<sect-Component_Reference-Menus_and_toolbars-toolbarGroup>> for full details on the [sgmltag]+<rich:toolbarGroup>+ component.

[[sect-Component_Reference-toolbar-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Toolbar+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIToolbar+
* [parameter]+component-family+: [classname]+org.richfaces.Toolbar+
* [parameter]+renderer-type+: [classname]+org.richfaces.ToolbarRenderer+


[[sect-Component_Reference-toolbar-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/toolbar.asciidoc[]

[[sect-Component_Reference-Menus_and_toolbars-toolbarGroup]]

==== [sgmltag]+<rich:toolbarGroup>+

The [sgmltag]+<rich:toolbarGroup>+ component is a child component of the [sgmltag]+<rich:toolbar>+ component. The [sgmltag]+<rich:toolbarGroup>+ component is used to group a number of items together on a toolbar.

[[sect-Component_Reference-toolbarGroup-Basic_usage]]

===== Basic usage

Like the [sgmltag]+<rich:toolbar>+ parent component, the [sgmltag]+<rich:toolbarGroup>+ component does not require any extra attributes for basic functionality. Add child components to the [sgmltag]+<rich:toolbarGroup>+ component to have them appear grouped on the parent toolbar when rendered.

[[sect-Component_Reference-toolbarGroup-Appearance]]

===== Appearance

Similar to the [sgmltag]+<rich:toolbar>+ component, items within a [sgmltag]+<rich:toolbarGroup>+ can be separated by specifying the [varname]+itemSeparator+ attribute. Refer to <<sect-Component_Reference-toolbar-Appearance>> for details on using the [varname]+itemSeparator+ attribute.

Groups of toolbar items can be located on either the left-hand side or the right-hand side of the parent toolbar. By default, they appear to the left. To locate the toolbar group to the right of the parent toolbar, set [code]+location="right"+.

[[exam-Component_Reference-toolbarGroup-toolbarGroup]]

.[sgmltag]+<rich:toolbarGroup>+
====


[source, XML]
----
<rich:toolBar height="26" itemSeparator="grid">
   <rich:toolBarGroup>
      <h:graphicImage value="/images/icons/create_doc.gif"/>
      <h:graphicImage value="/images/icons/create_folder.gif"/>
      <h:graphicImage value="/images/icons/copy.gif"/>
   </rich:toolBarGroup>
   <rich:toolBarGroup>
      <h:graphicImage value="/images/icons/save.gif"/>
      <h:graphicImage value="/images/icons/save_as.gif"/>
      <h:graphicImage value="/images/icons/save_all.gif"/>
   </rich:toolBarGroup>
   <rich:toolBarGroup location="right">
      <h:graphicImage value="/images/icons/find.gif"/>
      <h:graphicImage value="/images/icons/filter.gif"/>
   </rich:toolBarGroup>
</rich:toolBar>

----

The example shows how to locate a toolbar group to the right-hand side of the parent toolbar. It also demonstrates how item separators on the parent toolbar work with toolbar groups.

image::figu-Component_Reference-toolbarGroup-toolbarGroup.png[A toolbar using icons. Two toolbar groups are located on the left-hand side of the toolbar and separated by a grid pattern. The third toolbar group is located to the right-hand side.]

====

[[sect-Component_Reference-toolbarGroup-Reference_data]]

===== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.ToolbarGroup+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIToolbarGroup+
* [parameter]+component-family+: [classname]+org.richfaces.Toolbar+
* [parameter]+renderer-type+: [classname]+org.richfaces.ToolbarGroupRenderer+


[[chap-Component_Reference-Output_and_messages]]

== Output and messages

Read this chapter for details on components that display messages and other feedback to the user.

[[sect-Component_Reference-Output_and_messages-message]]

=== [sgmltag]+<rich:chart>+

The [sgmltag]+<rich:chart>+ component allows the user to plot data and to create line, bar or pie charts. It uses up to five children tags [sgmltag]+<rich:chartSeries>+, [sgmltag]+<rich:chartLegend>+, [sgmltag]+<rich:chartXAxis>+, [sgmltag]+<rich:chartYAxis>+ and [sgmltag]+<rich:chartPoint>+. Each child tag customizes a particular aspect of the chart. All are optional except at least one [sgmltag]+<rich:chartSeries>+ tag is required.

Additionally the [sgml]+<rich:chart>+ component allows one to handle events using either a client-side JavaScript or using server-side listeners.

[[figu-Component_Reference-chart-chart_component]]
.rich:chart component
image::figu-Component_Reference-chart-chart_component.png[]


[[sect-Component_Reference-chart-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:chart>+ tag and its optional children tags generate and customize the chart. The chart type is selected by a [sgmltag]+<rich:chartSeries>+ attribute.  The only requirements for use of the [sgmltag]+<rich:chart>+ are selection of the chart type and to pass at least one series of data - explained below.


[[sect-Component_Reference-chart-Data_input]]

==== Data input

The [sgmltag]+<rich:chart>+ component accepts data by two means - by facelet iteration or by creating data model object.

===== Facelet iteration

Use [sgmltag]+<a4j:repeat>+ and a collection of objects inside the [sgmltag]+<rich:chartSeries>+ tag and specify what you want to be plotted on the x and y axis using [sgmltag]+<rich:chartPoint>+ tag. The [sgmltag]+<a4j:repeat>+ approach can also be used at the [sgmltag]+<rich:chartSeries>+ level.

[[exam-Component_Reference-chart_facelet_iteration_example]]

.rich:chart facelet iteration example
====

[source, XML]
----
<rich:chart id="barChart" title="Countries by vehicles per capita">
    <rich:chartSeries type="bar">
        <a4j:repeat value="#{bean.records}" var="record">
            <rich:chartPoint x="#{record.country}" y="#{record.count}"/>
        </a4j:repeat>
    </rich:chartSeries>
    <rich:chartYAxis label="Motor vehicles per 1000 people"/>
</rich:chart>

----

====

===== Create a DataModel object
When facelet iteration is used the ChartDataModel object is created by the ChartRenderer. An alternative to this is to create a ChartDataModel yourself and pass it using [sgmltag]+<rich:chartSeries>+ data attribute. To do this, create an instance of one of the child classes of ChartDataModel - NumberChartDataModel, StringChartDataModel or DateChartDataModel (not yet fully supported). Select the class according to the data type used on the x-axis. Add values to the model using the put method and pass it to the [sgmltag]+<rich:chartSeries>+ tag using the data attribute.

[[exam-Component_Reference-chart_datamodel_object_example]]

.rich:chart DataModel object example
====

[source, XML]
----
<rich:chart id="barChart" title="Countries by vehicles per capita">
   <rich:chartSeries type="bar" data="#{bean.cars}"/>
   <rich:chartYAxis label="Motor vehicles per 1000 people"/>
</rich:chart>

----

[source,Java]
----
cars = new StringChartDataModel(ChartDataModel.ChartType.bar);
cars.put("San Marino", 1263);
cars.put("United States", 797);
...

----

====


If there is a model passed using the [sgmltag]+<rich:chartSeries>+ data attribute, any nested [sgmltag]+<rich:chartPoint>+ tags are ignored. If the data attribute is not used, then nested [sgmltag]+<rich:chartPoint>+ tags are expected.

[[sect-Component_Reference-chart-Look_customization]]

==== Chart look customization

The chart configuration is split into multiple tags providing a clearer facelet API. To configure axes, their min/max values, and label use [sgmltag]+<rich:chartXAxis>+ or [sgmltag]+<rich:chartYAxis>+ tag. The [sgmltag]+<rich:chartLegend>+ allows one to set up the position of the legend and the order of the labels within it.

To adjust the chart component size you can use CSS class .richfaces-chart-container, to customize title use .richfaces-chart-title the placeholder. The chart itself is placed in the div with the CSS class +.richfaces-chart+.

[[sect-Component_Reference-chart-Advanced_customization]]

==== Advanced customization

The [sgmltag]+<rich:chart>+ can also be customized directly through JavaScript to allow the use of plugins or objects that are not directly supported by the component.

There are two ways to define the customization: the [parameter]+hooks+ attribute or a facet named [parameter]+hooks+. The facet takes precedence over attribute when both are defined.

[source, XML]
----
<h:outputScript>
    var hooks = {
        processOptions: [function(plot,options) {
                options.xaxes[0].tickFormatter = function (value, axis) {
                    return value.toLocaleString('en-US', {minimumFractionDigits: 2});
                };
        }]
    };
</h:outputScript>
<rich:chart hooks="hooks" />

<rich:chart>
    <f:facet name="hooks">
        {
            processOptions: [function(plot,options) {
                    options.xaxes[0].tickFormatter = function (value, axis) {
                        return value.toLocaleString('en-US', {minimumFractionDigits: 2});
                    };
            }]
        }
    </f:facet>
</rich:chart>
----

In the above samples, the [sgmltag]+<rich:chart>+ is configured to display the label on x-axis according to US locale (e.g. 45,324.23).

[NOTE]
====

For further configuration options, refer to link:$$https://github.com/flot/flot/blob/master/API.md#hooks$$[Flot API - Hooks] and link:$$https://github.com/flot/flot/blob/master/API.md#plugins$$[Flot API - Plugins].

====

[[sect-Component_Reference-chart-Interactivity_options]]

==== Interactivity options

The [sgmltag]+<rich:chart>+ component does not only create static charts.

* It allows the user to zoom line charts when the [sgmltag]+<rich:chart>+ attribute zoom is set true. To reset zoom you can use the JavaScript API.
* You can also add functions to handle events fired by components. Event handlers are set up using proper [sgmltag]+<rich:chart>+ attributes. They handle events fired by any series. If you want to handle an event only fired by a particular series, set up handlers using the [sgmltag]+<rich:chartSeries>+ attributes.

[[sect-Component_Reference-chart-chart_server-side_events]]

==== [sgmltag]+<rich:chart>+ server-side events

* The [varname]+PlotClickEvent+ is fired when the user clicks a point in the chart. To set a listener use the [varname]+ClickListener+ attribute.

[[sect-Component_Reference-chart-chart_client-side_events]]

==== [sgmltag]+<rich:chart>+ client-side events

* The [varname]+plothover+ event points to the client-side function to execute when the mouse cursor is over the chart point.
* The [varname]+plotclick+ event points to the client-side function to execute when the user clicks the chart point.
* The [varname]+mouseout+ event points to the cient-side function to execute when the mouse cursor leaves the chart grid.

The plothover and plotclick handlers are given an event-object that contains the deatils of which point fired the event.

[source, JavaScript]
----
function log(e){
           	console.log("Series index: "+
                 	e.data.seriesIndex +" DataIndex: "+
                 	e.data.dataIndex+' ['+e.data.x+','+e.data.y+']');
}
----

==== JavaScript API

To access the jQuery widget of the component, use the componentID + chart

[function]+resetZoom()+::  display chart without scaling
[function]+getPlotObject()+:: returns JavaScript object containing chart data and options

Example
[source, XML]
----
<rich:chart id="priceChart">
----

[source, JavaScript]
----
$(document.getElementById("priceChart")).chart("resetZoom")
----

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Chart+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIChart+
* [parameter]+component-family+: [classname]+org.richfaces.Chart+
* [parameter]+renderer-type+: [classname]+org.richfaces.ChartRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.ChartTagHandler+


=== [sgmltag]+<rich:message>+

The [sgmltag]+<rich:message>+ component renders a single [classname]+FacesMessage+ message instance added for the component. The appearance of the message can be customized, and tool-tips can be used for further information about the message.

The [sgmltag]+<rich:message>+ component is rendered in the same way as the standard [sgmltag]+<h:message>+ component, but allows separate styling of the message summary and detail. It allows unified icons to be set using background images in predefined classes.

[[figu-Component_Reference-message-message_component]]
.rich:message component
image::figu-Component_Reference-message-message_component.png[]


[[sect-Component_Reference-message-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:message>+ component needs the [varname]+for+ attribute to point to the [varname]+id+ identifier of the related component. The message is displayed after the [classname]+FacesMessage+ message instance is created and added for the client identifier of the related component.

The [sgmltag]+<rich:message>+ component is automatically rendered after an Ajax request. This occurs without the use of an [sgmltag]+<a4j:outputPanel>+ component or a specific reference through the [varname]+render+ attribute of the Ajax request source.

[[exam-Component_Reference-message-message_example]]

.rich:message example
====


[source, XML]
----
<h:outputText value="Zip:" />
<h:inputText label="Zip" id="zip" required="true"
             value="#{userBean.zip}">
   <f:validateLength minimum="4" maximum="9" />
</h:inputText>
<rich:message for="zip" ajaxRendered="true"/>

----

The example contains a text input for zip codes. The simple validation requires the entered zip code to be between 4 and 9 characters long. The [sgmltag]+<rich:message>+ component references the input box, and reports any messages relating to the input validation.

====

[[sect-Component_Reference-message-Appearance]]

==== Appearance

The [varname]+showSummary+ attribute specifies whether to display only a summary of the full message. The full message can be displayed in a tool-tip when hovering the mouse over the summary.

Use CSS (Cascading Style Sheets) to customize the appearance and icon for the [sgmltag]+<rich:message>+ component. To use a custom icon, set the [property]+background-image+ property to the icon graphic, as shown in <<exam-Component_Reference-message-Message_icons>>. Refer to <<sect-Component_Reference-message-Style_classes_and_skin_parameters>> for a complete list of style classes for the [sgmltag]+<rich:message>+ component.

[[exam-Component_Reference-message-Message_icons]]

.Message icons
====

----
.rf-msg-err{
   background-image: url('#{facesContext.externalContext.requestContextPath}/images/icons/error.gif');
}

----

The example demonstrates how an icon for an error message could be added using CSS.

====

[[sect-Component_Reference-message-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Message+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlMessage+
* [parameter]+component-family+: [classname]+javax.faces.Message+
* [parameter]+renderer-type+: [classname]+org.richfaces.MessageRenderer+


[[sect-Component_Reference-message-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/message.asciidoc[]

[[sect-Component_Reference-Output_and_messages-messages]]

=== [sgmltag]+<rich:messages>+

The [sgmltag]+<rich:messages>+ components works similarly to the [sgmltag]+<rich:message>+ component, but can display all the validation messages added for the current view instead of just a single message. Refer to <<sect-Component_Reference-Output_and_messages-message>> for details on the [sgmltag]+<rich:message>+ component.

[[figu-Component_Reference-messages-messages_component]]
.rich:messages component
image::figu-Component_Reference-messages-messages_component.png[]


[[sect-Component_Reference-messages-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:messages>+ component doesn't require any extra attributes for basic usage. It displays all messages relating to requests from components.

To limit the messages to a specific component, use the [varname]+for+ attribute to reference the component's identifier.

To show only those messages that are not attached to specific components, set [code]+globalOnly="true"+.

The [sgmltag]+<rich:messages>+ component is automatically rendered after an Ajax request. This occurs without the use of an [sgmltag]+<a4j:outputPanel>+ component or a specific reference through the [varname]+render+ attribute of the Ajax request source.

[[sect-Component_Reference-messages-Appearance]]

==== Appearance

The [sgmltag]+<rich:messages>+ component displays error messages for each validating component in the same container.

The [sgmltag]+<rich:messages>+ component can be further styled through CSS, the same as for the [sgmltag]+<rich:message>+ component. Refer to <<sect-Component_Reference-message-Appearance>> for an example of message styling, and refer to <<sect-Component_Reference-messages-Style_classes_and_skin_parameters>> for a complete list of style classes for the [sgmltag]+<rich:message>+ component.

The layout of the messages can also be customized through CSS. By default, the messages are arranged in a block as shown in <<figu-Component_Reference-messages-Messages_in_a_block>>.

[[figu-Component_Reference-messages-Messages_in_a_block]]
.Messages in a block
image::figu-Component_Reference-messages-Messages_in_a_block.png[]


Override the [property]+display+ property for all CSS message classes to customize the layout as follows:

Display messages in a list with no icons:: To display the messages in a list format without the default icons, override the message styles as follows:
----
.rf-msg-err, .rf-msgs-err, .rf-msg-ftl, .rf-msgs-ftl, .rf-msg-inf,
.rf-msgs-inf, .rf-msg-wrn, .rf-msgs-wrn, .rf-msg-ok, .rf-msgs-ok {
   display: list-item;
   margin-left: 20px;
   padding-left: 0px; }

.rf-msg-err, .rf-msgs-err{ background-image:none; }

----

[[figu-Component_Reference-messages-Messages_in_a_list]]
.Messages in a list
image::figu-Component_Reference-messages-Messages_in_a_list.png[]


Display in-line messages:: To display the messages in line with text, override the message styles as follows:
----
.rf-msg-err, .rf-msgs-err, .rf-msg-ftl, .rf-msgs-ftl, .rf-msg-inf,
.rf-msgs-inf, .rf-msg-wrn, .rf-msgs-wrn, .rf-msg-ok, .rf-msgs-ok { display:inline; }

----

[[figu-Component_Reference-messages-In-line_messages]]
.In-line messages
image::figu-Component_Reference-messages-In-line_messages.png[]


[[sect-Component_Reference-messages-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Messages+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlMessages+
* [parameter]+component-family+: [classname]+javax.faces.Messages+
* [parameter]+renderer-type+: [classname]+org.richfaces.MessagesRenderer+


[[sect-Component_Reference-messages-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/messages.asciidoc[]

[[sect-Component_Reference-Output_and_messages-notify]]

=== [sgmltag]+<rich:notify>+

The [sgmltag]+<rich:notify>+ component serves for advanced user interaction, using notification boxes to give the user instant feedback on what's happening within the application. Each time this component is rendered, a floating notification box is displayed in the selected corner of the browser screen.

[[sect-Component_Reference-notify-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:notify>+ has two message customization attributes: [parameter]+summary+ is short text summarizing the message, while [parameter]+detail+ configures the detailed body of the message. Both attributes have their counterparts in form of facets with the same names as the corresponding attributes.

[[sect-Component_Reference-notify-Customizing_notifications]]

==== Customizing notifications

A notification appears on the page each time it is rendered, either on full-page or ajax requests. The notification remains on the screen for 8 seconds and then disappears. Users can close the notification with the close button in the top-right corner of the notification.

Notification stacks can be used to create sequences. For customization of stacking see the [sgmltag]+<rich:notifyStack>+ component.

There are several attributes that can change default behavior:

* [parameter]+sticky+: notifications does not disappear automatically, they needs to be closed explicitly with close button (this attribute can't be used together with [parameter]+nonblocking+ and [parameter]+stayTime+)
* [parameter]+stayTime+: configures how long notification stays on the screen before it disappears (in miliseconds)
* [parameter]+styleClass+: defines the class customizing the notification
* [parameter]+nonblocking+: defines notifications which becomes partially transparent and user can click through. Non-blocking notifications don't have close button.
* [parameter]+nonblockingOpacity+: defines opacity of nonblocking notifications when mouse hovers over notification (decimal number between 0 and 1)
* [parameter]+showShadow+: defines whether shadow will be displayed under the notification


[NOTE]
====

Nonblocking notifications can be clicked through, but because they are using jQuery mechanism to bypass events, only jQuery event handlers are triggered. IThis means that standard links won't be triggered.

====

[[sect-Component_Reference-notify-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Notify+
* [parameter]+component-class+: [classname]+org.richfaces.component.UINotify+
* [parameter]+component-family+: [classname]+org.richfaces.Notify+
* [parameter]+renderer-type+: [classname]+org.richfaces.NotifyRenderer+


[[sect-Component_Reference-notify-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

Note that skinning is common for [sgmltag]+<rich:notify>+, [sgmltag]+<rich:notifyMessage>+ and [sgmltag]+<rich:notifyMessages>+

include::skinning/notify.asciidoc[]

[[sect-Component_Reference-Output_and_messages-notifyMessage]]

=== [sgmltag]+<rich:notifyMessage>+

[[sect-Component_Reference-notifyMessage-Basic_usage]]

==== Basic usage

The [sgmltag]+<rich:notifyMessage>+ component is built on top of [sgmltag]+<rich:notify>+, the difference is in usage. The [sgmltag]+<rich:notifyMessage>+ component displays [code]++FacesMessage++ s associated with a given component, similar to [sgmltag]+<rich:message>+: one notification is displayed for first [code]+FacesMessage+ in the stack that is risen either programatically or during conversion/validation of the component. The severity of the message determines the color and icon of the resulting notification.

For customization of notification behavior, please refer to <<sect-Component_Reference-notify-Customizing_notifications,Customizing notifications>> of [sgmltag]+<rich:notify>+.

[[sect-Component_Reference-notifyMessage-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.NotifyMessage+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlNotifyMessage+
* [parameter]+component-family+: [classname]+javax.faces.Message+
* [parameter]+renderer-type+: [classname]+org.richfaces.NotifyMessageRenderer+


[[sect-Component_Reference-notifyMessage-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

Note that [sgmltag]+<rich:notifyMessage>+ shares common classes with [sgmltag]+<rich:notify>+, since there is exactly one notification rendered for each JSF message.

The [sgmltag]+<rich:notifyMessage>+ specific classes are redefining the look for various message severity levels.

include::skinning/notifyMessage.asciidoc[]

[[sect-Component_Reference-Output_and_messages-notifyMessages]]

=== [sgmltag]+<rich:notifyMessages>+

The [sgmltag]+<rich:notifyMessages>+ component is the same as the [sgmltag]+<rich:notifyMessage>+ component, but each of the available messages generates one notification.

[sgmltag]+<rich:notifyMessages>+ shares the same set of attributes with [sgmltag]+<rich:notifyMessage>+

[[figu-Component_Reference-notifyMessages-notifyMessages]]
image::figu-Component_Reference-notifyMessages-notifyMessages.png[width="200"]


[[sect-Component_Reference-notifyMessages-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.NotifyMessages+
* [parameter]+component-class+: [classname]+org.richfaces.component.html.HtmlNotifyMessages+
* [parameter]+component-family+: [classname]+javax.faces.Messages+
* [parameter]+renderer-type+: [classname]+org.richfaces.NotifyMessagesRenderer+


[[sect-Component_Reference-notifyMessages-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

[sgmltag]+<rich:notifyMessages>+ shares style classes with [sgmltag]+<rich:notifyMessage>+.

[[sect-Component_Reference-Output_and_messages-notifyStack]]

=== [sgmltag]+<rich:notifyStack>+

Notifications emited by [sgmltag]+<rich:notify>+, [sgmltag]+<rich:notifyMessage>+ and [sgmltag]+<rich:notifyMessages>+ are displayed in top-right corner of the screen by default.

It is [sgmltag]+<rich:notifyStack>+ which defines where messages will appear and handles their stacking.

Stack also provides way how to remove messages from screen - when stack is re-rendered, current notifications are destroyed, freeing place for new notifications.

[[sect-Component_Reference-notifyStack-Basic_usage]]

==== Basic usage

They are three alternative ways to bind notifications with a stack:

* _wrapping_: nesting [sgmltag]+<rich:notify>+, [sgmltag]+<rich:notifyMessage>+ or [sgmltag]+<rich:notifyMessages>+ binds notifications with the stack in which they are wrapped
* _binding by id_: notification can be bound directly to a stack using it's [code]+componentId+ in the [parameter]+stack+ attribute
* _using default stack_: a default stack is used when no other binding is defined for a given notification



[source, XML]
----
<rich:notifyStack position="bottomRight">
    <rich:notifyMessages />
</rich:notifyStack>
----

The sample above defines the stack explicitly, where notifications use the stack in which they are wrapped.

The sample bellow uses a notification rendered into the top-left corner of the screen. The notification is bound to a stack using it's id.


[source, XML]
----
<rich:notifyStack id="leftStack" position="topLeft" />

<rich:notify stack="leftStack" />
----

[[sect-Component_Reference-notifyStack-Positioning_notifications]]

==== Positioning notifications

To redefine the position of a notification, one needs to define a stack and bind it with the given notification.

[sgmltag]+<rich:notifyStack>+ uses the [parameter]+position+ attribute to place the stack and it's notifications into one of four corners: [code]+topRight+ (default), [code]+bottomRight+, [code]+bottomLeft+, [code]+topLeft+.

[[sect-Component_Reference-notifyStack-Stacking_notifications]]

==== Stacking notifications

There are two attributes which influences how notifications are placed into a stack:

* [parameter]+method+: defines where new notifications are placed and how they are removed. Options: [code]+first+ (default), [code]+last+.
[parameter]+direction+: defines in which direction will be messages stacked. Options: [code]+vertical+ (default), [code]+horizontal+


The following sample shows a stack which will place new notifications up front - the incoming message will appear first, causing all notifications currently in stack to shift. Subsequently, messages at the end of stack will be then removed.


[source, XML]
----
<rich:notifyStack method="first" />
----

On the other hand, stacking method [code]+last+ provides a method to place messages on the end of the stack, and when removing a notification, it is removed from the start, causing all other notifications to shift.

[[sect-Component_Reference-notifyStack-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.NotifyStack+
* [parameter]+component-class+: [classname]+org.richfaces.component.UINotifyStack+
* [parameter]+component-family+: [classname]+org.richfaces.NotifyStack+
* [parameter]+renderer-type+: [classname]+org.richfaces.NotifyStackRenderer+


[[sect-Component_Reference-notifyStack-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/notifyStack.asciidoc[]

[[sect-Component_Reference-Output_and_messages-progressBar]]

=== [sgmltag]+<rich:progressBar>+

The [sgmltag]+<rich:progressBar>+ component displays a progress bar to indicate the status of a process to the user. It can update either through Ajax or on the client side, and the look and feel can be fully customized.

[[figu-Component_Reference-progressBar-progressBar]]
.[sgmltag]+<rich:progressBar>+
image::figu-Component_Reference-progressBar-progressBar.png[]


[[sect-Component_Reference-progressBar-Basic_usage]]

==== Basic usage

Basic usage of the [sgmltag]+<rich:progressBar>+ component requires the [varname]+value+ attribute, which points to the property that holds the current progress value. When the value is greater than or equal to the minimum value ( +0+ by default), the progress bar becomes active, and starts sending Ajax requests if in +ajax+ mode.

[[exam-Component_Reference-progressBar-Basic_usage]]

.Basic usage
====


[source, XML]
----
<rich:progressBar value="#{bean.incValue}" />

----

====

[[sect-Component_Reference-progressBar-Customizing_the_appearance]]

==== Customizing the appearance

By default, the minimum value of the progress bar is +0+ and the maximum value of the progress bar is +100+. These values can be customized using the [varname]+minValue+ and [varname]+maxValue+ attributes respectively.

The progress bar can be labeled in one of two ways:

Using the [varname]+label+  attribute:: The content of the [varname]+label+ attribute is displayed over the progress bar.
[[exam-Component_Reference-progressBar-Using_the_label_attribute]]

.Using the [varname]+label+ attribute
====


[source, XML]
----
<rich:progressBar value="#{bean.incValue}" id="progrs" label="#{bean.incValue} % complete"/>

----

====

Using nested child components:: Child components, such as the JSF [sgmltag]+<h:outputText>+ component, can be nested in the [sgmltag]+<rich:progressBar>+ component to display over the progress bar.
[[exam-Component_Reference-progressBar-Using_nested_child_components]]

.Using nested child components
====


[source, XML]
----
<rich:progressBar value="#{bean.incValue}">
    <h:outputText value="#{bean.incValue} % complete"/>
</rich:progressBar>

----

====

Define the +initial+ and +finish+ facets to customize the progress bar's appearance before progress has started and after progress has finished. When the current progress bar value is less than the minimum value, the +initial+ facet is displayed. When the current progress bar is greater than the maximum value, the +finish+ facet is displayed.

[[exam-Component_Reference-progressBar-Initial_and_complete_states]]

.Initial and finished states
====


[source, XML]
----
<rich:progressBar value="#{bean.incValue1}">
    <f:facet name="initial">
        <h:outputText value="Process has not started"/>
    </f:facet>
    <f:facet name="finish">
        <h:outputText value="Process has completed"/>
    </f:facet>
</rich:progressBar>

----

====

[[sect-Component_Reference-progressBar-Update_mode]]

==== Update mode

The mode for updating the progress bar is determined by the [varname]+mode+ attribute, which can have one of the following values:

+ajax+:: The progress bar updates in the same way as the [sgmltag]+<a4j:poll>+ component. The [sgmltag]+<rich:progressBar>+ component repeatedly polls the server for the current progress value.
+client+:: The progress bar must be explicitly updated on the client side through the JavaScript API.
[[sect-Component_Reference-progressBar-Using_set_intervals]]

==== Using set intervals

The [sgmltag]+<rich:progressBar>+ component can be set to constantly poll for updates at a constant interval. Use the [varname]+interval+ component to set the interval in milliseconds. The progress bar is updated whenever the polled value changes. Polling is only active when the [varname]+enabled+ attribute is set to +true+.

[[exam-Component_Reference-progressBar-Using_set_intervals]]

.Using set intervals
====


[source, XML]
----
<rich:progressBar value="#{bean.incValue1}" id="progress" interval="900" enabled="#{bean.enabled1}"/>

----

====

[[sect-Component_Reference-progressBar-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:progressBar>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+getValue()+:: Return the current value displayed on the progress bar.
[function]+setValue()+:: Set the current value to display on the progress bar.
[function]+getMinValue()+:: Return the minimum value for the progress bar.
[function]+getMaxValue()+:: Return the maximum value for the progress bar.
[function]+disable()+:: Disables the progress bar.
[function]+enable()+:: Enables the progress bar.
[function]+isEnabled()+:: Returns a boolean value indicating whether the progress bar is enabled.
[[sect-Component_Reference-progressBar-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.ProgressBar+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIProgressBar+
* [parameter]+component-family+: [classname]+org.richfaces.ProgressBar+
* [parameter]+renderer-type+: [classname]+org.richfaces.ProgressBarRenderer+


[[sect-Component_Reference-progressBar-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/progressBar.asciidoc[]

[[sect-Component_Reference-Output_and_messages-tooltip]]

=== [sgmltag]+<rich:tooltip>+

The [sgmltag]+<rich:tooltip>+ component provides an informational tool-tip. The tool-tip can be attached to any control and is displayed when hovering the mouse cursor over the control.

[[figu-Component_Reference-tooltip-tooltip]]
.[sgmltag]+<rich:tooltip>+
image::figu-Component_Reference-toolTip-toolTip.png[]


[[sect-Component_Reference-tooltip-Basic_usage]]

==== Basic usage

For basic usage, define the tool-tip text using the [varname]+value+ attribute. The [sgmltag]+<rich:tooltip>+ component is then automatically attached to the parent element, and is usually shown when the mouse cursor hovers.

Alternatively, the content of the tool-tip can be defined inside the [sgmltag]+<rich:tooltip>+ tags, and the [varname]+value+ attribute is not used. This allows HTML tags to be used to define the content, and provides for rich content such as images, links, buttons, and other RichFaces components.

[[exam-Component_Reference-tooltip-Defining_tool-tip_content]]

.Defining tool-tip content
====

Basic content::
[source, XML]
----
<rich:panel>
    <rich:tooltip value="This is a tool-tip."/>
</rich:panel>

----

Rich content::
[source, XML]
----
<rich:panel>
    <rich:tooltip>
        This is a <b>tool-tip</b>.
    </rich:tooltip>
</rich:panel>

----

====

[[sect-Component_Reference-tooltip-Attaching_the_tool-tip_to_another_component]]

==== Attaching the tool-tip to another component

If not otherwise specified, the tool-tip is attached to the parent element in which it is defined. The [varname]+target+ attribute is used to attach the tool-tip to another component, pointing to the target component's [varname]+id+ identifier. This allows the [sgmltag]+<rich:tooltip>+ component to be specified outside the target element. This approach is demonstrated in <<exam-Component_Reference-tooltip-Attaching_the_tool-tip>>.

[[exam-Component_Reference-tooltip-Attaching_the_tool-tip]]

.Attaching the tool-tip
====


[source, XML]
----
<rich:panel id="panelId">
...
</rich:panel>

<rich:tooltip value="This is a tool-tip." target="panelId"/>

----

====

The [sgmltag]+<rich:tooltip>+ component can alternatively be left unattached, and is instead invoked through an event handler on the target component. To leave the [sgmltag]+<rich:tooltip>+ component unattached, set [code]+attached="false"+, and define the event handler to trigger the tool-tip on the target component. This approach is demonstrated in <<exam-Component_Reference-tooltip-Unattached_tool-tips>>. When leaving the [sgmltag]+<rich:tooltip>+ component unattached, ensure it has an [varname]+id+ identifier defined. If it is defined outside the target element, it must be nested in an [sgmltag]+<h:form>+ component.

[[exam-Component_Reference-tooltip-Unattached_tool-tips]]

.Unattached tool-tips
====


[source, XML]
----
<rich:panel id="panelId" onclick="#{rich:component('tooltipId')}.show(event);" />

<h:form>
    <rich:tooltip id="toolTipId" attached="false" value="This is a tool-tip."/>
</h:form>

----

====

[[sect-Component_Reference-tooltip-Appearance]]

==== Appearance

By default, the [sgmltag]+<rich:tooltip>+ component is positioned intelligently based on the position of the mouse cursor. Use the [varname]+jointPoint+ attribute to specify a corner of the target component at which to display the tool-tip instead, and use the [varname]+direction+ attribute to specify the direction the tool-tip will appear relative to that corner. Possible values for both attributes are:  +auto+, +autoLeft+, +autoRight+, +bottomAuto+, +bottomLeft+, +bottomRight+, +topAuto+, +topLeft+, +topRight+. Use the [varname]+horizontalOffset+ and [varname]+verticalOffset+ attributes to specify the horizontal offset and vertical offset at which to display the tool-tip.

Use the [varname]+showEvent+ attribute to specify when the tool-tip is shown. By default it appears when the attached component is hovered-over with the mouse. Use the [varname]+hideEvent+ attribute to specify when the tool-tip is hidden. The default value is +none+, so the tool-tip remains shown. However, it can be linked to an event on the target component, such as the +mouseout+ event.

Set [code]+followMouse="true"+ to cause the tool-tip to follow the user's mouse movements.

Advanced appearance features are demonstrated in <<exam-Component_Reference-tooltip-Advanced_tool-tip_usage>>.

[[sect-Component_Reference-tooltip-Update_mode]]

==== Update mode

The mode for updating the tool-tip is determined by the [varname]+mode+ attribute, which can have one of the following values:

+ajax+:: The tool-tip content is requested from the server with every activation.
+client+:: The tool-tip content is rendered once on the server. An external submit causes the content to re-render.

When using [code]+mode="ajax"+, define the +loading+ facet. The tool-tip displays the content of the +loading+ facet while loading the actual content from the server.

[[exam-Component_Reference-tooltip-Advanced_tool-tip_usage]]

.Advanced tool-tip usage
====


[source, XML]
----
<h:commandLink value="Simple Link" id="link">
    <rich:tooltip followMouse="true" direction="topRight" mode="ajax" value="#{bean.toolTipContent}"
                  horizontalOffset="5" verticalOffset="5" layout="block">
        <f:facet name="loading">
            <f:verbatim>Loading...</f:verbatim>
        </f:facet>
    </rich:tooltip>
</h:commandLink>

----

====

[[sect-Component_Reference-tooltip-tooltip_client-side_events]]

==== [sgmltag]+<rich:tooltip>+ client-side events

The [sgmltag]+<rich:tooltip>+ component supports the following client-side events:

+click+:: This event is activated when the tool-tip is clicked with the mouse.
+dblclick+:: This event is activated when the tool-tip is double-clicked with the mouse.
+mouseout+:: This event is activated when the mouse cursor leaves the tool-tip.
+mousemove+:: This event is activated when the mouse cursor moves over the tool-tip.
+mouseover+:: This event is activated when the mouse cursor hovers over the tool-tip.
+show+:: This event is activated when the tool-tip is shown.
+complete+:: This event is activated when the tool-tip is completed.
+hide+:: This event is activated when the tool-tip is hidden.
[[sect-Component_Reference-tooltip-JavaScript_API]]

==== JavaScript API

The [sgmltag]+<rich:tooltip>+ component can be controlled through the JavaScript API. The JavaScript API provides the following functions:

[function]+show(event)+:: Show the tool-tip.
[function]+hide()+:: Hide the tool-tip.
[[sect-Component_Reference-tooltip-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Tooltip+
* [parameter]+component-class+: [classname]+org.richfaces.component.UITooltip+
* [parameter]+component-family+: [classname]+org.richfaces.Tooltip+
* [parameter]+renderer-type+: [classname]+org.richfaces.TooltipRenderer+


[[sect-Component_Reference-tooltip-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/tooltip.asciidoc[]

[[chap-Component_Reference-Drag_and_drop]]

== Drag and drop

Read this chapter for details on adding drag and drop support to controls.

[[sect-Component_Reference-Drag_and_drop-dragSource]]

=== [sgmltag]+<rich:dragSource>+

The [sgmltag]+<rich:dragSource>+ component can be added to a component to indicate it is capable of being dragged by the user. The dragged item can then be dropped into a compatible drop area, designated using the [sgmltag]+<rich:dropTarget>+ component.

[[sect-Component_Reference-dragSource-Basic_usage]]

==== Basic usage

To add drag support to a component, attach the [sgmltag]+<rich:dragSource>+ component as a child element.

The [varname]+type+ attribute must be specified, and can be any identifying string. Dragged items can only be dropped in drop zones where the [varname]+type+ attribute of the [sgmltag]+<rich:dragSource>+ component is listed in the [varname]+acceptedTypes+ attribute of the [sgmltag]+<rich:dropTarget>+ component.

[[sect-Component_Reference-dragSource-Dragging_an_object]]

==== Dragging an object

Use the [varname]+dragIndicator+ parameter to customize the appearance of a dragged object while it is being dragged. The [varname]+dragIndicator+ parameter must point to the [varname]+id+ identifier of a [sgmltag]+<rich:dragIndicator>+ component. If the [varname]+dragIndicator+ attribute is not defined, the drag indicator appears as a clone of the [sgmltag]+<rich:dragSource>+ component's parent control.

To bind data to the dragged object, use the [varname]+dragValue+ attribute. The [varname]+dragValue+ attribute specifies a server-side object, which is then bound to the parent component when it is dragged. This facilitates handling event data during a drop event.

===== DragIndicator customization

Use the [varname]+dragOptions+ parameter to further customize the appearance and behavior of the dragIndicator.

[source, XML]
----
<h:outputScript>
    opts = {
        helper: function () {
            return $("#indicator").clone();
        },
        cursorAt: {
            left: 5,
            top: 5
        }
    }
</h:outputScript>

<rich:dragSource dragOptions="opts" />
----

For full list of options see the link:$$http://api.jqueryui.com/draggable/$$[jQuery.draggable documentation].

[[sect-Component_Reference-dragSource-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DragSource+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDragSource+
* [parameter]+component-family+: [classname]+org.richfaces.DragSource+
* [parameter]+renderer-type+: [classname]+org.richfaces.DragSourceRenderer+


[[sect-Component_Reference-Drag_and_drop-dropTarget]]

=== [sgmltag]+<rich:dropTarget>+

The [sgmltag]+<rich:dropTarget>+ component can be added to a component so that the component can accept dragged items. The dragged items must be defined with a compatible drop type for the [sgmltag]+<rich:dragSource>+ component.

[[sect-Component_Reference-dropTarget-Basic_usage]]

==== Basic usage

To allow dragged items to be dropped on a component, attach the [sgmltag]+<rich:dropTarget>+ component as a child element to the component.

The [varname]+acceptedTypes+ attribute must be specified. The [varname]+acceptedTypes+ attribute is a comma-separated list of strings that match the types of dragged items. Dragged items can only be dropped in drop zones where the [varname]+type+ attribute of the [sgmltag]+<rich:dragSource>+ component is listed in the [varname]+acceptedTypes+ attribute of the [sgmltag]+<rich:dropTarget>+ component.

The [varname]+acceptedTypes+ attribute can optionally be set to either +@none+ or +@all+. If set to +@none+, the component will not accept any type of dropped object. If set to +@all+, the component accepts all dropped objects. If the [varname]+acceptedTypes+ attribute is not specified, the default value is +null+, which is the same as a +@none+ setting.

[[sect-Component_Reference-dropTarget-Handling_dropped_data]]

==== Handling dropped data

To provide additional parameters for the server-side drop event, use the [varname]+dropValue+ attribute.

The [sgmltag]+<rich:dropTarget>+ component raises the [varname]+DropEvent+ server-side event when an object is dropped. The event uses the following parameters:

* The [parameter]+dragSource+ identifies the component being dragged (the parent of the [sgmltag]+<rich:dragSource>+ component).
* The [parameter]+dragValue+ parameter is the content of the [sgmltag]+<rich:dragSource>+ component's [varname]+dragValue+ attribute.
* The [parameter]+dropValue+ parameter is the content of the [sgmltag]+<rich:dropTarget>+ component's [varname]+dropValue+ attribute.


[[sect-Component_Reference-dropTarget-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DropTarget+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDropTarget+
* [parameter]+component-family+: [classname]+org.richfaces.DropTarget+
* [parameter]+renderer-type+: [classname]+org.richfaces.DropTargetRenderer+
* [parameter]+handler-class+: [classname]+org.richfaces.view.facelets.DropHandler+


[[sect-Component_Reference-dropTarget-Style_classes]]

==== Style classes

include::skinning/dropTarget.asciidoc[]

[[sect-Component_Reference-Drag_and_drop-dragIndicator]]

=== [sgmltag]+<rich:dragIndicator>+

The [sgmltag]+<rich:dragIndicator>+ component defines a graphical element to display under the mouse cursor during a drag-and-drop operation.

[[sect-Component_Reference-dragIndicator-Basic_usage]]

==== Basic usage

To use a drag indicator, define the inner content that appears during a drag event. No additional attributes are required. If a drag indicator is not used, a clone of the drag source is used instead.

[[sect-Component_Reference-dragIndicator-Styling_the_indicator]]

==== Styling the indicator

The drag indicator can be styled depending on the current state of the dragged element. There are three attributes for different states. The attributes reference the CSS class to use for styling the drag indicator when the dragged element is in the relevant state.

[varname]+acceptClass+:: The [varname]+acceptClass+ attribute specifies the style when the dragged element is over an acceptable drop target. It indicates that the [varname]+type+ attribute of the element's [sgmltag]+<rich:dragSource>+ component matches [varname]+acceptedTypes+ attribute of the drop target's [sgmltag]+<rich:dropTarget>+ component.
[varname]+rejectClass+:: The [varname]+rejectClass+ attribute specifies the style when the dragged element is over a drop target that is not acceptable. It indicates that the [varname]+type+ attribute of the element's [sgmltag]+<rich:dragSource>+ component is not found in the [varname]+acceptedTypes+ attribute of the drop target's [sgmltag]+<rich:dropTarget>+ component.
[varname]+draggingClass+:: The [varname]+draggingClass+ attribute specifies the style when the dragged element is being dragged. It indicates that the dragged element is not over a drop target.
[[sect-Component_Reference-dragIndicator-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.DragIndicator+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIDragIndicator+
* [parameter]+component-family+: [classname]+org.richfaces.DragIndicator+
* [parameter]+renderer-type+: [classname]+org.richfaces.DragIndicatorRenderer+


[[sect-Component_Reference-dragIndicator-Style_classes]]

==== Style classes

include::skinning/dragIndicator.asciidoc[]

[[chap-Component_Reference-Layout_and_appearance]]

== Layout and appearance

Read this chapter to alter the layout and appearance of web applications using special components.

[[sect-Component_Reference-Layout_and_appearance-jQuery]]

=== [sgmltag]+<rich:jQuery>+

The [sgmltag]+<rich:jQuery>+ component applies styles and custom behavior to both [acronym]#JSF# (JavaServer Faces) objects and regular [acronym]#DOM# (Document Object Model) objects. It uses the jQueryJavaScript framework to add functionality to web applications.

[[sect-Component_Reference-jQuery-Basic_usage]]

==== Basic usage

The query triggered by the [sgmltag]+<rich:jQuery>+ component is specified using the [varname]+query+ attribute.

With the query defined, the component is used to trigger the query as either a timed queryor a named query. The query can be bound to an event to act as an event handler. These different approaches are covered in the following sections.

[[sect-Component_Reference-jQuery-Defining_a_selector]]

==== Defining a selector

Any objects or lists of objects used in the query are specified using the [varname]+selector+ attribute. The [varname]+selector+ attribute references objects using the following method:

* The [varname]+selector+ attribute can refer to the elements by using syntax of the jQuery Selectors (a superset of CSS selectors defined by W3C consortium) and additionally it expands JSF component IDs to client-side IDs (see the VDL documentation for the [varname]+selector+ attribute).
* If the [varname]+selector+ attribute does not match the [varname]+id+ identifier attribute of any JSF components or clients on the page, it instead uses syntax defined by the World Wide Web Consortium (W3C)for the [acronym]#CSS# rule selector.
Refer to the syntax specification at http://api.jquery.com/category/selectors/ for full details.

Because the [varname]+selector+ attribute can be either an [varname]+id+ identifier attribute or CSS selector syntax, conflicting values could arise. <<exam-Component_Reference-jQuery-Avoiding_syntax_confusion>> demonstrates how to use double backslashes to escape colon characters in [varname]+id+ identifier values.

[[exam-Component_Reference-jQuery-Avoiding_syntax_confusion]]

.Avoiding syntax confusion
====


[source, XML]
----
<h:form id="form">
    <h:panelGrid id="menu">
        <h:graphicImage value="pic1.jpg" />
        <h:graphicImage value="pic2.jpg" />
    </h:panelGrid>
</h:form>

----

The [varname]+id+ identifier for the [sgmltag]+<h:panelGrid>+ element is +form:menu+, which can conflict with CSS selector syntax. Double backslashes can be used to escape the colon character such that the identifier is read correctly instead of being interpreted as CSS selector syntax.


[source, XML]
----
<rich:jQuery selector="#form\\:menu img" query="..." />

----

====

[[sect-Component_Reference-jQuery-Event_handlers]]

==== Event handlers

Queries set as event handlers are triggered when the component specified in the [varname]+selector+ attribute raises an event. The query is bound to the event defined using the [varname]+event+ attribute.

Use the [varname]+attachType+ attribute to specify how the event-handling queries are attached to the events:

+bind+:: This is the default for attaching queries to events. The event handler is bound to all elements currently defined by the [varname]+selector+ attribute.
+live+:: The event handler is bound to all current and future elements defined by the [varname]+selector+ attribute.
+one+:: The event handler is bound to all elements currently defined by the [varname]+selector+ attribute. After the first invocation of the event, the event handler is unbound such that it no longer fires when the event is raised.
[[sect-Component_Reference-jQuery-Timed_queries]]

==== Timed queries

Timed queries are triggered at specified times. This can be useful for calling simple methods when a page is rendered, or for adding specific functionality to an element. Use the [varname]+timing+ attribute to specify the point at which the timed query is triggered:

+domready+:: This is the default behavior. The query is triggered when the document is loaded and the DOM is ready. The query is called as a [methodname]+jQuery()+ function.
+immediate+:: The query is triggered immediately. The query is called as an in-line script.
[[exam-Component_Reference-jQuery-jQuery_example]]

.[sgmltag]+<rich:jQuery>+ example
====


[source, XML]
----
<rich:dataTable id="customList" ... >
   ...
</rich:dataTable>

<rich:jQuery selector="#customList tr:odd" timing="domready" query="addClass(odd)" />

----

In the example, the selector picks out the odd [sgmltag]+<tr>+ elements that are children of the element with an [code]+id="customlist"+ attribute. The query [code]+addClass(odd)+ is then performed on the selection during page loading ( +load+) such that the +odd+ CSS class is added to the selected elements.

image::Component_Reference-jQuery-jQuery_example.png[A table highlighted in a "zebra" fashion, with every odd row colored.]

====

[[sect-Component_Reference-jQuery-Named_queries]]

==== Named queries

Named queries are given a name such that they can be triggered by other functions or handlers. Use the [varname]+name+ attribute to name the query. The query can then be accessed as though it were a JavaScript function using the specified [varname]+name+ attribute as the function name.

Calls to the function must pass a direct reference ( +this+) to the calling object as a parameter. This is treated the same as an item defined through the [varname]+selector+ attribute.

If the function requires extra parameters itself, these are provided in JavaScript Object Notation (JSON) syntax as a second parameter in the JavaScript call. The +options+ namespace is then used in the [sgmltag]+<rich:jQuery>+ query to access the passed function parameters. <<exam-Component_Reference-jQuery-Calling_a_jQuery_component_as_a_function>> demonstrates the use of the [varname]+name+ attribute and how to pass function parameters through the JavaScript calls.

[[exam-Component_Reference-jQuery-Calling_a_jQuery_component_as_a_function]]

.Calling a [sgmltag]+<rich:jQuery>+ component as a function
====


[source, XML]
----
<h:graphicImage width="50" value="/images/price.png" onmouseover="enlargePic(this, {pwidth:'60px'})" onmouseout="releasePic(this)"  />
<h:graphicImage width="50" value="/images/discount.png" onmouseover="enlargePic(this, {pwidth:'100px'})" onmouseout="releasePic(this)"  />
...
<rich:jQuery name="enlargePic" query="animate({width:options.pwidth})" />
<rich:jQuery name="releasePic" query="animate({width:'50px'})"/>

----

The example enlarges the images when the mouse moves over them. The +enlargePic+ and +releasePic+ components are called like ordinary JavaScript functions from the image elements.

====

[[sect-Component_Reference-jQuery-Dynamic_rendering]]

==== Dynamic rendering

The [sgmltag]+<rich:jQuery>+ component applies style and behavioral changes to DOM objects dynamically. As such, changes applied during an Ajax response are overwritten, and will need to be re-applied once the Ajax response is complete.

Any timed queries with the [varname]+timing+ attribute set to +domready+ may not update during an Ajax response, as the DOM document is not completely reloaded. To ensure the query is re-applied after an Ajax response, include the [varname]+name+ attribute in the [sgmltag]+<rich:jQuery>+ component and invoke it using JavaScript from the [varname]+complete+ event attribute of the component that triggered the Ajax interaction.

[[sect-Component_Reference-jQuery-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.JQuery+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIJQuery+
* [parameter]+component-family+: [classname]+org.richfaces.JQuery+
* [parameter]+renderer-type+: [classname]+org.richfaces.JQueryRenderer+


[[chap-Component_Reference-Functions]]

== Functions

Read this chapter for details on special functions for use with particular components. Using JavaServer Faces Expression Language ( [acronym]#JSF# [acronym]#EL#), these functions can be accessed through the [varname]+data+ attribute of components. Refer to <<sect-Component_Reference-Events_and_JavaScript_interactions-data>> for details on the [varname]+data+ attribute.

[[sect-Component_Reference-Functions-clientId]]

=== [function]+rich:clientId+

The [function]+`rich:clientId('id')`+ function returns the client identifier related to the passed component identifier ([code]+`'id'`+). If the specified component identifier is not found, +null+ is returned instead.

[[sect-Component_Reference-Functions-component]]

=== [function]+rich:component+

The [function]+`rich:component('id')`+ function is equivalent to the [code]+`RichFaces.component('clientId')`+ code. It returns the client object instance based on the passed server-side component identifier ( [code]+`'id'`+). If the specified component identifier is not found, +null+ is returned instead. The function can be used to get an object from a component to call a JavaScript API function without using the [sgmltag]+<rich:componentControl>+ component.

[[sect-Component_Reference-Functions-element]]

=== [function]+rich:element+

The [function]+`rich:element('id')`+ function is a shortcut for the equivalent [code]+`document.getElementById(#{rich:clientId('id')})`+ code. It returns the element from the client, based on the passed server-side component identifier. If the specified component identifier is not found, +null+ is returned instead.

[[sect-Component_Reference-Functions-jquery]]

=== [function]+rich:jQuery+

The [function]+`rich:jQuery('id')`+ function is a shortcut for the equivalent [code]+`jQuery('##{rich:clientId('id')})`+ code. It returns the jQuery object for the element located by the passed server-side component identifier. If the specified component identifier is not found, +null+ is returned instead.

[[sect-Component_Reference-Functions-findComponent]]

=== [function]+rich:findComponent+

The [function]+`rich:findComponent('id')`+ function returns the a UIComponent instance of the passed component identifier. If the specified component identifier is not found, +null+ is returned instead.

[[exam-Component_Reference-findComponent-findComponent_example]]

.[function]+rich:findComponent+ example
====


[source, XML]
----
<h:inputText id="myInput">
   <rich:support event="keyup" render="outtext"/>
</h:inputText>
<h:outputText id="outtext" value="#{rich:findComponent('myInput').value}" />

----

====

[[sect-Component_Reference-Functions-isUserInRole]]

=== [function]+rich:isUserInRole+

The [function]+rich:isUserInRole(Object)+ function checks whether the logged-in user belongs to a certain user role, such as being an administrator. User roles are defined in the [filename]+web.xml+ settings file.

[[exam-Component_Reference-isUserInRole-isUserInRole_example]]

.[function]+rich:isUserInRole+ example
====

The [function]+rich:isUserInRole(Object)+ function can be used in conjunction with the [varname]+rendered+ attribute of a component to only display certain controls to authorized users.


[source, XML]
----
<rich:editor value="#{bean.text}" rendered="#{rich:isUserInRole('admin')}"/>

----

====

[[chap-Component_Reference-Functionality_extension]]

== Functionality extension

Read this chapter for details on miscellaneous components that provide extended functionality to web applications.

[[sect-Component_Reference-Functionality_extension-componentControl]]

=== [sgmltag]+<rich:componentControl>+

The [sgmltag]+<rich:componentControl>+ behavior allows JavaScript API functions to be called on target components. The functions are called after defined events are triggered on the component to with the [sgmltag]+<rich:componentControl>+ behavior is attached. Initialization variants and activation events can be customized, and parameters can be passed to the target component.

[[sect-Component_Reference-componentControl-Basic_usage]]

==== Basic usage

The [varname]+operation+ attribute is required to attach JavaScript functions to the parent component, along with either the [varname]+target+ or [varname]+selector+ attributes. Use the [varname]+operation+ attribute to specify the JavaScript API function to perform. Use the [varname]+target+ attribute to define the [varname]+id+ identifier of the target component, or use the [varname]+selector+ attribute to define a number of target components through the use of valid jQuery selectors.

Use the [varname]+event+ attribute to specify the event that triggers the JavaScript API function call if it is different from the default triggering event for the parent component.

[[exam-Component_Reference-componentControl-componentControl_basic_usage]]

.[sgmltag]+<rich:componentControl>+ basic usage
====


[source, XML]
----
<h:commandButton value="Show Modal Panel">
    <!--componentControl is attached to the commandButton-->
    <rich:componentControl target="ccModalPanelID" event="click" operation="show"/>
</h:commandButton>

----

The example contains a single command button, which when clicked shows the modal panel with the identifier +ccModalPanelID+.

====

[[sect-Component_Reference-componentControl-Passing_parameters_to_API_methods]]

==== Passing parameters to API methods

The operation can receive parameters through nested [sgmltag]+<f:param>+ elements.

[[exam-Component_Reference-componentControl-Using_parameters]]

.Using parameters
====


[source, XML]
----
<rich:componentControl event="click" target="modalPanel" operation="show">
   <f:param value="width" name="500"/>
</rich:componentControl>

----

====

To group multiple parameters for a function, use the [sgmltag]+<rich:hashParam>+ component to create a hash map. Refer to <<sect-Component_Reference-Functionality_extension-hashParam>> for details.

[[sect-Component_Reference-componentControl-Reference_data]]

==== Reference data

* [parameter]+client-behavior-renderer-type+: [classname]+org.richfaces.behavior.ComponentControlBehavior+
* [parameter]+behavior-id+: [classname]+org.richfaces.behavior.ComponentControlBehavior+
* [parameter]+handler-class+: [classname]+org.richfaces.taglib.ComponentControlHandler+
* [parameter]+behavior-class+: [classname]+org.richfaces.component.behavior.ComponentControlBehavior+
* [parameter]+client-behavior-renderer-class+: [classname]+org.richfaces.renderkit.html.ToggleControlRenderer+


[[sect-Component_Reference-Functionality_extension-focus]]

=== [sgmltag]+<rich:focus>+

The [sgmltag]+<rich:focus>+ component allows one to manipulate the focus of components on a page. It is intended to be used with any input field.

[[sect-Component_Reference-focus-Placement]]

==== Placement

The component will behave differently when placed:

* in a form - defines behavior for components in the given form
* in a view (outside of forms) - defines behavior for components in all forms in the view


There can be only one focus per form.

If both, form- and view-based focuses are defined, the form one takes a priority.

[[sect-Component_Reference-focus-Applying_focus]]

==== Applying Focus

The focus is applied each time it is rendered - either on form submission or after an AJAX request. Only focuses inside the form which is submitted are applied.

You can turn focusing-after-AJAX-requests off by setting the [varname]+ajaxRendered+ attribute to [varname]+false+.

[[sect-Component_Reference-focus-Validation_aware]]

==== Validation-Aware

The [sgmltag]+<rich:focus>+ component reflects the results of validation of components in a view. Focus is given to the first input component in the page which is invalid.

If all components are valid, then first component in the form is focused.

The order of input components is determined on the client-side and reflects the [varname]+tabindex+ and position in the page. You can prioritize the focusing of a specific component by increasing its tabindex.

You can turn validation awareness off by setting the [varname]+validationAware+ attribute to [varname]+false+.

[[figu-Component_Reference-focus-Validation_aware]]
.Validation-aware [sgmltag]+<rich:focus>+
image::figu-Component_Reference-focus-Validation_aware.png[]


[[sect-Component_Reference-focus-Preserving_focus]]

==== Preserving Focus

Focus can be configured to keep focus on the input component which had focus before sending the JSF request (using either AJAX or form submission).

[[exam-Component_Reference-focus-focus_preserving_focus]]

.[sgmltag]+<rich:focus>+ preserving focus
====


[source, XML]
----
<h:form>
    <rich:focus preserve="true" />

    <h:inputText id="query" value="#{query}" />
    <a4j:commandButton value="Search" render="output" />

    <h:outputText value="Searched query:" />
    <h:outputText id="output" value="#{query}" />
</h:form>
----

In the example above, everytime the user hits Search (or hits enter), the focus is given back to the query input after the request.

====

This configuration will take priority over any other focus setup.

[[sect-Component_Reference-focus-Delaying_focus]]

==== Delaying Focus

In certain situations, focus needs to be applied with a delay - once suitable conditions are met.

By configuring a focus with the attribute [varname]+delayed+ to [varname]+true+, the focus won't be applied on initial page request.

Then it is possible to call the [varname]+applyFocus()+ JavaScript API method in order to let the focus be applied.

[[sect-Component_Reference-focus-Focus_Manager]]

==== Focus Manager

For a situation when none of the options above help one to achieve the desired focus behavior, one can use the server-side component [varname]+FocusManager+.

A component focus chosen by the [varname]+FocusManager+ will take priority over any focus configuration.

[[exam-Component_Reference-focus-Focus_Manager]]

.[sgmltag]+<rich:focus>+ preserving focus
====


[source, Java]
----
FocusManager focusManager = ServiceTracker.getService(FocusManager.class);
focusManager.focus("input2");
----

====

[[sect-Component_Reference-focus-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Focus+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIFocus+
* [parameter]+component-family+: [classname]+org.richfaces.Focus+
* [parameter]+renderer-type+: [classname]+org.richfaces.FocusRenderer+


[[sect-Component_Reference-Functionality_extension-hotKey]]

=== [sgmltag]+<rich:hotKey>+

The [sgmltag]+<rich:hotKey>+ component allows one to register hot keys for the page or particular elements and to define client-side processing functions for these keys.

[[sect-Component_Reference-hotKey-Basic_usage]]

==== Basic usage

There are two ways to register [sgmltag]+<rich:hotKey>+:

* place it anywhere on the page. In this case the [sgmltag]+<rich:hotKey>+ component is attached to the whole page. This is the default scenario.
* attach it to specific elements by defining the [varname]+selector+ attribute. This attribute uses the syntax of the jQuery Selectors (a superset of CSS selectors defined by W3C consortium) and additionally it expands JSF component IDs to client-side IDs (see the VDL documentation for the [varname]+selector+ attribute).


The [varname]+key+ attribute defines the hot key itself, which is processed by the component.

The key sequences can be defined using a " [code]+$$+$$+" key separator. The key sequence modifiers needs to be defined in alphabetical order, e.g. [code]+$$alt+ctrl+shift$$+.

Hot key processing can be disabled by setting [varname]+rendered+ to [code]+false+.

[[exam-Component_Reference-hotkey-hotkey_basic_usage]]

.[sgmltag]+<rich:hotKey>+ basic usage
====


[source, XML]
----
<rich:hotKey key="ctrl+z">
    <rich:componentControl target="popup" operation="show" />
</rich:hotKey>

<rich:popupPanel id="popup">
	...
</rich:popupPanel>
----

The example contains [sgmltag]+<rich:hotKey>+ which handles the [code]+$$Ctrl+Z$$+ key sequence on the whole page. When the key sequence is pressed, the [sgmltag]+<rich:popupPanel>+ is displayed.

====

[[sect-Component_Reference-hotKey-Event_processing]]

==== Event processing

The [varname]+enabledInInput+ attribute enables the hot key event processing when form inputs are focused. This attribute is [code]+false+ by default.

The [varname]+preventDefault+ attribute specifies whether the hot key binding should prevent default browser-specific actions to be taken (e.g. [code]+$$Ctrl+A$$+ hot key selecting all available text, Ctrl+B opening bookmarks bar, etc.). This attribute has a default value of [code]+true+.

[NOTE]
.Cross-browser support for preventing default actions
====
Even though RichFaces instructs the browser to prevent the default action, browser implementations do not support preventing browser's native actions for selected key combinations.

Although the inability to prevent default action is not usual, you may experience that both the programatically-defined action and the browser's native action are triggered (e.g. native popup appears).

To keep an application accessible, it is convenient to not depend on hot keys or hot key combinations heavily. Best practice is using a hot key only as shortcut for a given action.
====

[[sect-Component_Reference-hotKey-Event_handlers]]

==== Event handlers

The following event handlers could be used to trigger client-side behaviors or to invoke javascript directly:

* [varname]+keydown+ (default event) is fired when the hot key sequence is initiated (the keys are down)
* [varname]+keyup+ is fired when the hot key sequence is finished (the keys are up)


[[exam-Component_Reference-hotKey-hotkKey_event_handlers]]

.[sgmltag]+<rich:hotKey>+ event handlers
====


[source, XML]
----
<rich:hotKey key="ctrl+a" onkeyup="alert('Ctrl+A was pressed')" />
----

====

[NOTE]
.Hot Key in Editor
====
The [sgmltag]+<rich:editor>+ uses [sgmltag]+<iframe>+ for the editable area.

The [sgmltag]+<iframe>+ doesn't allow one to propagate events outside of the [sgmltag]+<rich:editor>+, making [sgmltag]+<rich:hotKey>+ unusable for handling events from [sgmltag]+<rich:editor>+.

The CKEditor specific event handling mechanism should be used instead.
====

[[sect-Component_Reference-hotKey-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.HotKey+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIHotKey+
* [parameter]+component-family+: [classname]+org.richfaces.HotKey+
* [parameter]+renderer-type+: [classname]+org.richfaces.HotKeyRenderer+


[[sect-Component_Reference-Functionality_extension-hashParam]]

=== [sgmltag]+<rich:hashParam>+

The [sgmltag]+<rich:hashParam>+ component allows client-side parameters to be grouped into a hash map. The hash map can then be passed to the client JavaScript API functions of any RichFaces component.

[[sect-Component_Reference-hashParam-Basic_usage]]

==== Basic usage

Nest parameter tags in the [sgmltag]+<rich:hashParam>+ component to group them in the hash map. The hash map itself can then be passed as a function parameter.

[[exam-Component_Reference-hashParam-hashParam]]

.[sgmltag]+<rich:hashParam>+
====


[source, XML]
----
<h:commandButton value="Show popup">
   <rich:componentControl target="popupPanel" operation="show">
      <a4j:param noEscape="true" value="event" />
      <rich:hashParam>
         <f:param name="width" value="500" />
         <f:param name="height" value="300" />
         <f:param name="minWidth" value="300" />
         <f:param name="minHeight" value="150" />
         <a4j:param noEscape="true" name="left" value="(jQuery(window).width()/2)-250" />
         <a4j:param noEscape="true" name="top" value="(jQuery(window).height()/2)-150" />
      </rich:hashParam>
   </rich:componentControl>
</h:commandButton>

----

The example illustrates the use of the [sgmltag]+<rich:hashParam>+ component to group multiple parameters into a hash map. The parameters are passed through to the [function]+show+ function pop-up panel with the +popupPanel+ identifier.

====

[[sect-Component_Reference-hashParam-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.HashParameter+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIHashParameter+
* [parameter]+component-family+: [classname]+org.richfaces.HashParameter+
* [parameter]+handler-class+: [classname]+javax.faces.view.facelets.ComponentHandler+


[[sect-Component_Reference-Functionality_extension-placeholder]]

=== [sgmltag]+<rich:placeholder>+

The [sgmltag]+<rich:placeholder>+ component allows one to use functionality similar to the HTML5 [varname]+placeholder+ attribute for input components.

This component brings a backward compatibility for HTML5 non-compliant browsers and some additional features:

* per-component styling using [varname]+styleClass+ attribute
* application to multiple components at once using [varname]+selector+ attribute


[[exam-Component_Reference-placeholder-Input_components]]

.[sgmltag]+<rich:placeholder>+ with input components
====


[source, XML]
----
<h:outputLabel value="Input text:" />
<h:inputText id="input">
    <rich:placeholder value="Type text here..." />
</h:inputText>

<h:outputLabel value="Textarea:" />
<h:inputTextarea id="textarea">
    <rich:placeholder value="A space for long content..." />
</h:inputTextarea>

<h:outputLabel value="Date:" />
<rich:calendar datePattern="dd/M/yyyy" enableManualInput="true">
    <rich:placeholder value="dd/mm/yyyy" />
</rich:calendar>
----

====

[[figu-Component_Reference-placeholder-Input_components]]
.[sgmltag]+<rich:placeholder>+
image::figu-Component_Reference-placeholder-Input_components.png[]


[[sect-Component_Reference-placeholder-Reference_data]]

==== Reference data

* [parameter]+component-type+: [classname]+org.richfaces.Placeholder+
* [parameter]+component-class+: [classname]+org.richfaces.component.UIPlaceholder+
* [parameter]+component-family+: [classname]+org.richfaces.Placeholder+
* [parameter]+renderer-type+: [classname]+org.richfaces.PlaceholderRenderer+


[[sect-Component_Reference-placeholder-Style_classes_and_skin_parameters]]

==== Style classes and skin parameters

include::skinning/placeholder.asciidoc[]
